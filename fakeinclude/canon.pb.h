// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: machinetalk/protobuf/canon.proto

#ifndef PROTOBUF_INCLUDED_machinetalk_2fprotobuf_2fcanon_2eproto
#define PROTOBUF_INCLUDED_machinetalk_2fprotobuf_2fcanon_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "machinetalk/protobuf/nanopb.pb.h"
#include "machinetalk/protobuf/types.pb.h"
#include "machinetalk/protobuf/emcclass.pb.h"
#include "machinetalk/protobuf/motcmds.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_machinetalk_2fprotobuf_2fcanon_2eproto 

namespace protobuf_machinetalk_2fprotobuf_2fcanon_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[30];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_machinetalk_2fprotobuf_2fcanon_2eproto
namespace machinetalk {
class Emc_Aux_Input_Wait;
class Emc_Aux_Input_WaitDefaultTypeInternal;
extern Emc_Aux_Input_WaitDefaultTypeInternal _Emc_Aux_Input_Wait_default_instance_;
class Emc_Exec_Plugin_Ca1l;
class Emc_Exec_Plugin_Ca1lDefaultTypeInternal;
extern Emc_Exec_Plugin_Ca1lDefaultTypeInternal _Emc_Exec_Plugin_Ca1l_default_instance_;
class Emc_Io_Plugin_Call;
class Emc_Io_Plugin_CallDefaultTypeInternal;
extern Emc_Io_Plugin_CallDefaultTypeInternal _Emc_Io_Plugin_Call_default_instance_;
class Emc_Motion_Adaptive;
class Emc_Motion_AdaptiveDefaultTypeInternal;
extern Emc_Motion_AdaptiveDefaultTypeInternal _Emc_Motion_Adaptive_default_instance_;
class Emc_Motion_Set_Aout;
class Emc_Motion_Set_AoutDefaultTypeInternal;
extern Emc_Motion_Set_AoutDefaultTypeInternal _Emc_Motion_Set_Aout_default_instance_;
class Emc_Motion_Set_Dout;
class Emc_Motion_Set_DoutDefaultTypeInternal;
extern Emc_Motion_Set_DoutDefaultTypeInternal _Emc_Motion_Set_Dout_default_instance_;
class Emc_Operator_Display;
class Emc_Operator_DisplayDefaultTypeInternal;
extern Emc_Operator_DisplayDefaultTypeInternal _Emc_Operator_Display_default_instance_;
class Emc_Operator_Error;
class Emc_Operator_ErrorDefaultTypeInternal;
extern Emc_Operator_ErrorDefaultTypeInternal _Emc_Operator_Error_default_instance_;
class Emc_Operator_Text;
class Emc_Operator_TextDefaultTypeInternal;
extern Emc_Operator_TextDefaultTypeInternal _Emc_Operator_Text_default_instance_;
class Emc_Spindle_On;
class Emc_Spindle_OnDefaultTypeInternal;
extern Emc_Spindle_OnDefaultTypeInternal _Emc_Spindle_On_default_instance_;
class Emc_Spindle_Orient;
class Emc_Spindle_OrientDefaultTypeInternal;
extern Emc_Spindle_OrientDefaultTypeInternal _Emc_Spindle_Orient_default_instance_;
class Emc_Spindle_Speed;
class Emc_Spindle_SpeedDefaultTypeInternal;
extern Emc_Spindle_SpeedDefaultTypeInternal _Emc_Spindle_Speed_default_instance_;
class Emc_Spindle_Wait_Orient_Complete;
class Emc_Spindle_Wait_Orient_CompleteDefaultTypeInternal;
extern Emc_Spindle_Wait_Orient_CompleteDefaultTypeInternal _Emc_Spindle_Wait_Orient_Complete_default_instance_;
class Emc_Tool_Prepare;
class Emc_Tool_PrepareDefaultTypeInternal;
extern Emc_Tool_PrepareDefaultTypeInternal _Emc_Tool_Prepare_default_instance_;
class Emc_Tool_Set_Number;
class Emc_Tool_Set_NumberDefaultTypeInternal;
extern Emc_Tool_Set_NumberDefaultTypeInternal _Emc_Tool_Set_Number_default_instance_;
class Emc_Tool_Set_Offset;
class Emc_Tool_Set_OffsetDefaultTypeInternal;
extern Emc_Tool_Set_OffsetDefaultTypeInternal _Emc_Tool_Set_Offset_default_instance_;
class Emc_Traj_Circular_Move;
class Emc_Traj_Circular_MoveDefaultTypeInternal;
extern Emc_Traj_Circular_MoveDefaultTypeInternal _Emc_Traj_Circular_Move_default_instance_;
class Emc_Traj_Delay;
class Emc_Traj_DelayDefaultTypeInternal;
extern Emc_Traj_DelayDefaultTypeInternal _Emc_Traj_Delay_default_instance_;
class Emc_Traj_Linear_Move;
class Emc_Traj_Linear_MoveDefaultTypeInternal;
extern Emc_Traj_Linear_MoveDefaultTypeInternal _Emc_Traj_Linear_Move_default_instance_;
class Emc_Traj_Probe;
class Emc_Traj_ProbeDefaultTypeInternal;
extern Emc_Traj_ProbeDefaultTypeInternal _Emc_Traj_Probe_default_instance_;
class Emc_Traj_Rigid_Tap;
class Emc_Traj_Rigid_TapDefaultTypeInternal;
extern Emc_Traj_Rigid_TapDefaultTypeInternal _Emc_Traj_Rigid_Tap_default_instance_;
class Emc_Traj_Set_Fh_Enable;
class Emc_Traj_Set_Fh_EnableDefaultTypeInternal;
extern Emc_Traj_Set_Fh_EnableDefaultTypeInternal _Emc_Traj_Set_Fh_Enable_default_instance_;
class Emc_Traj_Set_Fo_Enable;
class Emc_Traj_Set_Fo_EnableDefaultTypeInternal;
extern Emc_Traj_Set_Fo_EnableDefaultTypeInternal _Emc_Traj_Set_Fo_Enable_default_instance_;
class Emc_Traj_Set_G5x;
class Emc_Traj_Set_G5xDefaultTypeInternal;
extern Emc_Traj_Set_G5xDefaultTypeInternal _Emc_Traj_Set_G5x_default_instance_;
class Emc_Traj_Set_G92;
class Emc_Traj_Set_G92DefaultTypeInternal;
extern Emc_Traj_Set_G92DefaultTypeInternal _Emc_Traj_Set_G92_default_instance_;
class Emc_Traj_Set_Offset;
class Emc_Traj_Set_OffsetDefaultTypeInternal;
extern Emc_Traj_Set_OffsetDefaultTypeInternal _Emc_Traj_Set_Offset_default_instance_;
class Emc_Traj_Set_Rotation;
class Emc_Traj_Set_RotationDefaultTypeInternal;
extern Emc_Traj_Set_RotationDefaultTypeInternal _Emc_Traj_Set_Rotation_default_instance_;
class Emc_Traj_Set_So_Enable;
class Emc_Traj_Set_So_EnableDefaultTypeInternal;
extern Emc_Traj_Set_So_EnableDefaultTypeInternal _Emc_Traj_Set_So_Enable_default_instance_;
class Emc_Traj_Set_Spindlesync;
class Emc_Traj_Set_SpindlesyncDefaultTypeInternal;
extern Emc_Traj_Set_SpindlesyncDefaultTypeInternal _Emc_Traj_Set_Spindlesync_default_instance_;
class Emc_Traj_Set_Term_Cond;
class Emc_Traj_Set_Term_CondDefaultTypeInternal;
extern Emc_Traj_Set_Term_CondDefaultTypeInternal _Emc_Traj_Set_Term_Cond_default_instance_;
}  // namespace machinetalk
namespace google {
namespace protobuf {
template<> ::machinetalk::Emc_Aux_Input_Wait* Arena::CreateMaybeMessage<::machinetalk::Emc_Aux_Input_Wait>(Arena*);
template<> ::machinetalk::Emc_Exec_Plugin_Ca1l* Arena::CreateMaybeMessage<::machinetalk::Emc_Exec_Plugin_Ca1l>(Arena*);
template<> ::machinetalk::Emc_Io_Plugin_Call* Arena::CreateMaybeMessage<::machinetalk::Emc_Io_Plugin_Call>(Arena*);
template<> ::machinetalk::Emc_Motion_Adaptive* Arena::CreateMaybeMessage<::machinetalk::Emc_Motion_Adaptive>(Arena*);
template<> ::machinetalk::Emc_Motion_Set_Aout* Arena::CreateMaybeMessage<::machinetalk::Emc_Motion_Set_Aout>(Arena*);
template<> ::machinetalk::Emc_Motion_Set_Dout* Arena::CreateMaybeMessage<::machinetalk::Emc_Motion_Set_Dout>(Arena*);
template<> ::machinetalk::Emc_Operator_Display* Arena::CreateMaybeMessage<::machinetalk::Emc_Operator_Display>(Arena*);
template<> ::machinetalk::Emc_Operator_Error* Arena::CreateMaybeMessage<::machinetalk::Emc_Operator_Error>(Arena*);
template<> ::machinetalk::Emc_Operator_Text* Arena::CreateMaybeMessage<::machinetalk::Emc_Operator_Text>(Arena*);
template<> ::machinetalk::Emc_Spindle_On* Arena::CreateMaybeMessage<::machinetalk::Emc_Spindle_On>(Arena*);
template<> ::machinetalk::Emc_Spindle_Orient* Arena::CreateMaybeMessage<::machinetalk::Emc_Spindle_Orient>(Arena*);
template<> ::machinetalk::Emc_Spindle_Speed* Arena::CreateMaybeMessage<::machinetalk::Emc_Spindle_Speed>(Arena*);
template<> ::machinetalk::Emc_Spindle_Wait_Orient_Complete* Arena::CreateMaybeMessage<::machinetalk::Emc_Spindle_Wait_Orient_Complete>(Arena*);
template<> ::machinetalk::Emc_Tool_Prepare* Arena::CreateMaybeMessage<::machinetalk::Emc_Tool_Prepare>(Arena*);
template<> ::machinetalk::Emc_Tool_Set_Number* Arena::CreateMaybeMessage<::machinetalk::Emc_Tool_Set_Number>(Arena*);
template<> ::machinetalk::Emc_Tool_Set_Offset* Arena::CreateMaybeMessage<::machinetalk::Emc_Tool_Set_Offset>(Arena*);
template<> ::machinetalk::Emc_Traj_Circular_Move* Arena::CreateMaybeMessage<::machinetalk::Emc_Traj_Circular_Move>(Arena*);
template<> ::machinetalk::Emc_Traj_Delay* Arena::CreateMaybeMessage<::machinetalk::Emc_Traj_Delay>(Arena*);
template<> ::machinetalk::Emc_Traj_Linear_Move* Arena::CreateMaybeMessage<::machinetalk::Emc_Traj_Linear_Move>(Arena*);
template<> ::machinetalk::Emc_Traj_Probe* Arena::CreateMaybeMessage<::machinetalk::Emc_Traj_Probe>(Arena*);
template<> ::machinetalk::Emc_Traj_Rigid_Tap* Arena::CreateMaybeMessage<::machinetalk::Emc_Traj_Rigid_Tap>(Arena*);
template<> ::machinetalk::Emc_Traj_Set_Fh_Enable* Arena::CreateMaybeMessage<::machinetalk::Emc_Traj_Set_Fh_Enable>(Arena*);
template<> ::machinetalk::Emc_Traj_Set_Fo_Enable* Arena::CreateMaybeMessage<::machinetalk::Emc_Traj_Set_Fo_Enable>(Arena*);
template<> ::machinetalk::Emc_Traj_Set_G5x* Arena::CreateMaybeMessage<::machinetalk::Emc_Traj_Set_G5x>(Arena*);
template<> ::machinetalk::Emc_Traj_Set_G92* Arena::CreateMaybeMessage<::machinetalk::Emc_Traj_Set_G92>(Arena*);
template<> ::machinetalk::Emc_Traj_Set_Offset* Arena::CreateMaybeMessage<::machinetalk::Emc_Traj_Set_Offset>(Arena*);
template<> ::machinetalk::Emc_Traj_Set_Rotation* Arena::CreateMaybeMessage<::machinetalk::Emc_Traj_Set_Rotation>(Arena*);
template<> ::machinetalk::Emc_Traj_Set_So_Enable* Arena::CreateMaybeMessage<::machinetalk::Emc_Traj_Set_So_Enable>(Arena*);
template<> ::machinetalk::Emc_Traj_Set_Spindlesync* Arena::CreateMaybeMessage<::machinetalk::Emc_Traj_Set_Spindlesync>(Arena*);
template<> ::machinetalk::Emc_Traj_Set_Term_Cond* Arena::CreateMaybeMessage<::machinetalk::Emc_Traj_Set_Term_Cond>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace machinetalk {

// ===================================================================

class Emc_Traj_Set_G5x : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Traj_Set_G5x) */ {
 public:
  Emc_Traj_Set_G5x();
  virtual ~Emc_Traj_Set_G5x();

  Emc_Traj_Set_G5x(const Emc_Traj_Set_G5x& from);

  inline Emc_Traj_Set_G5x& operator=(const Emc_Traj_Set_G5x& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Traj_Set_G5x(Emc_Traj_Set_G5x&& from) noexcept
    : Emc_Traj_Set_G5x() {
    *this = ::std::move(from);
  }

  inline Emc_Traj_Set_G5x& operator=(Emc_Traj_Set_G5x&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_G5x& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Traj_Set_G5x* internal_default_instance() {
    return reinterpret_cast<const Emc_Traj_Set_G5x*>(
               &_Emc_Traj_Set_G5x_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Emc_Traj_Set_G5x* other);
  friend void swap(Emc_Traj_Set_G5x& a, Emc_Traj_Set_G5x& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Traj_Set_G5x* New() const final {
    return CreateMaybeMessage<Emc_Traj_Set_G5x>(NULL);
  }

  Emc_Traj_Set_G5x* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Traj_Set_G5x>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Traj_Set_G5x& from);
  void MergeFrom(const Emc_Traj_Set_G5x& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Traj_Set_G5x* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .machinetalk.EmcPose origin = 10;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 10;
  private:
  const ::machinetalk::EmcPose& _internal_origin() const;
  public:
  const ::machinetalk::EmcPose& origin() const;
  ::machinetalk::EmcPose* release_origin();
  ::machinetalk::EmcPose* mutable_origin();
  void set_allocated_origin(::machinetalk::EmcPose* origin);

  // required .machinetalk.OriginIndex g5x_index = 20;
  bool has_g5x_index() const;
  void clear_g5x_index();
  static const int kG5XIndexFieldNumber = 20;
  ::machinetalk::OriginIndex g5x_index() const;
  void set_g5x_index(::machinetalk::OriginIndex value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Traj_Set_G5x)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_g5x_index();
  void clear_has_g5x_index();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::machinetalk::EmcPose* origin_;
  int g5x_index_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Traj_Set_G92 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Traj_Set_G92) */ {
 public:
  Emc_Traj_Set_G92();
  virtual ~Emc_Traj_Set_G92();

  Emc_Traj_Set_G92(const Emc_Traj_Set_G92& from);

  inline Emc_Traj_Set_G92& operator=(const Emc_Traj_Set_G92& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Traj_Set_G92(Emc_Traj_Set_G92&& from) noexcept
    : Emc_Traj_Set_G92() {
    *this = ::std::move(from);
  }

  inline Emc_Traj_Set_G92& operator=(Emc_Traj_Set_G92&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_G92& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Traj_Set_G92* internal_default_instance() {
    return reinterpret_cast<const Emc_Traj_Set_G92*>(
               &_Emc_Traj_Set_G92_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Emc_Traj_Set_G92* other);
  friend void swap(Emc_Traj_Set_G92& a, Emc_Traj_Set_G92& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Traj_Set_G92* New() const final {
    return CreateMaybeMessage<Emc_Traj_Set_G92>(NULL);
  }

  Emc_Traj_Set_G92* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Traj_Set_G92>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Traj_Set_G92& from);
  void MergeFrom(const Emc_Traj_Set_G92& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Traj_Set_G92* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .machinetalk.EmcPose origin = 10;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 10;
  private:
  const ::machinetalk::EmcPose& _internal_origin() const;
  public:
  const ::machinetalk::EmcPose& origin() const;
  ::machinetalk::EmcPose* release_origin();
  ::machinetalk::EmcPose* mutable_origin();
  void set_allocated_origin(::machinetalk::EmcPose* origin);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Traj_Set_G92)
 private:
  void set_has_origin();
  void clear_has_origin();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::machinetalk::EmcPose* origin_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Traj_Set_Rotation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Traj_Set_Rotation) */ {
 public:
  Emc_Traj_Set_Rotation();
  virtual ~Emc_Traj_Set_Rotation();

  Emc_Traj_Set_Rotation(const Emc_Traj_Set_Rotation& from);

  inline Emc_Traj_Set_Rotation& operator=(const Emc_Traj_Set_Rotation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Traj_Set_Rotation(Emc_Traj_Set_Rotation&& from) noexcept
    : Emc_Traj_Set_Rotation() {
    *this = ::std::move(from);
  }

  inline Emc_Traj_Set_Rotation& operator=(Emc_Traj_Set_Rotation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_Rotation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Traj_Set_Rotation* internal_default_instance() {
    return reinterpret_cast<const Emc_Traj_Set_Rotation*>(
               &_Emc_Traj_Set_Rotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Emc_Traj_Set_Rotation* other);
  friend void swap(Emc_Traj_Set_Rotation& a, Emc_Traj_Set_Rotation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Traj_Set_Rotation* New() const final {
    return CreateMaybeMessage<Emc_Traj_Set_Rotation>(NULL);
  }

  Emc_Traj_Set_Rotation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Traj_Set_Rotation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Traj_Set_Rotation& from);
  void MergeFrom(const Emc_Traj_Set_Rotation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Traj_Set_Rotation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double rotation = 10;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 10;
  double rotation() const;
  void set_rotation(double value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Traj_Set_Rotation)
 private:
  void set_has_rotation();
  void clear_has_rotation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double rotation_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Traj_Linear_Move : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Traj_Linear_Move) */ {
 public:
  Emc_Traj_Linear_Move();
  virtual ~Emc_Traj_Linear_Move();

  Emc_Traj_Linear_Move(const Emc_Traj_Linear_Move& from);

  inline Emc_Traj_Linear_Move& operator=(const Emc_Traj_Linear_Move& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Traj_Linear_Move(Emc_Traj_Linear_Move&& from) noexcept
    : Emc_Traj_Linear_Move() {
    *this = ::std::move(from);
  }

  inline Emc_Traj_Linear_Move& operator=(Emc_Traj_Linear_Move&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Linear_Move& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Traj_Linear_Move* internal_default_instance() {
    return reinterpret_cast<const Emc_Traj_Linear_Move*>(
               &_Emc_Traj_Linear_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Emc_Traj_Linear_Move* other);
  friend void swap(Emc_Traj_Linear_Move& a, Emc_Traj_Linear_Move& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Traj_Linear_Move* New() const final {
    return CreateMaybeMessage<Emc_Traj_Linear_Move>(NULL);
  }

  Emc_Traj_Linear_Move* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Traj_Linear_Move>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Traj_Linear_Move& from);
  void MergeFrom(const Emc_Traj_Linear_Move& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Traj_Linear_Move* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .machinetalk.EmcPose end = 20;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 20;
  private:
  const ::machinetalk::EmcPose& _internal_end() const;
  public:
  const ::machinetalk::EmcPose& end() const;
  ::machinetalk::EmcPose* release_end();
  ::machinetalk::EmcPose* mutable_end();
  void set_allocated_end(::machinetalk::EmcPose* end);

  // required int32 indexrotary = 70;
  bool has_indexrotary() const;
  void clear_indexrotary();
  static const int kIndexrotaryFieldNumber = 70;
  ::google::protobuf::int32 indexrotary() const;
  void set_indexrotary(::google::protobuf::int32 value);

  // required double vel = 30;
  bool has_vel() const;
  void clear_vel();
  static const int kVelFieldNumber = 30;
  double vel() const;
  void set_vel(double value);

  // required .machinetalk.MotionType type = 10;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 10;
  ::machinetalk::MotionType type() const;
  void set_type(::machinetalk::MotionType value);

  // required bool feed_mode = 60;
  bool has_feed_mode() const;
  void clear_feed_mode();
  static const int kFeedModeFieldNumber = 60;
  bool feed_mode() const;
  void set_feed_mode(bool value);

  // required double ini_maxvel = 40;
  bool has_ini_maxvel() const;
  void clear_ini_maxvel();
  static const int kIniMaxvelFieldNumber = 40;
  double ini_maxvel() const;
  void set_ini_maxvel(double value);

  // required double acc = 50;
  bool has_acc() const;
  void clear_acc();
  static const int kAccFieldNumber = 50;
  double acc() const;
  void set_acc(double value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Traj_Linear_Move)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_end();
  void clear_has_end();
  void set_has_vel();
  void clear_has_vel();
  void set_has_ini_maxvel();
  void clear_has_ini_maxvel();
  void set_has_acc();
  void clear_has_acc();
  void set_has_feed_mode();
  void clear_has_feed_mode();
  void set_has_indexrotary();
  void clear_has_indexrotary();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::machinetalk::EmcPose* end_;
  ::google::protobuf::int32 indexrotary_;
  double vel_;
  int type_;
  bool feed_mode_;
  double ini_maxvel_;
  double acc_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Traj_Probe : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Traj_Probe) */ {
 public:
  Emc_Traj_Probe();
  virtual ~Emc_Traj_Probe();

  Emc_Traj_Probe(const Emc_Traj_Probe& from);

  inline Emc_Traj_Probe& operator=(const Emc_Traj_Probe& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Traj_Probe(Emc_Traj_Probe&& from) noexcept
    : Emc_Traj_Probe() {
    *this = ::std::move(from);
  }

  inline Emc_Traj_Probe& operator=(Emc_Traj_Probe&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Probe& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Traj_Probe* internal_default_instance() {
    return reinterpret_cast<const Emc_Traj_Probe*>(
               &_Emc_Traj_Probe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Emc_Traj_Probe* other);
  friend void swap(Emc_Traj_Probe& a, Emc_Traj_Probe& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Traj_Probe* New() const final {
    return CreateMaybeMessage<Emc_Traj_Probe>(NULL);
  }

  Emc_Traj_Probe* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Traj_Probe>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Traj_Probe& from);
  void MergeFrom(const Emc_Traj_Probe& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Traj_Probe* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .machinetalk.EmcPose pos = 20;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 20;
  private:
  const ::machinetalk::EmcPose& _internal_pos() const;
  public:
  const ::machinetalk::EmcPose& pos() const;
  ::machinetalk::EmcPose* release_pos();
  ::machinetalk::EmcPose* mutable_pos();
  void set_allocated_pos(::machinetalk::EmcPose* pos);

  // required double vel = 30;
  bool has_vel() const;
  void clear_vel();
  static const int kVelFieldNumber = 30;
  double vel() const;
  void set_vel(double value);

  // required .machinetalk.MotionType type = 10;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 10;
  ::machinetalk::MotionType type() const;
  void set_type(::machinetalk::MotionType value);

  // required uint32 probe_type = 60;
  bool has_probe_type() const;
  void clear_probe_type();
  static const int kProbeTypeFieldNumber = 60;
  ::google::protobuf::uint32 probe_type() const;
  void set_probe_type(::google::protobuf::uint32 value);

  // required double ini_maxvel = 40;
  bool has_ini_maxvel() const;
  void clear_ini_maxvel();
  static const int kIniMaxvelFieldNumber = 40;
  double ini_maxvel() const;
  void set_ini_maxvel(double value);

  // required double acc = 50;
  bool has_acc() const;
  void clear_acc();
  static const int kAccFieldNumber = 50;
  double acc() const;
  void set_acc(double value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Traj_Probe)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_pos();
  void clear_has_pos();
  void set_has_vel();
  void clear_has_vel();
  void set_has_ini_maxvel();
  void clear_has_ini_maxvel();
  void set_has_acc();
  void clear_has_acc();
  void set_has_probe_type();
  void clear_has_probe_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::machinetalk::EmcPose* pos_;
  double vel_;
  int type_;
  ::google::protobuf::uint32 probe_type_;
  double ini_maxvel_;
  double acc_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Traj_Circular_Move : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Traj_Circular_Move) */ {
 public:
  Emc_Traj_Circular_Move();
  virtual ~Emc_Traj_Circular_Move();

  Emc_Traj_Circular_Move(const Emc_Traj_Circular_Move& from);

  inline Emc_Traj_Circular_Move& operator=(const Emc_Traj_Circular_Move& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Traj_Circular_Move(Emc_Traj_Circular_Move&& from) noexcept
    : Emc_Traj_Circular_Move() {
    *this = ::std::move(from);
  }

  inline Emc_Traj_Circular_Move& operator=(Emc_Traj_Circular_Move&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Circular_Move& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Traj_Circular_Move* internal_default_instance() {
    return reinterpret_cast<const Emc_Traj_Circular_Move*>(
               &_Emc_Traj_Circular_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Emc_Traj_Circular_Move* other);
  friend void swap(Emc_Traj_Circular_Move& a, Emc_Traj_Circular_Move& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Traj_Circular_Move* New() const final {
    return CreateMaybeMessage<Emc_Traj_Circular_Move>(NULL);
  }

  Emc_Traj_Circular_Move* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Traj_Circular_Move>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Traj_Circular_Move& from);
  void MergeFrom(const Emc_Traj_Circular_Move& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Traj_Circular_Move* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .machinetalk.EmcPose end = 20;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 20;
  private:
  const ::machinetalk::EmcPose& _internal_end() const;
  public:
  const ::machinetalk::EmcPose& end() const;
  ::machinetalk::EmcPose* release_end();
  ::machinetalk::EmcPose* mutable_end();
  void set_allocated_end(::machinetalk::EmcPose* end);

  // required .machinetalk.PmCartesian center = 25;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 25;
  private:
  const ::machinetalk::PmCartesian& _internal_center() const;
  public:
  const ::machinetalk::PmCartesian& center() const;
  ::machinetalk::PmCartesian* release_center();
  ::machinetalk::PmCartesian* mutable_center();
  void set_allocated_center(::machinetalk::PmCartesian* center);

  // required .machinetalk.PmCartesian normal = 27;
  bool has_normal() const;
  void clear_normal();
  static const int kNormalFieldNumber = 27;
  private:
  const ::machinetalk::PmCartesian& _internal_normal() const;
  public:
  const ::machinetalk::PmCartesian& normal() const;
  ::machinetalk::PmCartesian* release_normal();
  ::machinetalk::PmCartesian* mutable_normal();
  void set_allocated_normal(::machinetalk::PmCartesian* normal);

  // required int32 turn = 70;
  bool has_turn() const;
  void clear_turn();
  static const int kTurnFieldNumber = 70;
  ::google::protobuf::int32 turn() const;
  void set_turn(::google::protobuf::int32 value);

  // required double vel = 30;
  bool has_vel() const;
  void clear_vel();
  static const int kVelFieldNumber = 30;
  double vel() const;
  void set_vel(double value);

  // required .machinetalk.MotionType type = 10;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 10;
  ::machinetalk::MotionType type() const;
  void set_type(::machinetalk::MotionType value);

  // required bool feed_mode = 60;
  bool has_feed_mode() const;
  void clear_feed_mode();
  static const int kFeedModeFieldNumber = 60;
  bool feed_mode() const;
  void set_feed_mode(bool value);

  // required double ini_maxvel = 40;
  bool has_ini_maxvel() const;
  void clear_ini_maxvel();
  static const int kIniMaxvelFieldNumber = 40;
  double ini_maxvel() const;
  void set_ini_maxvel(double value);

  // required double acc = 50;
  bool has_acc() const;
  void clear_acc();
  static const int kAccFieldNumber = 50;
  double acc() const;
  void set_acc(double value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Traj_Circular_Move)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_end();
  void clear_has_end();
  void set_has_center();
  void clear_has_center();
  void set_has_normal();
  void clear_has_normal();
  void set_has_vel();
  void clear_has_vel();
  void set_has_ini_maxvel();
  void clear_has_ini_maxvel();
  void set_has_acc();
  void clear_has_acc();
  void set_has_feed_mode();
  void clear_has_feed_mode();
  void set_has_turn();
  void clear_has_turn();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::machinetalk::EmcPose* end_;
  ::machinetalk::PmCartesian* center_;
  ::machinetalk::PmCartesian* normal_;
  ::google::protobuf::int32 turn_;
  double vel_;
  int type_;
  bool feed_mode_;
  double ini_maxvel_;
  double acc_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Traj_Rigid_Tap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Traj_Rigid_Tap) */ {
 public:
  Emc_Traj_Rigid_Tap();
  virtual ~Emc_Traj_Rigid_Tap();

  Emc_Traj_Rigid_Tap(const Emc_Traj_Rigid_Tap& from);

  inline Emc_Traj_Rigid_Tap& operator=(const Emc_Traj_Rigid_Tap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Traj_Rigid_Tap(Emc_Traj_Rigid_Tap&& from) noexcept
    : Emc_Traj_Rigid_Tap() {
    *this = ::std::move(from);
  }

  inline Emc_Traj_Rigid_Tap& operator=(Emc_Traj_Rigid_Tap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Rigid_Tap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Traj_Rigid_Tap* internal_default_instance() {
    return reinterpret_cast<const Emc_Traj_Rigid_Tap*>(
               &_Emc_Traj_Rigid_Tap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Emc_Traj_Rigid_Tap* other);
  friend void swap(Emc_Traj_Rigid_Tap& a, Emc_Traj_Rigid_Tap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Traj_Rigid_Tap* New() const final {
    return CreateMaybeMessage<Emc_Traj_Rigid_Tap>(NULL);
  }

  Emc_Traj_Rigid_Tap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Traj_Rigid_Tap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Traj_Rigid_Tap& from);
  void MergeFrom(const Emc_Traj_Rigid_Tap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Traj_Rigid_Tap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .machinetalk.EmcPose pos = 20;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 20;
  private:
  const ::machinetalk::EmcPose& _internal_pos() const;
  public:
  const ::machinetalk::EmcPose& pos() const;
  ::machinetalk::EmcPose* release_pos();
  ::machinetalk::EmcPose* mutable_pos();
  void set_allocated_pos(::machinetalk::EmcPose* pos);

  // required double vel = 30;
  bool has_vel() const;
  void clear_vel();
  static const int kVelFieldNumber = 30;
  double vel() const;
  void set_vel(double value);

  // required double ini_maxvel = 40;
  bool has_ini_maxvel() const;
  void clear_ini_maxvel();
  static const int kIniMaxvelFieldNumber = 40;
  double ini_maxvel() const;
  void set_ini_maxvel(double value);

  // required double acc = 50;
  bool has_acc() const;
  void clear_acc();
  static const int kAccFieldNumber = 50;
  double acc() const;
  void set_acc(double value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Traj_Rigid_Tap)
 private:
  void set_has_pos();
  void clear_has_pos();
  void set_has_vel();
  void clear_has_vel();
  void set_has_ini_maxvel();
  void clear_has_ini_maxvel();
  void set_has_acc();
  void clear_has_acc();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::machinetalk::EmcPose* pos_;
  double vel_;
  double ini_maxvel_;
  double acc_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Traj_Set_Term_Cond : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Traj_Set_Term_Cond) */ {
 public:
  Emc_Traj_Set_Term_Cond();
  virtual ~Emc_Traj_Set_Term_Cond();

  Emc_Traj_Set_Term_Cond(const Emc_Traj_Set_Term_Cond& from);

  inline Emc_Traj_Set_Term_Cond& operator=(const Emc_Traj_Set_Term_Cond& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Traj_Set_Term_Cond(Emc_Traj_Set_Term_Cond&& from) noexcept
    : Emc_Traj_Set_Term_Cond() {
    *this = ::std::move(from);
  }

  inline Emc_Traj_Set_Term_Cond& operator=(Emc_Traj_Set_Term_Cond&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_Term_Cond& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Traj_Set_Term_Cond* internal_default_instance() {
    return reinterpret_cast<const Emc_Traj_Set_Term_Cond*>(
               &_Emc_Traj_Set_Term_Cond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Emc_Traj_Set_Term_Cond* other);
  friend void swap(Emc_Traj_Set_Term_Cond& a, Emc_Traj_Set_Term_Cond& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Traj_Set_Term_Cond* New() const final {
    return CreateMaybeMessage<Emc_Traj_Set_Term_Cond>(NULL);
  }

  Emc_Traj_Set_Term_Cond* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Traj_Set_Term_Cond>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Traj_Set_Term_Cond& from);
  void MergeFrom(const Emc_Traj_Set_Term_Cond& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Traj_Set_Term_Cond* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double tolerance = 20;
  bool has_tolerance() const;
  void clear_tolerance();
  static const int kToleranceFieldNumber = 20;
  double tolerance() const;
  void set_tolerance(double value);

  // required .machinetalk.TermConditionType cond = 10;
  bool has_cond() const;
  void clear_cond();
  static const int kCondFieldNumber = 10;
  ::machinetalk::TermConditionType cond() const;
  void set_cond(::machinetalk::TermConditionType value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Traj_Set_Term_Cond)
 private:
  void set_has_cond();
  void clear_has_cond();
  void set_has_tolerance();
  void clear_has_tolerance();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double tolerance_;
  int cond_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Traj_Set_Spindlesync : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Traj_Set_Spindlesync) */ {
 public:
  Emc_Traj_Set_Spindlesync();
  virtual ~Emc_Traj_Set_Spindlesync();

  Emc_Traj_Set_Spindlesync(const Emc_Traj_Set_Spindlesync& from);

  inline Emc_Traj_Set_Spindlesync& operator=(const Emc_Traj_Set_Spindlesync& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Traj_Set_Spindlesync(Emc_Traj_Set_Spindlesync&& from) noexcept
    : Emc_Traj_Set_Spindlesync() {
    *this = ::std::move(from);
  }

  inline Emc_Traj_Set_Spindlesync& operator=(Emc_Traj_Set_Spindlesync&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_Spindlesync& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Traj_Set_Spindlesync* internal_default_instance() {
    return reinterpret_cast<const Emc_Traj_Set_Spindlesync*>(
               &_Emc_Traj_Set_Spindlesync_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Emc_Traj_Set_Spindlesync* other);
  friend void swap(Emc_Traj_Set_Spindlesync& a, Emc_Traj_Set_Spindlesync& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Traj_Set_Spindlesync* New() const final {
    return CreateMaybeMessage<Emc_Traj_Set_Spindlesync>(NULL);
  }

  Emc_Traj_Set_Spindlesync* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Traj_Set_Spindlesync>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Traj_Set_Spindlesync& from);
  void MergeFrom(const Emc_Traj_Set_Spindlesync& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Traj_Set_Spindlesync* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool velocity_mode = 20;
  bool has_velocity_mode() const;
  void clear_velocity_mode();
  static const int kVelocityModeFieldNumber = 20;
  bool velocity_mode() const;
  void set_velocity_mode(bool value);

  // required double feed_per_revolution = 10;
  bool has_feed_per_revolution() const;
  void clear_feed_per_revolution();
  static const int kFeedPerRevolutionFieldNumber = 10;
  double feed_per_revolution() const;
  void set_feed_per_revolution(double value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Traj_Set_Spindlesync)
 private:
  void set_has_feed_per_revolution();
  void clear_has_feed_per_revolution();
  void set_has_velocity_mode();
  void clear_has_velocity_mode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool velocity_mode_;
  double feed_per_revolution_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Traj_Delay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Traj_Delay) */ {
 public:
  Emc_Traj_Delay();
  virtual ~Emc_Traj_Delay();

  Emc_Traj_Delay(const Emc_Traj_Delay& from);

  inline Emc_Traj_Delay& operator=(const Emc_Traj_Delay& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Traj_Delay(Emc_Traj_Delay&& from) noexcept
    : Emc_Traj_Delay() {
    *this = ::std::move(from);
  }

  inline Emc_Traj_Delay& operator=(Emc_Traj_Delay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Delay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Traj_Delay* internal_default_instance() {
    return reinterpret_cast<const Emc_Traj_Delay*>(
               &_Emc_Traj_Delay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Emc_Traj_Delay* other);
  friend void swap(Emc_Traj_Delay& a, Emc_Traj_Delay& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Traj_Delay* New() const final {
    return CreateMaybeMessage<Emc_Traj_Delay>(NULL);
  }

  Emc_Traj_Delay* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Traj_Delay>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Traj_Delay& from);
  void MergeFrom(const Emc_Traj_Delay& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Traj_Delay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double delay = 10;
  bool has_delay() const;
  void clear_delay();
  static const int kDelayFieldNumber = 10;
  double delay() const;
  void set_delay(double value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Traj_Delay)
 private:
  void set_has_delay();
  void clear_has_delay();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double delay_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Spindle_On : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Spindle_On) */ {
 public:
  Emc_Spindle_On();
  virtual ~Emc_Spindle_On();

  Emc_Spindle_On(const Emc_Spindle_On& from);

  inline Emc_Spindle_On& operator=(const Emc_Spindle_On& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Spindle_On(Emc_Spindle_On&& from) noexcept
    : Emc_Spindle_On() {
    *this = ::std::move(from);
  }

  inline Emc_Spindle_On& operator=(Emc_Spindle_On&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Spindle_On& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Spindle_On* internal_default_instance() {
    return reinterpret_cast<const Emc_Spindle_On*>(
               &_Emc_Spindle_On_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Emc_Spindle_On* other);
  friend void swap(Emc_Spindle_On& a, Emc_Spindle_On& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Spindle_On* New() const final {
    return CreateMaybeMessage<Emc_Spindle_On>(NULL);
  }

  Emc_Spindle_On* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Spindle_On>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Spindle_On& from);
  void MergeFrom(const Emc_Spindle_On& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Spindle_On* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double speed = 10 [default = 0];
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 10;
  double speed() const;
  void set_speed(double value);

  // required double factor = 20 [default = 0];
  bool has_factor() const;
  void clear_factor();
  static const int kFactorFieldNumber = 20;
  double factor() const;
  void set_factor(double value);

  // required double xoffset = 30 [default = 0];
  bool has_xoffset() const;
  void clear_xoffset();
  static const int kXoffsetFieldNumber = 30;
  double xoffset() const;
  void set_xoffset(double value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Spindle_On)
 private:
  void set_has_speed();
  void clear_has_speed();
  void set_has_factor();
  void clear_has_factor();
  void set_has_xoffset();
  void clear_has_xoffset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double speed_;
  double factor_;
  double xoffset_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Spindle_Speed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Spindle_Speed) */ {
 public:
  Emc_Spindle_Speed();
  virtual ~Emc_Spindle_Speed();

  Emc_Spindle_Speed(const Emc_Spindle_Speed& from);

  inline Emc_Spindle_Speed& operator=(const Emc_Spindle_Speed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Spindle_Speed(Emc_Spindle_Speed&& from) noexcept
    : Emc_Spindle_Speed() {
    *this = ::std::move(from);
  }

  inline Emc_Spindle_Speed& operator=(Emc_Spindle_Speed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Spindle_Speed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Spindle_Speed* internal_default_instance() {
    return reinterpret_cast<const Emc_Spindle_Speed*>(
               &_Emc_Spindle_Speed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Emc_Spindle_Speed* other);
  friend void swap(Emc_Spindle_Speed& a, Emc_Spindle_Speed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Spindle_Speed* New() const final {
    return CreateMaybeMessage<Emc_Spindle_Speed>(NULL);
  }

  Emc_Spindle_Speed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Spindle_Speed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Spindle_Speed& from);
  void MergeFrom(const Emc_Spindle_Speed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Spindle_Speed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double speed = 10;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 10;
  double speed() const;
  void set_speed(double value);

  // required double factor = 20;
  bool has_factor() const;
  void clear_factor();
  static const int kFactorFieldNumber = 20;
  double factor() const;
  void set_factor(double value);

  // required double xoffset = 30;
  bool has_xoffset() const;
  void clear_xoffset();
  static const int kXoffsetFieldNumber = 30;
  double xoffset() const;
  void set_xoffset(double value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Spindle_Speed)
 private:
  void set_has_speed();
  void clear_has_speed();
  void set_has_factor();
  void clear_has_factor();
  void set_has_xoffset();
  void clear_has_xoffset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double speed_;
  double factor_;
  double xoffset_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Spindle_Orient : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Spindle_Orient) */ {
 public:
  Emc_Spindle_Orient();
  virtual ~Emc_Spindle_Orient();

  Emc_Spindle_Orient(const Emc_Spindle_Orient& from);

  inline Emc_Spindle_Orient& operator=(const Emc_Spindle_Orient& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Spindle_Orient(Emc_Spindle_Orient&& from) noexcept
    : Emc_Spindle_Orient() {
    *this = ::std::move(from);
  }

  inline Emc_Spindle_Orient& operator=(Emc_Spindle_Orient&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Spindle_Orient& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Spindle_Orient* internal_default_instance() {
    return reinterpret_cast<const Emc_Spindle_Orient*>(
               &_Emc_Spindle_Orient_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Emc_Spindle_Orient* other);
  friend void swap(Emc_Spindle_Orient& a, Emc_Spindle_Orient& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Spindle_Orient* New() const final {
    return CreateMaybeMessage<Emc_Spindle_Orient>(NULL);
  }

  Emc_Spindle_Orient* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Spindle_Orient>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Spindle_Orient& from);
  void MergeFrom(const Emc_Spindle_Orient& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Spindle_Orient* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double orientation = 10;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 10;
  double orientation() const;
  void set_orientation(double value);

  // required .machinetalk.CanonDirection mode = 20;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 20;
  ::machinetalk::CanonDirection mode() const;
  void set_mode(::machinetalk::CanonDirection value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Spindle_Orient)
 private:
  void set_has_orientation();
  void clear_has_orientation();
  void set_has_mode();
  void clear_has_mode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double orientation_;
  int mode_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Spindle_Wait_Orient_Complete : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Spindle_Wait_Orient_Complete) */ {
 public:
  Emc_Spindle_Wait_Orient_Complete();
  virtual ~Emc_Spindle_Wait_Orient_Complete();

  Emc_Spindle_Wait_Orient_Complete(const Emc_Spindle_Wait_Orient_Complete& from);

  inline Emc_Spindle_Wait_Orient_Complete& operator=(const Emc_Spindle_Wait_Orient_Complete& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Spindle_Wait_Orient_Complete(Emc_Spindle_Wait_Orient_Complete&& from) noexcept
    : Emc_Spindle_Wait_Orient_Complete() {
    *this = ::std::move(from);
  }

  inline Emc_Spindle_Wait_Orient_Complete& operator=(Emc_Spindle_Wait_Orient_Complete&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Spindle_Wait_Orient_Complete& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Spindle_Wait_Orient_Complete* internal_default_instance() {
    return reinterpret_cast<const Emc_Spindle_Wait_Orient_Complete*>(
               &_Emc_Spindle_Wait_Orient_Complete_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Emc_Spindle_Wait_Orient_Complete* other);
  friend void swap(Emc_Spindle_Wait_Orient_Complete& a, Emc_Spindle_Wait_Orient_Complete& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Spindle_Wait_Orient_Complete* New() const final {
    return CreateMaybeMessage<Emc_Spindle_Wait_Orient_Complete>(NULL);
  }

  Emc_Spindle_Wait_Orient_Complete* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Spindle_Wait_Orient_Complete>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Spindle_Wait_Orient_Complete& from);
  void MergeFrom(const Emc_Spindle_Wait_Orient_Complete& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Spindle_Wait_Orient_Complete* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double timeout = 10;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 10;
  double timeout() const;
  void set_timeout(double value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Spindle_Wait_Orient_Complete)
 private:
  void set_has_timeout();
  void clear_has_timeout();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double timeout_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Tool_Set_Offset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Tool_Set_Offset) */ {
 public:
  Emc_Tool_Set_Offset();
  virtual ~Emc_Tool_Set_Offset();

  Emc_Tool_Set_Offset(const Emc_Tool_Set_Offset& from);

  inline Emc_Tool_Set_Offset& operator=(const Emc_Tool_Set_Offset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Tool_Set_Offset(Emc_Tool_Set_Offset&& from) noexcept
    : Emc_Tool_Set_Offset() {
    *this = ::std::move(from);
  }

  inline Emc_Tool_Set_Offset& operator=(Emc_Tool_Set_Offset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Tool_Set_Offset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Tool_Set_Offset* internal_default_instance() {
    return reinterpret_cast<const Emc_Tool_Set_Offset*>(
               &_Emc_Tool_Set_Offset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Emc_Tool_Set_Offset* other);
  friend void swap(Emc_Tool_Set_Offset& a, Emc_Tool_Set_Offset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Tool_Set_Offset* New() const final {
    return CreateMaybeMessage<Emc_Tool_Set_Offset>(NULL);
  }

  Emc_Tool_Set_Offset* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Tool_Set_Offset>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Tool_Set_Offset& from);
  void MergeFrom(const Emc_Tool_Set_Offset& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Tool_Set_Offset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .machinetalk.EmcPose offset = 20;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 20;
  private:
  const ::machinetalk::EmcPose& _internal_offset() const;
  public:
  const ::machinetalk::EmcPose& offset() const;
  ::machinetalk::EmcPose* release_offset();
  ::machinetalk::EmcPose* mutable_offset();
  void set_allocated_offset(::machinetalk::EmcPose* offset);

  // required int32 orientation = 60;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 60;
  ::google::protobuf::int32 orientation() const;
  void set_orientation(::google::protobuf::int32 value);

  // required int32 pocket = 10;
  bool has_pocket() const;
  void clear_pocket();
  static const int kPocketFieldNumber = 10;
  ::google::protobuf::int32 pocket() const;
  void set_pocket(::google::protobuf::int32 value);

  // required int32 toolno = 15;
  bool has_toolno() const;
  void clear_toolno();
  static const int kToolnoFieldNumber = 15;
  ::google::protobuf::int32 toolno() const;
  void set_toolno(::google::protobuf::int32 value);

  // required double diameter = 30;
  bool has_diameter() const;
  void clear_diameter();
  static const int kDiameterFieldNumber = 30;
  double diameter() const;
  void set_diameter(double value);

  // required double frontangle = 40;
  bool has_frontangle() const;
  void clear_frontangle();
  static const int kFrontangleFieldNumber = 40;
  double frontangle() const;
  void set_frontangle(double value);

  // required double backangle = 50;
  bool has_backangle() const;
  void clear_backangle();
  static const int kBackangleFieldNumber = 50;
  double backangle() const;
  void set_backangle(double value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Tool_Set_Offset)
 private:
  void set_has_pocket();
  void clear_has_pocket();
  void set_has_toolno();
  void clear_has_toolno();
  void set_has_offset();
  void clear_has_offset();
  void set_has_diameter();
  void clear_has_diameter();
  void set_has_frontangle();
  void clear_has_frontangle();
  void set_has_backangle();
  void clear_has_backangle();
  void set_has_orientation();
  void clear_has_orientation();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::machinetalk::EmcPose* offset_;
  ::google::protobuf::int32 orientation_;
  ::google::protobuf::int32 pocket_;
  ::google::protobuf::int32 toolno_;
  double diameter_;
  double frontangle_;
  double backangle_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Traj_Set_Offset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Traj_Set_Offset) */ {
 public:
  Emc_Traj_Set_Offset();
  virtual ~Emc_Traj_Set_Offset();

  Emc_Traj_Set_Offset(const Emc_Traj_Set_Offset& from);

  inline Emc_Traj_Set_Offset& operator=(const Emc_Traj_Set_Offset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Traj_Set_Offset(Emc_Traj_Set_Offset&& from) noexcept
    : Emc_Traj_Set_Offset() {
    *this = ::std::move(from);
  }

  inline Emc_Traj_Set_Offset& operator=(Emc_Traj_Set_Offset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_Offset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Traj_Set_Offset* internal_default_instance() {
    return reinterpret_cast<const Emc_Traj_Set_Offset*>(
               &_Emc_Traj_Set_Offset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Emc_Traj_Set_Offset* other);
  friend void swap(Emc_Traj_Set_Offset& a, Emc_Traj_Set_Offset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Traj_Set_Offset* New() const final {
    return CreateMaybeMessage<Emc_Traj_Set_Offset>(NULL);
  }

  Emc_Traj_Set_Offset* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Traj_Set_Offset>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Traj_Set_Offset& from);
  void MergeFrom(const Emc_Traj_Set_Offset& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Traj_Set_Offset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .machinetalk.EmcPose offset = 10;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 10;
  private:
  const ::machinetalk::EmcPose& _internal_offset() const;
  public:
  const ::machinetalk::EmcPose& offset() const;
  ::machinetalk::EmcPose* release_offset();
  ::machinetalk::EmcPose* mutable_offset();
  void set_allocated_offset(::machinetalk::EmcPose* offset);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Traj_Set_Offset)
 private:
  void set_has_offset();
  void clear_has_offset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::machinetalk::EmcPose* offset_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Tool_Prepare : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Tool_Prepare) */ {
 public:
  Emc_Tool_Prepare();
  virtual ~Emc_Tool_Prepare();

  Emc_Tool_Prepare(const Emc_Tool_Prepare& from);

  inline Emc_Tool_Prepare& operator=(const Emc_Tool_Prepare& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Tool_Prepare(Emc_Tool_Prepare&& from) noexcept
    : Emc_Tool_Prepare() {
    *this = ::std::move(from);
  }

  inline Emc_Tool_Prepare& operator=(Emc_Tool_Prepare&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Tool_Prepare& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Tool_Prepare* internal_default_instance() {
    return reinterpret_cast<const Emc_Tool_Prepare*>(
               &_Emc_Tool_Prepare_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Emc_Tool_Prepare* other);
  friend void swap(Emc_Tool_Prepare& a, Emc_Tool_Prepare& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Tool_Prepare* New() const final {
    return CreateMaybeMessage<Emc_Tool_Prepare>(NULL);
  }

  Emc_Tool_Prepare* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Tool_Prepare>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Tool_Prepare& from);
  void MergeFrom(const Emc_Tool_Prepare& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Tool_Prepare* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 pocket = 10;
  bool has_pocket() const;
  void clear_pocket();
  static const int kPocketFieldNumber = 10;
  ::google::protobuf::int32 pocket() const;
  void set_pocket(::google::protobuf::int32 value);

  // required int32 tool = 20;
  bool has_tool() const;
  void clear_tool();
  static const int kToolFieldNumber = 20;
  ::google::protobuf::int32 tool() const;
  void set_tool(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Tool_Prepare)
 private:
  void set_has_pocket();
  void clear_has_pocket();
  void set_has_tool();
  void clear_has_tool();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 pocket_;
  ::google::protobuf::int32 tool_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Tool_Set_Number : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Tool_Set_Number) */ {
 public:
  Emc_Tool_Set_Number();
  virtual ~Emc_Tool_Set_Number();

  Emc_Tool_Set_Number(const Emc_Tool_Set_Number& from);

  inline Emc_Tool_Set_Number& operator=(const Emc_Tool_Set_Number& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Tool_Set_Number(Emc_Tool_Set_Number&& from) noexcept
    : Emc_Tool_Set_Number() {
    *this = ::std::move(from);
  }

  inline Emc_Tool_Set_Number& operator=(Emc_Tool_Set_Number&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Tool_Set_Number& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Tool_Set_Number* internal_default_instance() {
    return reinterpret_cast<const Emc_Tool_Set_Number*>(
               &_Emc_Tool_Set_Number_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Emc_Tool_Set_Number* other);
  friend void swap(Emc_Tool_Set_Number& a, Emc_Tool_Set_Number& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Tool_Set_Number* New() const final {
    return CreateMaybeMessage<Emc_Tool_Set_Number>(NULL);
  }

  Emc_Tool_Set_Number* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Tool_Set_Number>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Tool_Set_Number& from);
  void MergeFrom(const Emc_Tool_Set_Number& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Tool_Set_Number* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tool = 10;
  bool has_tool() const;
  void clear_tool();
  static const int kToolFieldNumber = 10;
  ::google::protobuf::int32 tool() const;
  void set_tool(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Tool_Set_Number)
 private:
  void set_has_tool();
  void clear_has_tool();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 tool_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Traj_Set_Fo_Enable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Traj_Set_Fo_Enable) */ {
 public:
  Emc_Traj_Set_Fo_Enable();
  virtual ~Emc_Traj_Set_Fo_Enable();

  Emc_Traj_Set_Fo_Enable(const Emc_Traj_Set_Fo_Enable& from);

  inline Emc_Traj_Set_Fo_Enable& operator=(const Emc_Traj_Set_Fo_Enable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Traj_Set_Fo_Enable(Emc_Traj_Set_Fo_Enable&& from) noexcept
    : Emc_Traj_Set_Fo_Enable() {
    *this = ::std::move(from);
  }

  inline Emc_Traj_Set_Fo_Enable& operator=(Emc_Traj_Set_Fo_Enable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_Fo_Enable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Traj_Set_Fo_Enable* internal_default_instance() {
    return reinterpret_cast<const Emc_Traj_Set_Fo_Enable*>(
               &_Emc_Traj_Set_Fo_Enable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Emc_Traj_Set_Fo_Enable* other);
  friend void swap(Emc_Traj_Set_Fo_Enable& a, Emc_Traj_Set_Fo_Enable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Traj_Set_Fo_Enable* New() const final {
    return CreateMaybeMessage<Emc_Traj_Set_Fo_Enable>(NULL);
  }

  Emc_Traj_Set_Fo_Enable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Traj_Set_Fo_Enable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Traj_Set_Fo_Enable& from);
  void MergeFrom(const Emc_Traj_Set_Fo_Enable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Traj_Set_Fo_Enable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool mode = 10;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 10;
  bool mode() const;
  void set_mode(bool value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Traj_Set_Fo_Enable)
 private:
  void set_has_mode();
  void clear_has_mode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool mode_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Traj_Set_So_Enable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Traj_Set_So_Enable) */ {
 public:
  Emc_Traj_Set_So_Enable();
  virtual ~Emc_Traj_Set_So_Enable();

  Emc_Traj_Set_So_Enable(const Emc_Traj_Set_So_Enable& from);

  inline Emc_Traj_Set_So_Enable& operator=(const Emc_Traj_Set_So_Enable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Traj_Set_So_Enable(Emc_Traj_Set_So_Enable&& from) noexcept
    : Emc_Traj_Set_So_Enable() {
    *this = ::std::move(from);
  }

  inline Emc_Traj_Set_So_Enable& operator=(Emc_Traj_Set_So_Enable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_So_Enable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Traj_Set_So_Enable* internal_default_instance() {
    return reinterpret_cast<const Emc_Traj_Set_So_Enable*>(
               &_Emc_Traj_Set_So_Enable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(Emc_Traj_Set_So_Enable* other);
  friend void swap(Emc_Traj_Set_So_Enable& a, Emc_Traj_Set_So_Enable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Traj_Set_So_Enable* New() const final {
    return CreateMaybeMessage<Emc_Traj_Set_So_Enable>(NULL);
  }

  Emc_Traj_Set_So_Enable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Traj_Set_So_Enable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Traj_Set_So_Enable& from);
  void MergeFrom(const Emc_Traj_Set_So_Enable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Traj_Set_So_Enable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool mode = 10;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 10;
  bool mode() const;
  void set_mode(bool value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Traj_Set_So_Enable)
 private:
  void set_has_mode();
  void clear_has_mode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool mode_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Traj_Set_Fh_Enable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Traj_Set_Fh_Enable) */ {
 public:
  Emc_Traj_Set_Fh_Enable();
  virtual ~Emc_Traj_Set_Fh_Enable();

  Emc_Traj_Set_Fh_Enable(const Emc_Traj_Set_Fh_Enable& from);

  inline Emc_Traj_Set_Fh_Enable& operator=(const Emc_Traj_Set_Fh_Enable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Traj_Set_Fh_Enable(Emc_Traj_Set_Fh_Enable&& from) noexcept
    : Emc_Traj_Set_Fh_Enable() {
    *this = ::std::move(from);
  }

  inline Emc_Traj_Set_Fh_Enable& operator=(Emc_Traj_Set_Fh_Enable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Traj_Set_Fh_Enable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Traj_Set_Fh_Enable* internal_default_instance() {
    return reinterpret_cast<const Emc_Traj_Set_Fh_Enable*>(
               &_Emc_Traj_Set_Fh_Enable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(Emc_Traj_Set_Fh_Enable* other);
  friend void swap(Emc_Traj_Set_Fh_Enable& a, Emc_Traj_Set_Fh_Enable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Traj_Set_Fh_Enable* New() const final {
    return CreateMaybeMessage<Emc_Traj_Set_Fh_Enable>(NULL);
  }

  Emc_Traj_Set_Fh_Enable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Traj_Set_Fh_Enable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Traj_Set_Fh_Enable& from);
  void MergeFrom(const Emc_Traj_Set_Fh_Enable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Traj_Set_Fh_Enable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool mode = 10;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 10;
  bool mode() const;
  void set_mode(bool value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Traj_Set_Fh_Enable)
 private:
  void set_has_mode();
  void clear_has_mode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool mode_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Motion_Adaptive : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Motion_Adaptive) */ {
 public:
  Emc_Motion_Adaptive();
  virtual ~Emc_Motion_Adaptive();

  Emc_Motion_Adaptive(const Emc_Motion_Adaptive& from);

  inline Emc_Motion_Adaptive& operator=(const Emc_Motion_Adaptive& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Motion_Adaptive(Emc_Motion_Adaptive&& from) noexcept
    : Emc_Motion_Adaptive() {
    *this = ::std::move(from);
  }

  inline Emc_Motion_Adaptive& operator=(Emc_Motion_Adaptive&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Motion_Adaptive& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Motion_Adaptive* internal_default_instance() {
    return reinterpret_cast<const Emc_Motion_Adaptive*>(
               &_Emc_Motion_Adaptive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(Emc_Motion_Adaptive* other);
  friend void swap(Emc_Motion_Adaptive& a, Emc_Motion_Adaptive& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Motion_Adaptive* New() const final {
    return CreateMaybeMessage<Emc_Motion_Adaptive>(NULL);
  }

  Emc_Motion_Adaptive* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Motion_Adaptive>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Motion_Adaptive& from);
  void MergeFrom(const Emc_Motion_Adaptive& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Motion_Adaptive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool status = 10;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 10;
  bool status() const;
  void set_status(bool value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Motion_Adaptive)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool status_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Operator_Display : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Operator_Display) */ {
 public:
  Emc_Operator_Display();
  virtual ~Emc_Operator_Display();

  Emc_Operator_Display(const Emc_Operator_Display& from);

  inline Emc_Operator_Display& operator=(const Emc_Operator_Display& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Operator_Display(Emc_Operator_Display&& from) noexcept
    : Emc_Operator_Display() {
    *this = ::std::move(from);
  }

  inline Emc_Operator_Display& operator=(Emc_Operator_Display&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Operator_Display& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Operator_Display* internal_default_instance() {
    return reinterpret_cast<const Emc_Operator_Display*>(
               &_Emc_Operator_Display_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(Emc_Operator_Display* other);
  friend void swap(Emc_Operator_Display& a, Emc_Operator_Display& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Operator_Display* New() const final {
    return CreateMaybeMessage<Emc_Operator_Display>(NULL);
  }

  Emc_Operator_Display* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Operator_Display>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Operator_Display& from);
  void MergeFrom(const Emc_Operator_Display& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Operator_Display* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string display = 20;
  bool has_display() const;
  void clear_display();
  static const int kDisplayFieldNumber = 20;
  const ::std::string& display() const;
  void set_display(const ::std::string& value);
  #if LANG_CXX11
  void set_display(::std::string&& value);
  #endif
  void set_display(const char* value);
  void set_display(const char* value, size_t size);
  ::std::string* mutable_display();
  ::std::string* release_display();
  void set_allocated_display(::std::string* display);

  // required int32 id = 10;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 10;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Operator_Display)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_display();
  void clear_has_display();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr display_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Operator_Text : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Operator_Text) */ {
 public:
  Emc_Operator_Text();
  virtual ~Emc_Operator_Text();

  Emc_Operator_Text(const Emc_Operator_Text& from);

  inline Emc_Operator_Text& operator=(const Emc_Operator_Text& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Operator_Text(Emc_Operator_Text&& from) noexcept
    : Emc_Operator_Text() {
    *this = ::std::move(from);
  }

  inline Emc_Operator_Text& operator=(Emc_Operator_Text&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Operator_Text& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Operator_Text* internal_default_instance() {
    return reinterpret_cast<const Emc_Operator_Text*>(
               &_Emc_Operator_Text_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(Emc_Operator_Text* other);
  friend void swap(Emc_Operator_Text& a, Emc_Operator_Text& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Operator_Text* New() const final {
    return CreateMaybeMessage<Emc_Operator_Text>(NULL);
  }

  Emc_Operator_Text* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Operator_Text>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Operator_Text& from);
  void MergeFrom(const Emc_Operator_Text& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Operator_Text* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 20;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 20;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // required int32 id = 10;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 10;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Operator_Text)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_text();
  void clear_has_text();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Operator_Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Operator_Error) */ {
 public:
  Emc_Operator_Error();
  virtual ~Emc_Operator_Error();

  Emc_Operator_Error(const Emc_Operator_Error& from);

  inline Emc_Operator_Error& operator=(const Emc_Operator_Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Operator_Error(Emc_Operator_Error&& from) noexcept
    : Emc_Operator_Error() {
    *this = ::std::move(from);
  }

  inline Emc_Operator_Error& operator=(Emc_Operator_Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Operator_Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Operator_Error* internal_default_instance() {
    return reinterpret_cast<const Emc_Operator_Error*>(
               &_Emc_Operator_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(Emc_Operator_Error* other);
  friend void swap(Emc_Operator_Error& a, Emc_Operator_Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Operator_Error* New() const final {
    return CreateMaybeMessage<Emc_Operator_Error>(NULL);
  }

  Emc_Operator_Error* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Operator_Error>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Operator_Error& from);
  void MergeFrom(const Emc_Operator_Error& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Operator_Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string error = 20;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 20;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // required int32 id = 10;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 10;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Operator_Error)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_error();
  void clear_has_error();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Motion_Set_Dout : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Motion_Set_Dout) */ {
 public:
  Emc_Motion_Set_Dout();
  virtual ~Emc_Motion_Set_Dout();

  Emc_Motion_Set_Dout(const Emc_Motion_Set_Dout& from);

  inline Emc_Motion_Set_Dout& operator=(const Emc_Motion_Set_Dout& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Motion_Set_Dout(Emc_Motion_Set_Dout&& from) noexcept
    : Emc_Motion_Set_Dout() {
    *this = ::std::move(from);
  }

  inline Emc_Motion_Set_Dout& operator=(Emc_Motion_Set_Dout&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Motion_Set_Dout& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Motion_Set_Dout* internal_default_instance() {
    return reinterpret_cast<const Emc_Motion_Set_Dout*>(
               &_Emc_Motion_Set_Dout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(Emc_Motion_Set_Dout* other);
  friend void swap(Emc_Motion_Set_Dout& a, Emc_Motion_Set_Dout& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Motion_Set_Dout* New() const final {
    return CreateMaybeMessage<Emc_Motion_Set_Dout>(NULL);
  }

  Emc_Motion_Set_Dout* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Motion_Set_Dout>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Motion_Set_Dout& from);
  void MergeFrom(const Emc_Motion_Set_Dout& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Motion_Set_Dout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 10;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 10;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // required bool start = 20;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 20;
  bool start() const;
  void set_start(bool value);

  // required bool end = 30;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 30;
  bool end() const;
  void set_end(bool value);

  // required bool now = 40;
  bool has_now() const;
  void clear_now();
  static const int kNowFieldNumber = 40;
  bool now() const;
  void set_now(bool value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Motion_Set_Dout)
 private:
  void set_has_index();
  void clear_has_index();
  void set_has_start();
  void clear_has_start();
  void set_has_end();
  void clear_has_end();
  void set_has_now();
  void clear_has_now();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 index_;
  bool start_;
  bool end_;
  bool now_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Motion_Set_Aout : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Motion_Set_Aout) */ {
 public:
  Emc_Motion_Set_Aout();
  virtual ~Emc_Motion_Set_Aout();

  Emc_Motion_Set_Aout(const Emc_Motion_Set_Aout& from);

  inline Emc_Motion_Set_Aout& operator=(const Emc_Motion_Set_Aout& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Motion_Set_Aout(Emc_Motion_Set_Aout&& from) noexcept
    : Emc_Motion_Set_Aout() {
    *this = ::std::move(from);
  }

  inline Emc_Motion_Set_Aout& operator=(Emc_Motion_Set_Aout&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Motion_Set_Aout& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Motion_Set_Aout* internal_default_instance() {
    return reinterpret_cast<const Emc_Motion_Set_Aout*>(
               &_Emc_Motion_Set_Aout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(Emc_Motion_Set_Aout* other);
  friend void swap(Emc_Motion_Set_Aout& a, Emc_Motion_Set_Aout& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Motion_Set_Aout* New() const final {
    return CreateMaybeMessage<Emc_Motion_Set_Aout>(NULL);
  }

  Emc_Motion_Set_Aout* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Motion_Set_Aout>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Motion_Set_Aout& from);
  void MergeFrom(const Emc_Motion_Set_Aout& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Motion_Set_Aout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double start = 20;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 20;
  double start() const;
  void set_start(double value);

  // required uint32 index = 10;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 10;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // required bool now = 40;
  bool has_now() const;
  void clear_now();
  static const int kNowFieldNumber = 40;
  bool now() const;
  void set_now(bool value);

  // required double end = 30;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 30;
  double end() const;
  void set_end(double value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Motion_Set_Aout)
 private:
  void set_has_index();
  void clear_has_index();
  void set_has_start();
  void clear_has_start();
  void set_has_end();
  void clear_has_end();
  void set_has_now();
  void clear_has_now();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double start_;
  ::google::protobuf::uint32 index_;
  bool now_;
  double end_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Aux_Input_Wait : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Aux_Input_Wait) */ {
 public:
  Emc_Aux_Input_Wait();
  virtual ~Emc_Aux_Input_Wait();

  Emc_Aux_Input_Wait(const Emc_Aux_Input_Wait& from);

  inline Emc_Aux_Input_Wait& operator=(const Emc_Aux_Input_Wait& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Aux_Input_Wait(Emc_Aux_Input_Wait&& from) noexcept
    : Emc_Aux_Input_Wait() {
    *this = ::std::move(from);
  }

  inline Emc_Aux_Input_Wait& operator=(Emc_Aux_Input_Wait&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Aux_Input_Wait& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Aux_Input_Wait* internal_default_instance() {
    return reinterpret_cast<const Emc_Aux_Input_Wait*>(
               &_Emc_Aux_Input_Wait_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(Emc_Aux_Input_Wait* other);
  friend void swap(Emc_Aux_Input_Wait& a, Emc_Aux_Input_Wait& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Aux_Input_Wait* New() const final {
    return CreateMaybeMessage<Emc_Aux_Input_Wait>(NULL);
  }

  Emc_Aux_Input_Wait* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Aux_Input_Wait>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Aux_Input_Wait& from);
  void MergeFrom(const Emc_Aux_Input_Wait& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Aux_Input_Wait* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .machinetalk.WaitType wait_type = 30;
  bool has_wait_type() const;
  void clear_wait_type();
  static const int kWaitTypeFieldNumber = 30;
  ::machinetalk::WaitType wait_type() const;
  void set_wait_type(::machinetalk::WaitType value);

  // required uint32 index = 10;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 10;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // required .machinetalk.InputType input_type = 20;
  bool has_input_type() const;
  void clear_input_type();
  static const int kInputTypeFieldNumber = 20;
  ::machinetalk::InputType input_type() const;
  void set_input_type(::machinetalk::InputType value);

  // required double timeout = 40;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 40;
  double timeout() const;
  void set_timeout(double value);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Aux_Input_Wait)
 private:
  void set_has_index();
  void clear_has_index();
  void set_has_input_type();
  void clear_has_input_type();
  void set_has_wait_type();
  void clear_has_wait_type();
  void set_has_timeout();
  void clear_has_timeout();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int wait_type_;
  ::google::protobuf::uint32 index_;
  int input_type_;
  double timeout_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Exec_Plugin_Ca1l : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Exec_Plugin_Ca1l) */ {
 public:
  Emc_Exec_Plugin_Ca1l();
  virtual ~Emc_Exec_Plugin_Ca1l();

  Emc_Exec_Plugin_Ca1l(const Emc_Exec_Plugin_Ca1l& from);

  inline Emc_Exec_Plugin_Ca1l& operator=(const Emc_Exec_Plugin_Ca1l& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Exec_Plugin_Ca1l(Emc_Exec_Plugin_Ca1l&& from) noexcept
    : Emc_Exec_Plugin_Ca1l() {
    *this = ::std::move(from);
  }

  inline Emc_Exec_Plugin_Ca1l& operator=(Emc_Exec_Plugin_Ca1l&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Exec_Plugin_Ca1l& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Exec_Plugin_Ca1l* internal_default_instance() {
    return reinterpret_cast<const Emc_Exec_Plugin_Ca1l*>(
               &_Emc_Exec_Plugin_Ca1l_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(Emc_Exec_Plugin_Ca1l* other);
  friend void swap(Emc_Exec_Plugin_Ca1l& a, Emc_Exec_Plugin_Ca1l& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Exec_Plugin_Ca1l* New() const final {
    return CreateMaybeMessage<Emc_Exec_Plugin_Ca1l>(NULL);
  }

  Emc_Exec_Plugin_Ca1l* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Exec_Plugin_Ca1l>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Exec_Plugin_Ca1l& from);
  void MergeFrom(const Emc_Exec_Plugin_Ca1l& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Exec_Plugin_Ca1l* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes call = 20;
  bool has_call() const;
  void clear_call();
  static const int kCallFieldNumber = 20;
  const ::std::string& call() const;
  void set_call(const ::std::string& value);
  #if LANG_CXX11
  void set_call(::std::string&& value);
  #endif
  void set_call(const char* value);
  void set_call(const void* value, size_t size);
  ::std::string* mutable_call();
  ::std::string* release_call();
  void set_allocated_call(::std::string* call);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Exec_Plugin_Ca1l)
 private:
  void set_has_call();
  void clear_has_call();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr call_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Emc_Io_Plugin_Call : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Emc_Io_Plugin_Call) */ {
 public:
  Emc_Io_Plugin_Call();
  virtual ~Emc_Io_Plugin_Call();

  Emc_Io_Plugin_Call(const Emc_Io_Plugin_Call& from);

  inline Emc_Io_Plugin_Call& operator=(const Emc_Io_Plugin_Call& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Emc_Io_Plugin_Call(Emc_Io_Plugin_Call&& from) noexcept
    : Emc_Io_Plugin_Call() {
    *this = ::std::move(from);
  }

  inline Emc_Io_Plugin_Call& operator=(Emc_Io_Plugin_Call&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Emc_Io_Plugin_Call& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Emc_Io_Plugin_Call* internal_default_instance() {
    return reinterpret_cast<const Emc_Io_Plugin_Call*>(
               &_Emc_Io_Plugin_Call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(Emc_Io_Plugin_Call* other);
  friend void swap(Emc_Io_Plugin_Call& a, Emc_Io_Plugin_Call& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Emc_Io_Plugin_Call* New() const final {
    return CreateMaybeMessage<Emc_Io_Plugin_Call>(NULL);
  }

  Emc_Io_Plugin_Call* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Emc_Io_Plugin_Call>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Emc_Io_Plugin_Call& from);
  void MergeFrom(const Emc_Io_Plugin_Call& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Emc_Io_Plugin_Call* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes call = 20;
  bool has_call() const;
  void clear_call();
  static const int kCallFieldNumber = 20;
  const ::std::string& call() const;
  void set_call(const ::std::string& value);
  #if LANG_CXX11
  void set_call(::std::string&& value);
  #endif
  void set_call(const char* value);
  void set_call(const void* value, size_t size);
  ::std::string* mutable_call();
  ::std::string* release_call();
  void set_allocated_call(::std::string* call);

  // @@protoc_insertion_point(class_scope:machinetalk.Emc_Io_Plugin_Call)
 private:
  void set_has_call();
  void clear_has_call();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr call_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fcanon_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Emc_Traj_Set_G5x

// required .machinetalk.EmcPose origin = 10;
inline bool Emc_Traj_Set_G5x::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_G5x::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_G5x::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::machinetalk::EmcPose& Emc_Traj_Set_G5x::_internal_origin() const {
  return *origin_;
}
inline const ::machinetalk::EmcPose& Emc_Traj_Set_G5x::origin() const {
  const ::machinetalk::EmcPose* p = origin_;
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Set_G5x.origin)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcPose*>(
      &::machinetalk::_EmcPose_default_instance_);
}
inline ::machinetalk::EmcPose* Emc_Traj_Set_G5x::release_origin() {
  // @@protoc_insertion_point(field_release:machinetalk.Emc_Traj_Set_G5x.origin)
  clear_has_origin();
  ::machinetalk::EmcPose* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline ::machinetalk::EmcPose* Emc_Traj_Set_G5x::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcPose>(GetArenaNoVirtual());
    origin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Emc_Traj_Set_G5x.origin)
  return origin_;
}
inline void Emc_Traj_Set_G5x::set_allocated_origin(::machinetalk::EmcPose* origin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(origin_);
  }
  if (origin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      origin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    set_has_origin();
  } else {
    clear_has_origin();
  }
  origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Emc_Traj_Set_G5x.origin)
}

// required .machinetalk.OriginIndex g5x_index = 20;
inline bool Emc_Traj_Set_G5x::has_g5x_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Traj_Set_G5x::set_has_g5x_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Traj_Set_G5x::clear_has_g5x_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Traj_Set_G5x::clear_g5x_index() {
  g5x_index_ = 0;
  clear_has_g5x_index();
}
inline ::machinetalk::OriginIndex Emc_Traj_Set_G5x::g5x_index() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Set_G5x.g5x_index)
  return static_cast< ::machinetalk::OriginIndex >(g5x_index_);
}
inline void Emc_Traj_Set_G5x::set_g5x_index(::machinetalk::OriginIndex value) {
  assert(::machinetalk::OriginIndex_IsValid(value));
  set_has_g5x_index();
  g5x_index_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Set_G5x.g5x_index)
}

// -------------------------------------------------------------------

// Emc_Traj_Set_G92

// required .machinetalk.EmcPose origin = 10;
inline bool Emc_Traj_Set_G92::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_G92::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_G92::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::machinetalk::EmcPose& Emc_Traj_Set_G92::_internal_origin() const {
  return *origin_;
}
inline const ::machinetalk::EmcPose& Emc_Traj_Set_G92::origin() const {
  const ::machinetalk::EmcPose* p = origin_;
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Set_G92.origin)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcPose*>(
      &::machinetalk::_EmcPose_default_instance_);
}
inline ::machinetalk::EmcPose* Emc_Traj_Set_G92::release_origin() {
  // @@protoc_insertion_point(field_release:machinetalk.Emc_Traj_Set_G92.origin)
  clear_has_origin();
  ::machinetalk::EmcPose* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline ::machinetalk::EmcPose* Emc_Traj_Set_G92::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcPose>(GetArenaNoVirtual());
    origin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Emc_Traj_Set_G92.origin)
  return origin_;
}
inline void Emc_Traj_Set_G92::set_allocated_origin(::machinetalk::EmcPose* origin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(origin_);
  }
  if (origin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      origin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    set_has_origin();
  } else {
    clear_has_origin();
  }
  origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Emc_Traj_Set_G92.origin)
}

// -------------------------------------------------------------------

// Emc_Traj_Set_Rotation

// required double rotation = 10;
inline bool Emc_Traj_Set_Rotation::has_rotation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_Rotation::set_has_rotation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_Rotation::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Set_Rotation::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline double Emc_Traj_Set_Rotation::rotation() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Set_Rotation.rotation)
  return rotation_;
}
inline void Emc_Traj_Set_Rotation::set_rotation(double value) {
  set_has_rotation();
  rotation_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Set_Rotation.rotation)
}

// -------------------------------------------------------------------

// Emc_Traj_Linear_Move

// required .machinetalk.MotionType type = 10;
inline bool Emc_Traj_Linear_Move::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Emc_Traj_Linear_Move::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Emc_Traj_Linear_Move::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Emc_Traj_Linear_Move::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::machinetalk::MotionType Emc_Traj_Linear_Move::type() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Linear_Move.type)
  return static_cast< ::machinetalk::MotionType >(type_);
}
inline void Emc_Traj_Linear_Move::set_type(::machinetalk::MotionType value) {
  assert(::machinetalk::MotionType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Linear_Move.type)
}

// required .machinetalk.EmcPose end = 20;
inline bool Emc_Traj_Linear_Move::has_end() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Linear_Move::set_has_end() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Linear_Move::clear_has_end() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::machinetalk::EmcPose& Emc_Traj_Linear_Move::_internal_end() const {
  return *end_;
}
inline const ::machinetalk::EmcPose& Emc_Traj_Linear_Move::end() const {
  const ::machinetalk::EmcPose* p = end_;
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Linear_Move.end)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcPose*>(
      &::machinetalk::_EmcPose_default_instance_);
}
inline ::machinetalk::EmcPose* Emc_Traj_Linear_Move::release_end() {
  // @@protoc_insertion_point(field_release:machinetalk.Emc_Traj_Linear_Move.end)
  clear_has_end();
  ::machinetalk::EmcPose* temp = end_;
  end_ = NULL;
  return temp;
}
inline ::machinetalk::EmcPose* Emc_Traj_Linear_Move::mutable_end() {
  set_has_end();
  if (end_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcPose>(GetArenaNoVirtual());
    end_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Emc_Traj_Linear_Move.end)
  return end_;
}
inline void Emc_Traj_Linear_Move::set_allocated_end(::machinetalk::EmcPose* end) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(end_);
  }
  if (end) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    set_has_end();
  } else {
    clear_has_end();
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Emc_Traj_Linear_Move.end)
}

// required double vel = 30;
inline bool Emc_Traj_Linear_Move::has_vel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Traj_Linear_Move::set_has_vel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Traj_Linear_Move::clear_has_vel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Traj_Linear_Move::clear_vel() {
  vel_ = 0;
  clear_has_vel();
}
inline double Emc_Traj_Linear_Move::vel() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Linear_Move.vel)
  return vel_;
}
inline void Emc_Traj_Linear_Move::set_vel(double value) {
  set_has_vel();
  vel_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Linear_Move.vel)
}

// required double ini_maxvel = 40;
inline bool Emc_Traj_Linear_Move::has_ini_maxvel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Emc_Traj_Linear_Move::set_has_ini_maxvel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Emc_Traj_Linear_Move::clear_has_ini_maxvel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Emc_Traj_Linear_Move::clear_ini_maxvel() {
  ini_maxvel_ = 0;
  clear_has_ini_maxvel();
}
inline double Emc_Traj_Linear_Move::ini_maxvel() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Linear_Move.ini_maxvel)
  return ini_maxvel_;
}
inline void Emc_Traj_Linear_Move::set_ini_maxvel(double value) {
  set_has_ini_maxvel();
  ini_maxvel_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Linear_Move.ini_maxvel)
}

// required double acc = 50;
inline bool Emc_Traj_Linear_Move::has_acc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Emc_Traj_Linear_Move::set_has_acc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Emc_Traj_Linear_Move::clear_has_acc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Emc_Traj_Linear_Move::clear_acc() {
  acc_ = 0;
  clear_has_acc();
}
inline double Emc_Traj_Linear_Move::acc() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Linear_Move.acc)
  return acc_;
}
inline void Emc_Traj_Linear_Move::set_acc(double value) {
  set_has_acc();
  acc_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Linear_Move.acc)
}

// required bool feed_mode = 60;
inline bool Emc_Traj_Linear_Move::has_feed_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Emc_Traj_Linear_Move::set_has_feed_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Emc_Traj_Linear_Move::clear_has_feed_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Emc_Traj_Linear_Move::clear_feed_mode() {
  feed_mode_ = false;
  clear_has_feed_mode();
}
inline bool Emc_Traj_Linear_Move::feed_mode() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Linear_Move.feed_mode)
  return feed_mode_;
}
inline void Emc_Traj_Linear_Move::set_feed_mode(bool value) {
  set_has_feed_mode();
  feed_mode_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Linear_Move.feed_mode)
}

// required int32 indexrotary = 70;
inline bool Emc_Traj_Linear_Move::has_indexrotary() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Traj_Linear_Move::set_has_indexrotary() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Traj_Linear_Move::clear_has_indexrotary() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Traj_Linear_Move::clear_indexrotary() {
  indexrotary_ = 0;
  clear_has_indexrotary();
}
inline ::google::protobuf::int32 Emc_Traj_Linear_Move::indexrotary() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Linear_Move.indexrotary)
  return indexrotary_;
}
inline void Emc_Traj_Linear_Move::set_indexrotary(::google::protobuf::int32 value) {
  set_has_indexrotary();
  indexrotary_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Linear_Move.indexrotary)
}

// -------------------------------------------------------------------

// Emc_Traj_Probe

// required .machinetalk.MotionType type = 10;
inline bool Emc_Traj_Probe::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Traj_Probe::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Traj_Probe::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Traj_Probe::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::machinetalk::MotionType Emc_Traj_Probe::type() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Probe.type)
  return static_cast< ::machinetalk::MotionType >(type_);
}
inline void Emc_Traj_Probe::set_type(::machinetalk::MotionType value) {
  assert(::machinetalk::MotionType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Probe.type)
}

// required .machinetalk.EmcPose pos = 20;
inline bool Emc_Traj_Probe::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Probe::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Probe::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::machinetalk::EmcPose& Emc_Traj_Probe::_internal_pos() const {
  return *pos_;
}
inline const ::machinetalk::EmcPose& Emc_Traj_Probe::pos() const {
  const ::machinetalk::EmcPose* p = pos_;
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Probe.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcPose*>(
      &::machinetalk::_EmcPose_default_instance_);
}
inline ::machinetalk::EmcPose* Emc_Traj_Probe::release_pos() {
  // @@protoc_insertion_point(field_release:machinetalk.Emc_Traj_Probe.pos)
  clear_has_pos();
  ::machinetalk::EmcPose* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline ::machinetalk::EmcPose* Emc_Traj_Probe::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcPose>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Emc_Traj_Probe.pos)
  return pos_;
}
inline void Emc_Traj_Probe::set_allocated_pos(::machinetalk::EmcPose* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pos_);
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    set_has_pos();
  } else {
    clear_has_pos();
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Emc_Traj_Probe.pos)
}

// required double vel = 30;
inline bool Emc_Traj_Probe::has_vel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Traj_Probe::set_has_vel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Traj_Probe::clear_has_vel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Traj_Probe::clear_vel() {
  vel_ = 0;
  clear_has_vel();
}
inline double Emc_Traj_Probe::vel() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Probe.vel)
  return vel_;
}
inline void Emc_Traj_Probe::set_vel(double value) {
  set_has_vel();
  vel_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Probe.vel)
}

// required double ini_maxvel = 40;
inline bool Emc_Traj_Probe::has_ini_maxvel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Emc_Traj_Probe::set_has_ini_maxvel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Emc_Traj_Probe::clear_has_ini_maxvel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Emc_Traj_Probe::clear_ini_maxvel() {
  ini_maxvel_ = 0;
  clear_has_ini_maxvel();
}
inline double Emc_Traj_Probe::ini_maxvel() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Probe.ini_maxvel)
  return ini_maxvel_;
}
inline void Emc_Traj_Probe::set_ini_maxvel(double value) {
  set_has_ini_maxvel();
  ini_maxvel_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Probe.ini_maxvel)
}

// required double acc = 50;
inline bool Emc_Traj_Probe::has_acc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Emc_Traj_Probe::set_has_acc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Emc_Traj_Probe::clear_has_acc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Emc_Traj_Probe::clear_acc() {
  acc_ = 0;
  clear_has_acc();
}
inline double Emc_Traj_Probe::acc() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Probe.acc)
  return acc_;
}
inline void Emc_Traj_Probe::set_acc(double value) {
  set_has_acc();
  acc_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Probe.acc)
}

// required uint32 probe_type = 60;
inline bool Emc_Traj_Probe::has_probe_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Emc_Traj_Probe::set_has_probe_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Emc_Traj_Probe::clear_has_probe_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Emc_Traj_Probe::clear_probe_type() {
  probe_type_ = 0u;
  clear_has_probe_type();
}
inline ::google::protobuf::uint32 Emc_Traj_Probe::probe_type() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Probe.probe_type)
  return probe_type_;
}
inline void Emc_Traj_Probe::set_probe_type(::google::protobuf::uint32 value) {
  set_has_probe_type();
  probe_type_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Probe.probe_type)
}

// -------------------------------------------------------------------

// Emc_Traj_Circular_Move

// required .machinetalk.MotionType type = 10;
inline bool Emc_Traj_Circular_Move::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Emc_Traj_Circular_Move::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Emc_Traj_Circular_Move::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::machinetalk::MotionType Emc_Traj_Circular_Move::type() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Circular_Move.type)
  return static_cast< ::machinetalk::MotionType >(type_);
}
inline void Emc_Traj_Circular_Move::set_type(::machinetalk::MotionType value) {
  assert(::machinetalk::MotionType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Circular_Move.type)
}

// required .machinetalk.EmcPose end = 20;
inline bool Emc_Traj_Circular_Move::has_end() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_end() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Circular_Move::clear_has_end() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::machinetalk::EmcPose& Emc_Traj_Circular_Move::_internal_end() const {
  return *end_;
}
inline const ::machinetalk::EmcPose& Emc_Traj_Circular_Move::end() const {
  const ::machinetalk::EmcPose* p = end_;
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Circular_Move.end)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcPose*>(
      &::machinetalk::_EmcPose_default_instance_);
}
inline ::machinetalk::EmcPose* Emc_Traj_Circular_Move::release_end() {
  // @@protoc_insertion_point(field_release:machinetalk.Emc_Traj_Circular_Move.end)
  clear_has_end();
  ::machinetalk::EmcPose* temp = end_;
  end_ = NULL;
  return temp;
}
inline ::machinetalk::EmcPose* Emc_Traj_Circular_Move::mutable_end() {
  set_has_end();
  if (end_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcPose>(GetArenaNoVirtual());
    end_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Emc_Traj_Circular_Move.end)
  return end_;
}
inline void Emc_Traj_Circular_Move::set_allocated_end(::machinetalk::EmcPose* end) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(end_);
  }
  if (end) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      end = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    set_has_end();
  } else {
    clear_has_end();
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Emc_Traj_Circular_Move.end)
}

// required .machinetalk.PmCartesian center = 25;
inline bool Emc_Traj_Circular_Move::has_center() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_center() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Traj_Circular_Move::clear_has_center() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::machinetalk::PmCartesian& Emc_Traj_Circular_Move::_internal_center() const {
  return *center_;
}
inline const ::machinetalk::PmCartesian& Emc_Traj_Circular_Move::center() const {
  const ::machinetalk::PmCartesian* p = center_;
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Circular_Move.center)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::PmCartesian*>(
      &::machinetalk::_PmCartesian_default_instance_);
}
inline ::machinetalk::PmCartesian* Emc_Traj_Circular_Move::release_center() {
  // @@protoc_insertion_point(field_release:machinetalk.Emc_Traj_Circular_Move.center)
  clear_has_center();
  ::machinetalk::PmCartesian* temp = center_;
  center_ = NULL;
  return temp;
}
inline ::machinetalk::PmCartesian* Emc_Traj_Circular_Move::mutable_center() {
  set_has_center();
  if (center_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::PmCartesian>(GetArenaNoVirtual());
    center_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Emc_Traj_Circular_Move.center)
  return center_;
}
inline void Emc_Traj_Circular_Move::set_allocated_center(::machinetalk::PmCartesian* center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(center_);
  }
  if (center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    set_has_center();
  } else {
    clear_has_center();
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Emc_Traj_Circular_Move.center)
}

// required .machinetalk.PmCartesian normal = 27;
inline bool Emc_Traj_Circular_Move::has_normal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_normal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Traj_Circular_Move::clear_has_normal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::machinetalk::PmCartesian& Emc_Traj_Circular_Move::_internal_normal() const {
  return *normal_;
}
inline const ::machinetalk::PmCartesian& Emc_Traj_Circular_Move::normal() const {
  const ::machinetalk::PmCartesian* p = normal_;
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Circular_Move.normal)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::PmCartesian*>(
      &::machinetalk::_PmCartesian_default_instance_);
}
inline ::machinetalk::PmCartesian* Emc_Traj_Circular_Move::release_normal() {
  // @@protoc_insertion_point(field_release:machinetalk.Emc_Traj_Circular_Move.normal)
  clear_has_normal();
  ::machinetalk::PmCartesian* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline ::machinetalk::PmCartesian* Emc_Traj_Circular_Move::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::PmCartesian>(GetArenaNoVirtual());
    normal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Emc_Traj_Circular_Move.normal)
  return normal_;
}
inline void Emc_Traj_Circular_Move::set_allocated_normal(::machinetalk::PmCartesian* normal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(normal_);
  }
  if (normal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      normal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, normal, submessage_arena);
    }
    set_has_normal();
  } else {
    clear_has_normal();
  }
  normal_ = normal;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Emc_Traj_Circular_Move.normal)
}

// required double vel = 30;
inline bool Emc_Traj_Circular_Move::has_vel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_vel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Emc_Traj_Circular_Move::clear_has_vel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Emc_Traj_Circular_Move::clear_vel() {
  vel_ = 0;
  clear_has_vel();
}
inline double Emc_Traj_Circular_Move::vel() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Circular_Move.vel)
  return vel_;
}
inline void Emc_Traj_Circular_Move::set_vel(double value) {
  set_has_vel();
  vel_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Circular_Move.vel)
}

// required double ini_maxvel = 40;
inline bool Emc_Traj_Circular_Move::has_ini_maxvel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_ini_maxvel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Emc_Traj_Circular_Move::clear_has_ini_maxvel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Emc_Traj_Circular_Move::clear_ini_maxvel() {
  ini_maxvel_ = 0;
  clear_has_ini_maxvel();
}
inline double Emc_Traj_Circular_Move::ini_maxvel() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Circular_Move.ini_maxvel)
  return ini_maxvel_;
}
inline void Emc_Traj_Circular_Move::set_ini_maxvel(double value) {
  set_has_ini_maxvel();
  ini_maxvel_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Circular_Move.ini_maxvel)
}

// required double acc = 50;
inline bool Emc_Traj_Circular_Move::has_acc() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_acc() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Emc_Traj_Circular_Move::clear_has_acc() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Emc_Traj_Circular_Move::clear_acc() {
  acc_ = 0;
  clear_has_acc();
}
inline double Emc_Traj_Circular_Move::acc() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Circular_Move.acc)
  return acc_;
}
inline void Emc_Traj_Circular_Move::set_acc(double value) {
  set_has_acc();
  acc_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Circular_Move.acc)
}

// required bool feed_mode = 60;
inline bool Emc_Traj_Circular_Move::has_feed_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_feed_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Emc_Traj_Circular_Move::clear_has_feed_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Emc_Traj_Circular_Move::clear_feed_mode() {
  feed_mode_ = false;
  clear_has_feed_mode();
}
inline bool Emc_Traj_Circular_Move::feed_mode() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Circular_Move.feed_mode)
  return feed_mode_;
}
inline void Emc_Traj_Circular_Move::set_feed_mode(bool value) {
  set_has_feed_mode();
  feed_mode_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Circular_Move.feed_mode)
}

// required int32 turn = 70;
inline bool Emc_Traj_Circular_Move::has_turn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Emc_Traj_Circular_Move::set_has_turn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Emc_Traj_Circular_Move::clear_has_turn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Emc_Traj_Circular_Move::clear_turn() {
  turn_ = 0;
  clear_has_turn();
}
inline ::google::protobuf::int32 Emc_Traj_Circular_Move::turn() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Circular_Move.turn)
  return turn_;
}
inline void Emc_Traj_Circular_Move::set_turn(::google::protobuf::int32 value) {
  set_has_turn();
  turn_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Circular_Move.turn)
}

// -------------------------------------------------------------------

// Emc_Traj_Rigid_Tap

// required .machinetalk.EmcPose pos = 20;
inline bool Emc_Traj_Rigid_Tap::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Rigid_Tap::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Rigid_Tap::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::machinetalk::EmcPose& Emc_Traj_Rigid_Tap::_internal_pos() const {
  return *pos_;
}
inline const ::machinetalk::EmcPose& Emc_Traj_Rigid_Tap::pos() const {
  const ::machinetalk::EmcPose* p = pos_;
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Rigid_Tap.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcPose*>(
      &::machinetalk::_EmcPose_default_instance_);
}
inline ::machinetalk::EmcPose* Emc_Traj_Rigid_Tap::release_pos() {
  // @@protoc_insertion_point(field_release:machinetalk.Emc_Traj_Rigid_Tap.pos)
  clear_has_pos();
  ::machinetalk::EmcPose* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline ::machinetalk::EmcPose* Emc_Traj_Rigid_Tap::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcPose>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Emc_Traj_Rigid_Tap.pos)
  return pos_;
}
inline void Emc_Traj_Rigid_Tap::set_allocated_pos(::machinetalk::EmcPose* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pos_);
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    set_has_pos();
  } else {
    clear_has_pos();
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Emc_Traj_Rigid_Tap.pos)
}

// required double vel = 30;
inline bool Emc_Traj_Rigid_Tap::has_vel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Traj_Rigid_Tap::set_has_vel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Traj_Rigid_Tap::clear_has_vel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Traj_Rigid_Tap::clear_vel() {
  vel_ = 0;
  clear_has_vel();
}
inline double Emc_Traj_Rigid_Tap::vel() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Rigid_Tap.vel)
  return vel_;
}
inline void Emc_Traj_Rigid_Tap::set_vel(double value) {
  set_has_vel();
  vel_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Rigid_Tap.vel)
}

// required double ini_maxvel = 40;
inline bool Emc_Traj_Rigid_Tap::has_ini_maxvel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Traj_Rigid_Tap::set_has_ini_maxvel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Traj_Rigid_Tap::clear_has_ini_maxvel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Traj_Rigid_Tap::clear_ini_maxvel() {
  ini_maxvel_ = 0;
  clear_has_ini_maxvel();
}
inline double Emc_Traj_Rigid_Tap::ini_maxvel() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Rigid_Tap.ini_maxvel)
  return ini_maxvel_;
}
inline void Emc_Traj_Rigid_Tap::set_ini_maxvel(double value) {
  set_has_ini_maxvel();
  ini_maxvel_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Rigid_Tap.ini_maxvel)
}

// required double acc = 50;
inline bool Emc_Traj_Rigid_Tap::has_acc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Emc_Traj_Rigid_Tap::set_has_acc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Emc_Traj_Rigid_Tap::clear_has_acc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Emc_Traj_Rigid_Tap::clear_acc() {
  acc_ = 0;
  clear_has_acc();
}
inline double Emc_Traj_Rigid_Tap::acc() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Rigid_Tap.acc)
  return acc_;
}
inline void Emc_Traj_Rigid_Tap::set_acc(double value) {
  set_has_acc();
  acc_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Rigid_Tap.acc)
}

// -------------------------------------------------------------------

// Emc_Traj_Set_Term_Cond

// required .machinetalk.TermConditionType cond = 10;
inline bool Emc_Traj_Set_Term_Cond::has_cond() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Traj_Set_Term_Cond::set_has_cond() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Traj_Set_Term_Cond::clear_has_cond() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Traj_Set_Term_Cond::clear_cond() {
  cond_ = 1;
  clear_has_cond();
}
inline ::machinetalk::TermConditionType Emc_Traj_Set_Term_Cond::cond() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Set_Term_Cond.cond)
  return static_cast< ::machinetalk::TermConditionType >(cond_);
}
inline void Emc_Traj_Set_Term_Cond::set_cond(::machinetalk::TermConditionType value) {
  assert(::machinetalk::TermConditionType_IsValid(value));
  set_has_cond();
  cond_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Set_Term_Cond.cond)
}

// required double tolerance = 20;
inline bool Emc_Traj_Set_Term_Cond::has_tolerance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_Term_Cond::set_has_tolerance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_Term_Cond::clear_has_tolerance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Set_Term_Cond::clear_tolerance() {
  tolerance_ = 0;
  clear_has_tolerance();
}
inline double Emc_Traj_Set_Term_Cond::tolerance() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Set_Term_Cond.tolerance)
  return tolerance_;
}
inline void Emc_Traj_Set_Term_Cond::set_tolerance(double value) {
  set_has_tolerance();
  tolerance_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Set_Term_Cond.tolerance)
}

// -------------------------------------------------------------------

// Emc_Traj_Set_Spindlesync

// required double feed_per_revolution = 10;
inline bool Emc_Traj_Set_Spindlesync::has_feed_per_revolution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Traj_Set_Spindlesync::set_has_feed_per_revolution() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Traj_Set_Spindlesync::clear_has_feed_per_revolution() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Traj_Set_Spindlesync::clear_feed_per_revolution() {
  feed_per_revolution_ = 0;
  clear_has_feed_per_revolution();
}
inline double Emc_Traj_Set_Spindlesync::feed_per_revolution() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Set_Spindlesync.feed_per_revolution)
  return feed_per_revolution_;
}
inline void Emc_Traj_Set_Spindlesync::set_feed_per_revolution(double value) {
  set_has_feed_per_revolution();
  feed_per_revolution_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Set_Spindlesync.feed_per_revolution)
}

// required bool velocity_mode = 20;
inline bool Emc_Traj_Set_Spindlesync::has_velocity_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_Spindlesync::set_has_velocity_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_Spindlesync::clear_has_velocity_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Set_Spindlesync::clear_velocity_mode() {
  velocity_mode_ = false;
  clear_has_velocity_mode();
}
inline bool Emc_Traj_Set_Spindlesync::velocity_mode() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Set_Spindlesync.velocity_mode)
  return velocity_mode_;
}
inline void Emc_Traj_Set_Spindlesync::set_velocity_mode(bool value) {
  set_has_velocity_mode();
  velocity_mode_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Set_Spindlesync.velocity_mode)
}

// -------------------------------------------------------------------

// Emc_Traj_Delay

// required double delay = 10;
inline bool Emc_Traj_Delay::has_delay() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Delay::set_has_delay() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Delay::clear_has_delay() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Delay::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline double Emc_Traj_Delay::delay() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Delay.delay)
  return delay_;
}
inline void Emc_Traj_Delay::set_delay(double value) {
  set_has_delay();
  delay_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Delay.delay)
}

// -------------------------------------------------------------------

// Emc_Spindle_On

// required double speed = 10 [default = 0];
inline bool Emc_Spindle_On::has_speed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Spindle_On::set_has_speed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Spindle_On::clear_has_speed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Spindle_On::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double Emc_Spindle_On::speed() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Spindle_On.speed)
  return speed_;
}
inline void Emc_Spindle_On::set_speed(double value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Spindle_On.speed)
}

// required double factor = 20 [default = 0];
inline bool Emc_Spindle_On::has_factor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Spindle_On::set_has_factor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Spindle_On::clear_has_factor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Spindle_On::clear_factor() {
  factor_ = 0;
  clear_has_factor();
}
inline double Emc_Spindle_On::factor() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Spindle_On.factor)
  return factor_;
}
inline void Emc_Spindle_On::set_factor(double value) {
  set_has_factor();
  factor_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Spindle_On.factor)
}

// required double xoffset = 30 [default = 0];
inline bool Emc_Spindle_On::has_xoffset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Spindle_On::set_has_xoffset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Spindle_On::clear_has_xoffset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Spindle_On::clear_xoffset() {
  xoffset_ = 0;
  clear_has_xoffset();
}
inline double Emc_Spindle_On::xoffset() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Spindle_On.xoffset)
  return xoffset_;
}
inline void Emc_Spindle_On::set_xoffset(double value) {
  set_has_xoffset();
  xoffset_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Spindle_On.xoffset)
}

// -------------------------------------------------------------------

// Emc_Spindle_Speed

// required double speed = 10;
inline bool Emc_Spindle_Speed::has_speed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Spindle_Speed::set_has_speed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Spindle_Speed::clear_has_speed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Spindle_Speed::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline double Emc_Spindle_Speed::speed() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Spindle_Speed.speed)
  return speed_;
}
inline void Emc_Spindle_Speed::set_speed(double value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Spindle_Speed.speed)
}

// required double factor = 20;
inline bool Emc_Spindle_Speed::has_factor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Spindle_Speed::set_has_factor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Spindle_Speed::clear_has_factor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Spindle_Speed::clear_factor() {
  factor_ = 0;
  clear_has_factor();
}
inline double Emc_Spindle_Speed::factor() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Spindle_Speed.factor)
  return factor_;
}
inline void Emc_Spindle_Speed::set_factor(double value) {
  set_has_factor();
  factor_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Spindle_Speed.factor)
}

// required double xoffset = 30;
inline bool Emc_Spindle_Speed::has_xoffset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Spindle_Speed::set_has_xoffset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Spindle_Speed::clear_has_xoffset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Spindle_Speed::clear_xoffset() {
  xoffset_ = 0;
  clear_has_xoffset();
}
inline double Emc_Spindle_Speed::xoffset() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Spindle_Speed.xoffset)
  return xoffset_;
}
inline void Emc_Spindle_Speed::set_xoffset(double value) {
  set_has_xoffset();
  xoffset_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Spindle_Speed.xoffset)
}

// -------------------------------------------------------------------

// Emc_Spindle_Orient

// required double orientation = 10;
inline bool Emc_Spindle_Orient::has_orientation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Spindle_Orient::set_has_orientation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Spindle_Orient::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Spindle_Orient::clear_orientation() {
  orientation_ = 0;
  clear_has_orientation();
}
inline double Emc_Spindle_Orient::orientation() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Spindle_Orient.orientation)
  return orientation_;
}
inline void Emc_Spindle_Orient::set_orientation(double value) {
  set_has_orientation();
  orientation_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Spindle_Orient.orientation)
}

// required .machinetalk.CanonDirection mode = 20;
inline bool Emc_Spindle_Orient::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Spindle_Orient::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Spindle_Orient::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Spindle_Orient::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
inline ::machinetalk::CanonDirection Emc_Spindle_Orient::mode() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Spindle_Orient.mode)
  return static_cast< ::machinetalk::CanonDirection >(mode_);
}
inline void Emc_Spindle_Orient::set_mode(::machinetalk::CanonDirection value) {
  assert(::machinetalk::CanonDirection_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Spindle_Orient.mode)
}

// -------------------------------------------------------------------

// Emc_Spindle_Wait_Orient_Complete

// required double timeout = 10;
inline bool Emc_Spindle_Wait_Orient_Complete::has_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Spindle_Wait_Orient_Complete::set_has_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Spindle_Wait_Orient_Complete::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Spindle_Wait_Orient_Complete::clear_timeout() {
  timeout_ = 0;
  clear_has_timeout();
}
inline double Emc_Spindle_Wait_Orient_Complete::timeout() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Spindle_Wait_Orient_Complete.timeout)
  return timeout_;
}
inline void Emc_Spindle_Wait_Orient_Complete::set_timeout(double value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Spindle_Wait_Orient_Complete.timeout)
}

// -------------------------------------------------------------------

// Emc_Tool_Set_Offset

// required int32 pocket = 10;
inline bool Emc_Tool_Set_Offset::has_pocket() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Tool_Set_Offset::set_has_pocket() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Tool_Set_Offset::clear_has_pocket() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Tool_Set_Offset::clear_pocket() {
  pocket_ = 0;
  clear_has_pocket();
}
inline ::google::protobuf::int32 Emc_Tool_Set_Offset::pocket() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Tool_Set_Offset.pocket)
  return pocket_;
}
inline void Emc_Tool_Set_Offset::set_pocket(::google::protobuf::int32 value) {
  set_has_pocket();
  pocket_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Tool_Set_Offset.pocket)
}

// required int32 toolno = 15;
inline bool Emc_Tool_Set_Offset::has_toolno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Emc_Tool_Set_Offset::set_has_toolno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Emc_Tool_Set_Offset::clear_has_toolno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Emc_Tool_Set_Offset::clear_toolno() {
  toolno_ = 0;
  clear_has_toolno();
}
inline ::google::protobuf::int32 Emc_Tool_Set_Offset::toolno() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Tool_Set_Offset.toolno)
  return toolno_;
}
inline void Emc_Tool_Set_Offset::set_toolno(::google::protobuf::int32 value) {
  set_has_toolno();
  toolno_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Tool_Set_Offset.toolno)
}

// required .machinetalk.EmcPose offset = 20;
inline bool Emc_Tool_Set_Offset::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Tool_Set_Offset::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Tool_Set_Offset::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::machinetalk::EmcPose& Emc_Tool_Set_Offset::_internal_offset() const {
  return *offset_;
}
inline const ::machinetalk::EmcPose& Emc_Tool_Set_Offset::offset() const {
  const ::machinetalk::EmcPose* p = offset_;
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Tool_Set_Offset.offset)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcPose*>(
      &::machinetalk::_EmcPose_default_instance_);
}
inline ::machinetalk::EmcPose* Emc_Tool_Set_Offset::release_offset() {
  // @@protoc_insertion_point(field_release:machinetalk.Emc_Tool_Set_Offset.offset)
  clear_has_offset();
  ::machinetalk::EmcPose* temp = offset_;
  offset_ = NULL;
  return temp;
}
inline ::machinetalk::EmcPose* Emc_Tool_Set_Offset::mutable_offset() {
  set_has_offset();
  if (offset_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcPose>(GetArenaNoVirtual());
    offset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Emc_Tool_Set_Offset.offset)
  return offset_;
}
inline void Emc_Tool_Set_Offset::set_allocated_offset(::machinetalk::EmcPose* offset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(offset_);
  }
  if (offset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      offset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, offset, submessage_arena);
    }
    set_has_offset();
  } else {
    clear_has_offset();
  }
  offset_ = offset;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Emc_Tool_Set_Offset.offset)
}

// required double diameter = 30;
inline bool Emc_Tool_Set_Offset::has_diameter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Emc_Tool_Set_Offset::set_has_diameter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Emc_Tool_Set_Offset::clear_has_diameter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Emc_Tool_Set_Offset::clear_diameter() {
  diameter_ = 0;
  clear_has_diameter();
}
inline double Emc_Tool_Set_Offset::diameter() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Tool_Set_Offset.diameter)
  return diameter_;
}
inline void Emc_Tool_Set_Offset::set_diameter(double value) {
  set_has_diameter();
  diameter_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Tool_Set_Offset.diameter)
}

// required double frontangle = 40;
inline bool Emc_Tool_Set_Offset::has_frontangle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Emc_Tool_Set_Offset::set_has_frontangle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Emc_Tool_Set_Offset::clear_has_frontangle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Emc_Tool_Set_Offset::clear_frontangle() {
  frontangle_ = 0;
  clear_has_frontangle();
}
inline double Emc_Tool_Set_Offset::frontangle() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Tool_Set_Offset.frontangle)
  return frontangle_;
}
inline void Emc_Tool_Set_Offset::set_frontangle(double value) {
  set_has_frontangle();
  frontangle_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Tool_Set_Offset.frontangle)
}

// required double backangle = 50;
inline bool Emc_Tool_Set_Offset::has_backangle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Emc_Tool_Set_Offset::set_has_backangle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Emc_Tool_Set_Offset::clear_has_backangle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Emc_Tool_Set_Offset::clear_backangle() {
  backangle_ = 0;
  clear_has_backangle();
}
inline double Emc_Tool_Set_Offset::backangle() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Tool_Set_Offset.backangle)
  return backangle_;
}
inline void Emc_Tool_Set_Offset::set_backangle(double value) {
  set_has_backangle();
  backangle_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Tool_Set_Offset.backangle)
}

// required int32 orientation = 60;
inline bool Emc_Tool_Set_Offset::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Tool_Set_Offset::set_has_orientation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Tool_Set_Offset::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Tool_Set_Offset::clear_orientation() {
  orientation_ = 0;
  clear_has_orientation();
}
inline ::google::protobuf::int32 Emc_Tool_Set_Offset::orientation() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Tool_Set_Offset.orientation)
  return orientation_;
}
inline void Emc_Tool_Set_Offset::set_orientation(::google::protobuf::int32 value) {
  set_has_orientation();
  orientation_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Tool_Set_Offset.orientation)
}

// -------------------------------------------------------------------

// Emc_Traj_Set_Offset

// required .machinetalk.EmcPose offset = 10;
inline bool Emc_Traj_Set_Offset::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_Offset::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_Offset::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::machinetalk::EmcPose& Emc_Traj_Set_Offset::_internal_offset() const {
  return *offset_;
}
inline const ::machinetalk::EmcPose& Emc_Traj_Set_Offset::offset() const {
  const ::machinetalk::EmcPose* p = offset_;
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Set_Offset.offset)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcPose*>(
      &::machinetalk::_EmcPose_default_instance_);
}
inline ::machinetalk::EmcPose* Emc_Traj_Set_Offset::release_offset() {
  // @@protoc_insertion_point(field_release:machinetalk.Emc_Traj_Set_Offset.offset)
  clear_has_offset();
  ::machinetalk::EmcPose* temp = offset_;
  offset_ = NULL;
  return temp;
}
inline ::machinetalk::EmcPose* Emc_Traj_Set_Offset::mutable_offset() {
  set_has_offset();
  if (offset_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcPose>(GetArenaNoVirtual());
    offset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Emc_Traj_Set_Offset.offset)
  return offset_;
}
inline void Emc_Traj_Set_Offset::set_allocated_offset(::machinetalk::EmcPose* offset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(offset_);
  }
  if (offset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      offset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, offset, submessage_arena);
    }
    set_has_offset();
  } else {
    clear_has_offset();
  }
  offset_ = offset;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Emc_Traj_Set_Offset.offset)
}

// -------------------------------------------------------------------

// Emc_Tool_Prepare

// required int32 pocket = 10;
inline bool Emc_Tool_Prepare::has_pocket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Tool_Prepare::set_has_pocket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Tool_Prepare::clear_has_pocket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Tool_Prepare::clear_pocket() {
  pocket_ = 0;
  clear_has_pocket();
}
inline ::google::protobuf::int32 Emc_Tool_Prepare::pocket() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Tool_Prepare.pocket)
  return pocket_;
}
inline void Emc_Tool_Prepare::set_pocket(::google::protobuf::int32 value) {
  set_has_pocket();
  pocket_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Tool_Prepare.pocket)
}

// required int32 tool = 20;
inline bool Emc_Tool_Prepare::has_tool() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Tool_Prepare::set_has_tool() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Tool_Prepare::clear_has_tool() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Tool_Prepare::clear_tool() {
  tool_ = 0;
  clear_has_tool();
}
inline ::google::protobuf::int32 Emc_Tool_Prepare::tool() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Tool_Prepare.tool)
  return tool_;
}
inline void Emc_Tool_Prepare::set_tool(::google::protobuf::int32 value) {
  set_has_tool();
  tool_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Tool_Prepare.tool)
}

// -------------------------------------------------------------------

// Emc_Tool_Set_Number

// required int32 tool = 10;
inline bool Emc_Tool_Set_Number::has_tool() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Tool_Set_Number::set_has_tool() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Tool_Set_Number::clear_has_tool() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Tool_Set_Number::clear_tool() {
  tool_ = 0;
  clear_has_tool();
}
inline ::google::protobuf::int32 Emc_Tool_Set_Number::tool() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Tool_Set_Number.tool)
  return tool_;
}
inline void Emc_Tool_Set_Number::set_tool(::google::protobuf::int32 value) {
  set_has_tool();
  tool_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Tool_Set_Number.tool)
}

// -------------------------------------------------------------------

// Emc_Traj_Set_Fo_Enable

// required bool mode = 10;
inline bool Emc_Traj_Set_Fo_Enable::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_Fo_Enable::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_Fo_Enable::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Set_Fo_Enable::clear_mode() {
  mode_ = false;
  clear_has_mode();
}
inline bool Emc_Traj_Set_Fo_Enable::mode() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Set_Fo_Enable.mode)
  return mode_;
}
inline void Emc_Traj_Set_Fo_Enable::set_mode(bool value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Set_Fo_Enable.mode)
}

// -------------------------------------------------------------------

// Emc_Traj_Set_So_Enable

// required bool mode = 10;
inline bool Emc_Traj_Set_So_Enable::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_So_Enable::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_So_Enable::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Set_So_Enable::clear_mode() {
  mode_ = false;
  clear_has_mode();
}
inline bool Emc_Traj_Set_So_Enable::mode() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Set_So_Enable.mode)
  return mode_;
}
inline void Emc_Traj_Set_So_Enable::set_mode(bool value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Set_So_Enable.mode)
}

// -------------------------------------------------------------------

// Emc_Traj_Set_Fh_Enable

// required bool mode = 10;
inline bool Emc_Traj_Set_Fh_Enable::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Traj_Set_Fh_Enable::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Traj_Set_Fh_Enable::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Traj_Set_Fh_Enable::clear_mode() {
  mode_ = false;
  clear_has_mode();
}
inline bool Emc_Traj_Set_Fh_Enable::mode() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Traj_Set_Fh_Enable.mode)
  return mode_;
}
inline void Emc_Traj_Set_Fh_Enable::set_mode(bool value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Traj_Set_Fh_Enable.mode)
}

// -------------------------------------------------------------------

// Emc_Motion_Adaptive

// required bool status = 10;
inline bool Emc_Motion_Adaptive::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Motion_Adaptive::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Motion_Adaptive::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Motion_Adaptive::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool Emc_Motion_Adaptive::status() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Motion_Adaptive.status)
  return status_;
}
inline void Emc_Motion_Adaptive::set_status(bool value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Motion_Adaptive.status)
}

// -------------------------------------------------------------------

// Emc_Operator_Display

// required int32 id = 10;
inline bool Emc_Operator_Display::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Operator_Display::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Operator_Display::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Operator_Display::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Emc_Operator_Display::id() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Operator_Display.id)
  return id_;
}
inline void Emc_Operator_Display::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Operator_Display.id)
}

// required string display = 20;
inline bool Emc_Operator_Display::has_display() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Operator_Display::set_has_display() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Operator_Display::clear_has_display() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Operator_Display::clear_display() {
  display_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_display();
}
inline const ::std::string& Emc_Operator_Display::display() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Operator_Display.display)
  return display_.GetNoArena();
}
inline void Emc_Operator_Display::set_display(const ::std::string& value) {
  set_has_display();
  display_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Operator_Display.display)
}
#if LANG_CXX11
inline void Emc_Operator_Display::set_display(::std::string&& value) {
  set_has_display();
  display_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Emc_Operator_Display.display)
}
#endif
inline void Emc_Operator_Display::set_display(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_display();
  display_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Emc_Operator_Display.display)
}
inline void Emc_Operator_Display::set_display(const char* value, size_t size) {
  set_has_display();
  display_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Emc_Operator_Display.display)
}
inline ::std::string* Emc_Operator_Display::mutable_display() {
  set_has_display();
  // @@protoc_insertion_point(field_mutable:machinetalk.Emc_Operator_Display.display)
  return display_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Emc_Operator_Display::release_display() {
  // @@protoc_insertion_point(field_release:machinetalk.Emc_Operator_Display.display)
  if (!has_display()) {
    return NULL;
  }
  clear_has_display();
  return display_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Emc_Operator_Display::set_allocated_display(::std::string* display) {
  if (display != NULL) {
    set_has_display();
  } else {
    clear_has_display();
  }
  display_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), display);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Emc_Operator_Display.display)
}

// -------------------------------------------------------------------

// Emc_Operator_Text

// required int32 id = 10;
inline bool Emc_Operator_Text::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Operator_Text::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Operator_Text::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Operator_Text::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Emc_Operator_Text::id() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Operator_Text.id)
  return id_;
}
inline void Emc_Operator_Text::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Operator_Text.id)
}

// required string text = 20;
inline bool Emc_Operator_Text::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Operator_Text::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Operator_Text::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Operator_Text::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Emc_Operator_Text::text() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Operator_Text.text)
  return text_.GetNoArena();
}
inline void Emc_Operator_Text::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Operator_Text.text)
}
#if LANG_CXX11
inline void Emc_Operator_Text::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Emc_Operator_Text.text)
}
#endif
inline void Emc_Operator_Text::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Emc_Operator_Text.text)
}
inline void Emc_Operator_Text::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Emc_Operator_Text.text)
}
inline ::std::string* Emc_Operator_Text::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:machinetalk.Emc_Operator_Text.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Emc_Operator_Text::release_text() {
  // @@protoc_insertion_point(field_release:machinetalk.Emc_Operator_Text.text)
  if (!has_text()) {
    return NULL;
  }
  clear_has_text();
  return text_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Emc_Operator_Text::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Emc_Operator_Text.text)
}

// -------------------------------------------------------------------

// Emc_Operator_Error

// required int32 id = 10;
inline bool Emc_Operator_Error::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Operator_Error::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Operator_Error::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Operator_Error::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Emc_Operator_Error::id() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Operator_Error.id)
  return id_;
}
inline void Emc_Operator_Error::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Operator_Error.id)
}

// required string error = 20;
inline bool Emc_Operator_Error::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Operator_Error::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Operator_Error::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Operator_Error::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& Emc_Operator_Error::error() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Operator_Error.error)
  return error_.GetNoArena();
}
inline void Emc_Operator_Error::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Operator_Error.error)
}
#if LANG_CXX11
inline void Emc_Operator_Error::set_error(::std::string&& value) {
  set_has_error();
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Emc_Operator_Error.error)
}
#endif
inline void Emc_Operator_Error::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Emc_Operator_Error.error)
}
inline void Emc_Operator_Error::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Emc_Operator_Error.error)
}
inline ::std::string* Emc_Operator_Error::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:machinetalk.Emc_Operator_Error.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Emc_Operator_Error::release_error() {
  // @@protoc_insertion_point(field_release:machinetalk.Emc_Operator_Error.error)
  if (!has_error()) {
    return NULL;
  }
  clear_has_error();
  return error_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Emc_Operator_Error::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Emc_Operator_Error.error)
}

// -------------------------------------------------------------------

// Emc_Motion_Set_Dout

// required uint32 index = 10;
inline bool Emc_Motion_Set_Dout::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Motion_Set_Dout::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Motion_Set_Dout::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Motion_Set_Dout::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 Emc_Motion_Set_Dout::index() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Motion_Set_Dout.index)
  return index_;
}
inline void Emc_Motion_Set_Dout::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Motion_Set_Dout.index)
}

// required bool start = 20;
inline bool Emc_Motion_Set_Dout::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Motion_Set_Dout::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Motion_Set_Dout::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Motion_Set_Dout::clear_start() {
  start_ = false;
  clear_has_start();
}
inline bool Emc_Motion_Set_Dout::start() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Motion_Set_Dout.start)
  return start_;
}
inline void Emc_Motion_Set_Dout::set_start(bool value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Motion_Set_Dout.start)
}

// required bool end = 30;
inline bool Emc_Motion_Set_Dout::has_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Motion_Set_Dout::set_has_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Motion_Set_Dout::clear_has_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Motion_Set_Dout::clear_end() {
  end_ = false;
  clear_has_end();
}
inline bool Emc_Motion_Set_Dout::end() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Motion_Set_Dout.end)
  return end_;
}
inline void Emc_Motion_Set_Dout::set_end(bool value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Motion_Set_Dout.end)
}

// required bool now = 40;
inline bool Emc_Motion_Set_Dout::has_now() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Emc_Motion_Set_Dout::set_has_now() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Emc_Motion_Set_Dout::clear_has_now() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Emc_Motion_Set_Dout::clear_now() {
  now_ = false;
  clear_has_now();
}
inline bool Emc_Motion_Set_Dout::now() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Motion_Set_Dout.now)
  return now_;
}
inline void Emc_Motion_Set_Dout::set_now(bool value) {
  set_has_now();
  now_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Motion_Set_Dout.now)
}

// -------------------------------------------------------------------

// Emc_Motion_Set_Aout

// required uint32 index = 10;
inline bool Emc_Motion_Set_Aout::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Motion_Set_Aout::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Motion_Set_Aout::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Motion_Set_Aout::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 Emc_Motion_Set_Aout::index() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Motion_Set_Aout.index)
  return index_;
}
inline void Emc_Motion_Set_Aout::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Motion_Set_Aout.index)
}

// required double start = 20;
inline bool Emc_Motion_Set_Aout::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Motion_Set_Aout::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Motion_Set_Aout::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Motion_Set_Aout::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline double Emc_Motion_Set_Aout::start() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Motion_Set_Aout.start)
  return start_;
}
inline void Emc_Motion_Set_Aout::set_start(double value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Motion_Set_Aout.start)
}

// required double end = 30;
inline bool Emc_Motion_Set_Aout::has_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Emc_Motion_Set_Aout::set_has_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Emc_Motion_Set_Aout::clear_has_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Emc_Motion_Set_Aout::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline double Emc_Motion_Set_Aout::end() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Motion_Set_Aout.end)
  return end_;
}
inline void Emc_Motion_Set_Aout::set_end(double value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Motion_Set_Aout.end)
}

// required bool now = 40;
inline bool Emc_Motion_Set_Aout::has_now() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Motion_Set_Aout::set_has_now() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Motion_Set_Aout::clear_has_now() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Motion_Set_Aout::clear_now() {
  now_ = false;
  clear_has_now();
}
inline bool Emc_Motion_Set_Aout::now() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Motion_Set_Aout.now)
  return now_;
}
inline void Emc_Motion_Set_Aout::set_now(bool value) {
  set_has_now();
  now_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Motion_Set_Aout.now)
}

// -------------------------------------------------------------------

// Emc_Aux_Input_Wait

// required uint32 index = 10;
inline bool Emc_Aux_Input_Wait::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Emc_Aux_Input_Wait::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Emc_Aux_Input_Wait::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Emc_Aux_Input_Wait::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 Emc_Aux_Input_Wait::index() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Aux_Input_Wait.index)
  return index_;
}
inline void Emc_Aux_Input_Wait::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Aux_Input_Wait.index)
}

// required .machinetalk.InputType input_type = 20;
inline bool Emc_Aux_Input_Wait::has_input_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Emc_Aux_Input_Wait::set_has_input_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Emc_Aux_Input_Wait::clear_has_input_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Emc_Aux_Input_Wait::clear_input_type() {
  input_type_ = 0;
  clear_has_input_type();
}
inline ::machinetalk::InputType Emc_Aux_Input_Wait::input_type() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Aux_Input_Wait.input_type)
  return static_cast< ::machinetalk::InputType >(input_type_);
}
inline void Emc_Aux_Input_Wait::set_input_type(::machinetalk::InputType value) {
  assert(::machinetalk::InputType_IsValid(value));
  set_has_input_type();
  input_type_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Aux_Input_Wait.input_type)
}

// required .machinetalk.WaitType wait_type = 30;
inline bool Emc_Aux_Input_Wait::has_wait_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Aux_Input_Wait::set_has_wait_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Aux_Input_Wait::clear_has_wait_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Aux_Input_Wait::clear_wait_type() {
  wait_type_ = 0;
  clear_has_wait_type();
}
inline ::machinetalk::WaitType Emc_Aux_Input_Wait::wait_type() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Aux_Input_Wait.wait_type)
  return static_cast< ::machinetalk::WaitType >(wait_type_);
}
inline void Emc_Aux_Input_Wait::set_wait_type(::machinetalk::WaitType value) {
  assert(::machinetalk::WaitType_IsValid(value));
  set_has_wait_type();
  wait_type_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Aux_Input_Wait.wait_type)
}

// required double timeout = 40;
inline bool Emc_Aux_Input_Wait::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Emc_Aux_Input_Wait::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Emc_Aux_Input_Wait::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Emc_Aux_Input_Wait::clear_timeout() {
  timeout_ = 0;
  clear_has_timeout();
}
inline double Emc_Aux_Input_Wait::timeout() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Aux_Input_Wait.timeout)
  return timeout_;
}
inline void Emc_Aux_Input_Wait::set_timeout(double value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Aux_Input_Wait.timeout)
}

// -------------------------------------------------------------------

// Emc_Exec_Plugin_Ca1l

// required bytes call = 20;
inline bool Emc_Exec_Plugin_Ca1l::has_call() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Exec_Plugin_Ca1l::set_has_call() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Exec_Plugin_Ca1l::clear_has_call() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Exec_Plugin_Ca1l::clear_call() {
  call_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_call();
}
inline const ::std::string& Emc_Exec_Plugin_Ca1l::call() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Exec_Plugin_Ca1l.call)
  return call_.GetNoArena();
}
inline void Emc_Exec_Plugin_Ca1l::set_call(const ::std::string& value) {
  set_has_call();
  call_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Exec_Plugin_Ca1l.call)
}
#if LANG_CXX11
inline void Emc_Exec_Plugin_Ca1l::set_call(::std::string&& value) {
  set_has_call();
  call_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Emc_Exec_Plugin_Ca1l.call)
}
#endif
inline void Emc_Exec_Plugin_Ca1l::set_call(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_call();
  call_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Emc_Exec_Plugin_Ca1l.call)
}
inline void Emc_Exec_Plugin_Ca1l::set_call(const void* value, size_t size) {
  set_has_call();
  call_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Emc_Exec_Plugin_Ca1l.call)
}
inline ::std::string* Emc_Exec_Plugin_Ca1l::mutable_call() {
  set_has_call();
  // @@protoc_insertion_point(field_mutable:machinetalk.Emc_Exec_Plugin_Ca1l.call)
  return call_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Emc_Exec_Plugin_Ca1l::release_call() {
  // @@protoc_insertion_point(field_release:machinetalk.Emc_Exec_Plugin_Ca1l.call)
  if (!has_call()) {
    return NULL;
  }
  clear_has_call();
  return call_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Emc_Exec_Plugin_Ca1l::set_allocated_call(::std::string* call) {
  if (call != NULL) {
    set_has_call();
  } else {
    clear_has_call();
  }
  call_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), call);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Emc_Exec_Plugin_Ca1l.call)
}

// -------------------------------------------------------------------

// Emc_Io_Plugin_Call

// required bytes call = 20;
inline bool Emc_Io_Plugin_Call::has_call() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Emc_Io_Plugin_Call::set_has_call() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Emc_Io_Plugin_Call::clear_has_call() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Emc_Io_Plugin_Call::clear_call() {
  call_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_call();
}
inline const ::std::string& Emc_Io_Plugin_Call::call() const {
  // @@protoc_insertion_point(field_get:machinetalk.Emc_Io_Plugin_Call.call)
  return call_.GetNoArena();
}
inline void Emc_Io_Plugin_Call::set_call(const ::std::string& value) {
  set_has_call();
  call_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Emc_Io_Plugin_Call.call)
}
#if LANG_CXX11
inline void Emc_Io_Plugin_Call::set_call(::std::string&& value) {
  set_has_call();
  call_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Emc_Io_Plugin_Call.call)
}
#endif
inline void Emc_Io_Plugin_Call::set_call(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_call();
  call_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Emc_Io_Plugin_Call.call)
}
inline void Emc_Io_Plugin_Call::set_call(const void* value, size_t size) {
  set_has_call();
  call_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Emc_Io_Plugin_Call.call)
}
inline ::std::string* Emc_Io_Plugin_Call::mutable_call() {
  set_has_call();
  // @@protoc_insertion_point(field_mutable:machinetalk.Emc_Io_Plugin_Call.call)
  return call_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Emc_Io_Plugin_Call::release_call() {
  // @@protoc_insertion_point(field_release:machinetalk.Emc_Io_Plugin_Call.call)
  if (!has_call()) {
    return NULL;
  }
  clear_has_call();
  return call_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Emc_Io_Plugin_Call::set_allocated_call(::std::string* call) {
  if (call != NULL) {
    set_has_call();
  } else {
    clear_has_call();
  }
  call_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), call);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Emc_Io_Plugin_Call.call)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace machinetalk

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_machinetalk_2fprotobuf_2fcanon_2eproto
