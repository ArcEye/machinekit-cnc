// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: machinetalk/protobuf/motcmds.proto

#ifndef PROTOBUF_INCLUDED_machinetalk_2fprotobuf_2fmotcmds_2eproto
#define PROTOBUF_INCLUDED_machinetalk_2fprotobuf_2fmotcmds_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "machinetalk/protobuf/emcclass.pb.h"
#include "machinetalk/protobuf/nanopb.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_machinetalk_2fprotobuf_2fmotcmds_2eproto 

namespace protobuf_machinetalk_2fprotobuf_2fmotcmds_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[2];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_machinetalk_2fprotobuf_2fmotcmds_2eproto
namespace machinetalk {
class MotionCommand;
class MotionCommandDefaultTypeInternal;
extern MotionCommandDefaultTypeInternal _MotionCommand_default_instance_;
class MotionStatus;
class MotionStatusDefaultTypeInternal;
extern MotionStatusDefaultTypeInternal _MotionStatus_default_instance_;
}  // namespace machinetalk
namespace google {
namespace protobuf {
template<> ::machinetalk::MotionCommand* Arena::CreateMaybeMessage<::machinetalk::MotionCommand>(Arena*);
template<> ::machinetalk::MotionStatus* Arena::CreateMaybeMessage<::machinetalk::MotionStatus>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace machinetalk {

enum MotionType {
  _EMC_MOTION_TYPE_NONE = 0,
  _EMC_MOTION_TYPE_TRAVERSE = 1,
  _EMC_MOTION_TYPE_FEED = 2,
  _EMC_MOTION_TYPE_ARC = 3,
  _EMC_MOTION_TYPE_TOOLCHANGE = 4,
  _EMC_MOTION_TYPE_PROBING = 5,
  _EMC_MOTION_TYPE_INDEXROTARY = 6
};
bool MotionType_IsValid(int value);
const MotionType MotionType_MIN = _EMC_MOTION_TYPE_NONE;
const MotionType MotionType_MAX = _EMC_MOTION_TYPE_INDEXROTARY;
const int MotionType_ARRAYSIZE = MotionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MotionType_descriptor();
inline const ::std::string& MotionType_Name(MotionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MotionType_descriptor(), value);
}
inline bool MotionType_Parse(
    const ::std::string& name, MotionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MotionType>(
    MotionType_descriptor(), name, value);
}
enum cmd_code_t {
  EMCMOT_ABORT = 4000,
  EMCMOT_AXIS_ABORT = 4001,
  EMCMOT_ENABLE = 4002,
  EMCMOT_DISABLE = 4003,
  EMCMOT_ENABLE_AMPLIFIER = 4004,
  EMCMOT_DISABLE_AMPLIFIER = 4005,
  EMCMOT_ENABLE_WATCHDOG = 4006,
  EMCMOT_DISABLE_WATCHDOG = 4007,
  EMCMOT_ACTIVATE_JOINT = 4008,
  EMCMOT_DEACTIVATE_JOINT = 4009,
  EMCMOT_PAUSE = 4010,
  EMCMOT_RESUME = 4011,
  EMCMOT_STEP = 4012,
  EMCMOT_FREE = 4013,
  EMCMOT_COORD = 4014,
  EMCMOT_TELEOP = 4015,
  EMCMOT_SPINDLE_SCALE = 4016,
  EMCMOT_SS_ENABLE = 4017,
  EMCMOT_FEED_SCALE = 4018,
  EMCMOT_FS_ENABLE = 4019,
  EMCMOT_FH_ENABLE = 4020,
  EMCMOT_AF_ENABLE = 4021,
  EMCMOT_OVERRIDE_LIMITS = 4022,
  EMCMOT_HOME = 4023,
  EMCMOT_UNHOME = 4024,
  EMCMOT_JOG_CONT = 4025,
  EMCMOT_JOG_INCR = 4026,
  EMCMOT_JOG_ABS = 4027,
  EMCMOT_SET_LINE = 4028,
  EMCMOT_SET_CIRCLE = 4029,
  EMCMOT_SET_TELEOP_VECTOR = 4030,
  EMCMOT_CLEAR_PROBE_FLAGS = 4031,
  EMCMOT_PROBE = 4032,
  EMCMOT_RIGID_TAP = 4033,
  EMCMOT_SET_POSITION_LIMITS = 4034,
  EMCMOT_SET_BACKLASH = 4035,
  EMCMOT_SET_MIN_FERROR = 4036,
  EMCMOT_SET_MAX_FERROR = 4037,
  EMCMOT_SET_VEL = 4038,
  EMCMOT_SET_VEL_LIMIT = 4039,
  EMCMOT_SET_JOINT_VEL_LIMIT = 4040,
  EMCMOT_SET_JOINT_ACC_LIMIT = 4041,
  EMCMOT_SET_ACC = 4042,
  EMCMOT_SET_TERM_COND = 4043,
  EMCMOT_SET_NUM_AXES = 4044,
  EMCMOT_SET_WORLD_HOME = 4045,
  EMCMOT_SET_HOMING_PARAMS = 4046,
  EMCMOT_SET_DEBUG = 4047,
  EMCMOT_SET_DOUT = 4048,
  EMCMOT_SET_AOUT = 4049,
  EMCMOT_SET_SPINDLESYNC = 4050,
  EMCMOT_SPINDLE_ON = 4051,
  EMCMOT_SPINDLE_OFF = 4052,
  EMCMOT_SPINDLE_INCREASE = 4053,
  EMCMOT_SPINDLE_DECREASE = 4054,
  EMCMOT_SPINDLE_BRAKE_ENGAGE = 4055,
  EMCMOT_SPINDLE_BRAKE_RELEASE = 4056,
  EMCMOT_SET_MOTOR_OFFSET = 4057,
  EMCMOT_SET_JOINT_COMP = 4058,
  EMCMOT_SET_OFFSET = 4059
};
bool cmd_code_t_IsValid(int value);
const cmd_code_t cmd_code_t_MIN = EMCMOT_ABORT;
const cmd_code_t cmd_code_t_MAX = EMCMOT_SET_OFFSET;
const int cmd_code_t_ARRAYSIZE = cmd_code_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* cmd_code_t_descriptor();
inline const ::std::string& cmd_code_t_Name(cmd_code_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    cmd_code_t_descriptor(), value);
}
inline bool cmd_code_t_Parse(
    const ::std::string& name, cmd_code_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<cmd_code_t>(
    cmd_code_t_descriptor(), name, value);
}
enum cmd_status_t {
  EMCMOT_COMMAND_OK = 0,
  EMCMOT_COMMAND_UNKNOWN_COMMAND = 1,
  EMCMOT_COMMAND_INVALID_COMMAND = 2,
  EMCMOT_COMMAND_INVALID_PARAMS = 3,
  EMCMOT_COMMAND_BAD_EXEC = 4
};
bool cmd_status_t_IsValid(int value);
const cmd_status_t cmd_status_t_MIN = EMCMOT_COMMAND_OK;
const cmd_status_t cmd_status_t_MAX = EMCMOT_COMMAND_BAD_EXEC;
const int cmd_status_t_ARRAYSIZE = cmd_status_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* cmd_status_t_descriptor();
inline const ::std::string& cmd_status_t_Name(cmd_status_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    cmd_status_t_descriptor(), value);
}
inline bool cmd_status_t_Parse(
    const ::std::string& name, cmd_status_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<cmd_status_t>(
    cmd_status_t_descriptor(), name, value);
}
// ===================================================================

class MotionCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.MotionCommand) */ {
 public:
  MotionCommand();
  virtual ~MotionCommand();

  MotionCommand(const MotionCommand& from);

  inline MotionCommand& operator=(const MotionCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MotionCommand(MotionCommand&& from) noexcept
    : MotionCommand() {
    *this = ::std::move(from);
  }

  inline MotionCommand& operator=(MotionCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MotionCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MotionCommand* internal_default_instance() {
    return reinterpret_cast<const MotionCommand*>(
               &_MotionCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MotionCommand* other);
  friend void swap(MotionCommand& a, MotionCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MotionCommand* New() const final {
    return CreateMaybeMessage<MotionCommand>(NULL);
  }

  MotionCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MotionCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MotionCommand& from);
  void MergeFrom(const MotionCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .machinetalk.EmcPose pos = 60;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 60;
  private:
  const ::machinetalk::EmcPose& _internal_pos() const;
  public:
  const ::machinetalk::EmcPose& pos() const;
  ::machinetalk::EmcPose* release_pos();
  ::machinetalk::EmcPose* mutable_pos();
  void set_allocated_pos(::machinetalk::EmcPose* pos);

  // optional .machinetalk.PmCartesian center = 70;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 70;
  private:
  const ::machinetalk::PmCartesian& _internal_center() const;
  public:
  const ::machinetalk::PmCartesian& center() const;
  ::machinetalk::PmCartesian* release_center();
  ::machinetalk::PmCartesian* mutable_center();
  void set_allocated_center(::machinetalk::PmCartesian* center);

  // optional .machinetalk.PmCartesian normal = 80;
  bool has_normal() const;
  void clear_normal();
  static const int kNormalFieldNumber = 80;
  private:
  const ::machinetalk::PmCartesian& _internal_normal() const;
  public:
  const ::machinetalk::PmCartesian& normal() const;
  ::machinetalk::PmCartesian* release_normal();
  ::machinetalk::PmCartesian* mutable_normal();
  void set_allocated_normal(::machinetalk::PmCartesian* normal);

  // optional .machinetalk.EmcPose tool_offset = 420;
  bool has_tool_offset() const;
  void clear_tool_offset();
  static const int kToolOffsetFieldNumber = 420;
  private:
  const ::machinetalk::EmcPose& _internal_tool_offset() const;
  public:
  const ::machinetalk::EmcPose& tool_offset() const;
  ::machinetalk::EmcPose* release_tool_offset();
  ::machinetalk::EmcPose* mutable_tool_offset();
  void set_allocated_tool_offset(::machinetalk::EmcPose* tool_offset);

  // optional double motor_offset = 30;
  bool has_motor_offset() const;
  void clear_motor_offset();
  static const int kMotorOffsetFieldNumber = 30;
  double motor_offset() const;
  void set_motor_offset(double value);

  // optional double maxLimit = 40;
  bool has_maxlimit() const;
  void clear_maxlimit();
  static const int kMaxLimitFieldNumber = 40;
  double maxlimit() const;
  void set_maxlimit(double value);

  // optional int32 probe_type = 410;
  bool has_probe_type() const;
  void clear_probe_type();
  static const int kProbeTypeFieldNumber = 410;
  ::google::protobuf::int32 probe_type() const;
  void set_probe_type(::google::protobuf::int32 value);

  // optional double minLimit = 50;
  bool has_minlimit() const;
  void clear_minlimit();
  static const int kMinLimitFieldNumber = 50;
  double minlimit() const;
  void set_minlimit(double value);

  // required fixed32 commandNum = 20;
  bool has_commandnum() const;
  void clear_commandnum();
  static const int kCommandNumFieldNumber = 20;
  ::google::protobuf::uint32 commandnum() const;
  void set_commandnum(::google::protobuf::uint32 value);

  // optional fixed32 turn = 90;
  bool has_turn() const;
  void clear_turn();
  static const int kTurnFieldNumber = 90;
  ::google::protobuf::uint32 turn() const;
  void set_turn(::google::protobuf::uint32 value);

  // optional double vel = 100;
  bool has_vel() const;
  void clear_vel();
  static const int kVelFieldNumber = 100;
  double vel() const;
  void set_vel(double value);

  // optional double ini_maxvel = 110;
  bool has_ini_maxvel() const;
  void clear_ini_maxvel();
  static const int kIniMaxvelFieldNumber = 110;
  double ini_maxvel() const;
  void set_ini_maxvel(double value);

  // optional double spindlesync = 130;
  bool has_spindlesync() const;
  void clear_spindlesync();
  static const int kSpindlesyncFieldNumber = 130;
  double spindlesync() const;
  void set_spindlesync(double value);

  // optional double acc = 140;
  bool has_acc() const;
  void clear_acc();
  static const int kAccFieldNumber = 140;
  double acc() const;
  void set_acc(double value);

  // optional .machinetalk.MotionType motion_type = 120;
  bool has_motion_type() const;
  void clear_motion_type();
  static const int kMotionTypeFieldNumber = 120;
  ::machinetalk::MotionType motion_type() const;
  void set_motion_type(::machinetalk::MotionType value);

  // optional fixed32 id = 160;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 160;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional double backlash = 150;
  bool has_backlash() const;
  void clear_backlash();
  static const int kBacklashFieldNumber = 150;
  double backlash() const;
  void set_backlash(double value);

  // optional double tolerance = 180;
  bool has_tolerance() const;
  void clear_tolerance();
  static const int kToleranceFieldNumber = 180;
  double tolerance() const;
  void set_tolerance(double value);

  // optional fixed32 termCond = 170;
  bool has_termcond() const;
  void clear_termcond();
  static const int kTermCondFieldNumber = 170;
  ::google::protobuf::uint32 termcond() const;
  void set_termcond(::google::protobuf::uint32 value);

  // optional fixed32 axis = 190;
  bool has_axis() const;
  void clear_axis();
  static const int kAxisFieldNumber = 190;
  ::google::protobuf::uint32 axis() const;
  void set_axis(::google::protobuf::uint32 value);

  // optional double scale = 200;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 200;
  double scale() const;
  void set_scale(double value);

  // optional double offset = 210;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 210;
  double offset() const;
  void set_offset(double value);

  // optional double home = 220;
  bool has_home() const;
  void clear_home();
  static const int kHomeFieldNumber = 220;
  double home() const;
  void set_home(double value);

  // optional double home_final_vel = 230;
  bool has_home_final_vel() const;
  void clear_home_final_vel();
  static const int kHomeFinalVelFieldNumber = 230;
  double home_final_vel() const;
  void set_home_final_vel(double value);

  // optional double search_vel = 240;
  bool has_search_vel() const;
  void clear_search_vel();
  static const int kSearchVelFieldNumber = 240;
  double search_vel() const;
  void set_search_vel(double value);

  // optional double latch_vel = 250;
  bool has_latch_vel() const;
  void clear_latch_vel();
  static const int kLatchVelFieldNumber = 250;
  double latch_vel() const;
  void set_latch_vel(double value);

  // optional fixed32 flags = 260;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 260;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // optional fixed32 home_sequence = 270;
  bool has_home_sequence() const;
  void clear_home_sequence();
  static const int kHomeSequenceFieldNumber = 270;
  ::google::protobuf::uint32 home_sequence() const;
  void set_home_sequence(::google::protobuf::uint32 value);

  // optional double minFerror = 290;
  bool has_minferror() const;
  void clear_minferror();
  static const int kMinFerrorFieldNumber = 290;
  double minferror() const;
  void set_minferror(double value);

  // optional fixed32 volatile_home = 280;
  bool has_volatile_home() const;
  void clear_volatile_home();
  static const int kVolatileHomeFieldNumber = 280;
  ::google::protobuf::uint32 volatile_home() const;
  void set_volatile_home(::google::protobuf::uint32 value);

  // optional fixed32 wdWait = 310;
  bool has_wdwait() const;
  void clear_wdwait();
  static const int kWdWaitFieldNumber = 310;
  ::google::protobuf::uint32 wdwait() const;
  void set_wdwait(::google::protobuf::uint32 value);

  // optional double maxFerror = 300;
  bool has_maxferror() const;
  void clear_maxferror();
  static const int kMaxFerrorFieldNumber = 300;
  double maxferror() const;
  void set_maxferror(double value);

  // optional fixed32 debug = 320;
  bool has_debug() const;
  void clear_debug();
  static const int kDebugFieldNumber = 320;
  ::google::protobuf::uint32 debug() const;
  void set_debug(::google::protobuf::uint32 value);

  // optional int32 now = 330;
  bool has_now() const;
  void clear_now();
  static const int kNowFieldNumber = 330;
  ::google::protobuf::int32 now() const;
  void set_now(::google::protobuf::int32 value);

  // optional int32 out = 340;
  bool has_out() const;
  void clear_out();
  static const int kOutFieldNumber = 340;
  ::google::protobuf::int32 out() const;
  void set_out(::google::protobuf::int32 value);

  // optional int32 start = 350;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 350;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // optional int32 end = 360;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 360;
  ::google::protobuf::int32 end() const;
  void set_end(::google::protobuf::int32 value);

  // optional int32 mode = 370;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 370;
  ::google::protobuf::int32 mode() const;
  void set_mode(::google::protobuf::int32 value);

  // optional double comp_nominal = 380;
  bool has_comp_nominal() const;
  void clear_comp_nominal();
  static const int kCompNominalFieldNumber = 380;
  double comp_nominal() const;
  void set_comp_nominal(double value);

  // optional double comp_forward = 390;
  bool has_comp_forward() const;
  void clear_comp_forward();
  static const int kCompForwardFieldNumber = 390;
  double comp_forward() const;
  void set_comp_forward(double value);

  // optional double comp_reverse = 400;
  bool has_comp_reverse() const;
  void clear_comp_reverse();
  static const int kCompReverseFieldNumber = 400;
  double comp_reverse() const;
  void set_comp_reverse(double value);

  // required .machinetalk.cmd_code_t command = 10;
  bool has_command() const;
  void clear_command();
  static const int kCommandFieldNumber = 10;
  ::machinetalk::cmd_code_t command() const;
  void set_command(::machinetalk::cmd_code_t value);

  // @@protoc_insertion_point(class_scope:machinetalk.MotionCommand)
 private:
  void set_has_command();
  void clear_has_command();
  void set_has_commandnum();
  void clear_has_commandnum();
  void set_has_motor_offset();
  void clear_has_motor_offset();
  void set_has_maxlimit();
  void clear_has_maxlimit();
  void set_has_minlimit();
  void clear_has_minlimit();
  void set_has_pos();
  void clear_has_pos();
  void set_has_center();
  void clear_has_center();
  void set_has_normal();
  void clear_has_normal();
  void set_has_turn();
  void clear_has_turn();
  void set_has_vel();
  void clear_has_vel();
  void set_has_ini_maxvel();
  void clear_has_ini_maxvel();
  void set_has_motion_type();
  void clear_has_motion_type();
  void set_has_spindlesync();
  void clear_has_spindlesync();
  void set_has_acc();
  void clear_has_acc();
  void set_has_backlash();
  void clear_has_backlash();
  void set_has_id();
  void clear_has_id();
  void set_has_termcond();
  void clear_has_termcond();
  void set_has_tolerance();
  void clear_has_tolerance();
  void set_has_axis();
  void clear_has_axis();
  void set_has_scale();
  void clear_has_scale();
  void set_has_offset();
  void clear_has_offset();
  void set_has_home();
  void clear_has_home();
  void set_has_home_final_vel();
  void clear_has_home_final_vel();
  void set_has_search_vel();
  void clear_has_search_vel();
  void set_has_latch_vel();
  void clear_has_latch_vel();
  void set_has_flags();
  void clear_has_flags();
  void set_has_home_sequence();
  void clear_has_home_sequence();
  void set_has_volatile_home();
  void clear_has_volatile_home();
  void set_has_minferror();
  void clear_has_minferror();
  void set_has_maxferror();
  void clear_has_maxferror();
  void set_has_wdwait();
  void clear_has_wdwait();
  void set_has_debug();
  void clear_has_debug();
  void set_has_now();
  void clear_has_now();
  void set_has_out();
  void clear_has_out();
  void set_has_start();
  void clear_has_start();
  void set_has_end();
  void clear_has_end();
  void set_has_mode();
  void clear_has_mode();
  void set_has_comp_nominal();
  void clear_has_comp_nominal();
  void set_has_comp_forward();
  void clear_has_comp_forward();
  void set_has_comp_reverse();
  void clear_has_comp_reverse();
  void set_has_probe_type();
  void clear_has_probe_type();
  void set_has_tool_offset();
  void clear_has_tool_offset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  ::machinetalk::EmcPose* pos_;
  ::machinetalk::PmCartesian* center_;
  ::machinetalk::PmCartesian* normal_;
  ::machinetalk::EmcPose* tool_offset_;
  double motor_offset_;
  double maxlimit_;
  ::google::protobuf::int32 probe_type_;
  double minlimit_;
  ::google::protobuf::uint32 commandnum_;
  ::google::protobuf::uint32 turn_;
  double vel_;
  double ini_maxvel_;
  double spindlesync_;
  double acc_;
  int motion_type_;
  ::google::protobuf::uint32 id_;
  double backlash_;
  double tolerance_;
  ::google::protobuf::uint32 termcond_;
  ::google::protobuf::uint32 axis_;
  double scale_;
  double offset_;
  double home_;
  double home_final_vel_;
  double search_vel_;
  double latch_vel_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::uint32 home_sequence_;
  double minferror_;
  ::google::protobuf::uint32 volatile_home_;
  ::google::protobuf::uint32 wdwait_;
  double maxferror_;
  ::google::protobuf::uint32 debug_;
  ::google::protobuf::int32 now_;
  ::google::protobuf::int32 out_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 end_;
  ::google::protobuf::int32 mode_;
  double comp_nominal_;
  double comp_forward_;
  double comp_reverse_;
  int command_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fmotcmds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MotionStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.MotionStatus) */ {
 public:
  MotionStatus();
  virtual ~MotionStatus();

  MotionStatus(const MotionStatus& from);

  inline MotionStatus& operator=(const MotionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MotionStatus(MotionStatus&& from) noexcept
    : MotionStatus() {
    *this = ::std::move(from);
  }

  inline MotionStatus& operator=(MotionStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MotionStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MotionStatus* internal_default_instance() {
    return reinterpret_cast<const MotionStatus*>(
               &_MotionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(MotionStatus* other);
  friend void swap(MotionStatus& a, MotionStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MotionStatus* New() const final {
    return CreateMaybeMessage<MotionStatus>(NULL);
  }

  MotionStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MotionStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MotionStatus& from);
  void MergeFrom(const MotionStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotionStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .machinetalk.EmcPose carte_pos_fb = 40;
  bool has_carte_pos_fb() const;
  void clear_carte_pos_fb();
  static const int kCartePosFbFieldNumber = 40;
  private:
  const ::machinetalk::EmcPose& _internal_carte_pos_fb() const;
  public:
  const ::machinetalk::EmcPose& carte_pos_fb() const;
  ::machinetalk::EmcPose* release_carte_pos_fb();
  ::machinetalk::EmcPose* mutable_carte_pos_fb();
  void set_allocated_carte_pos_fb(::machinetalk::EmcPose* carte_pos_fb);

  // required fixed32 commandNumEcho = 20;
  bool has_commandnumecho() const;
  void clear_commandnumecho();
  static const int kCommandNumEchoFieldNumber = 20;
  ::google::protobuf::uint32 commandnumecho() const;
  void set_commandnumecho(::google::protobuf::uint32 value);

  // required .machinetalk.cmd_status_t commandStatus = 30;
  bool has_commandstatus() const;
  void clear_commandstatus();
  static const int kCommandStatusFieldNumber = 30;
  ::machinetalk::cmd_status_t commandstatus() const;
  void set_commandstatus(::machinetalk::cmd_status_t value);

  // required .machinetalk.cmd_code_t commandEcho = 10;
  bool has_commandecho() const;
  void clear_commandecho();
  static const int kCommandEchoFieldNumber = 10;
  ::machinetalk::cmd_code_t commandecho() const;
  void set_commandecho(::machinetalk::cmd_code_t value);

  // @@protoc_insertion_point(class_scope:machinetalk.MotionStatus)
 private:
  void set_has_commandecho();
  void clear_has_commandecho();
  void set_has_commandnumecho();
  void clear_has_commandnumecho();
  void set_has_commandstatus();
  void clear_has_commandstatus();
  void set_has_carte_pos_fb();
  void clear_has_carte_pos_fb();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::machinetalk::EmcPose* carte_pos_fb_;
  ::google::protobuf::uint32 commandnumecho_;
  int commandstatus_;
  int commandecho_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fmotcmds_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MotionCommand

// required .machinetalk.cmd_code_t command = 10;
inline bool MotionCommand::has_command() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void MotionCommand::set_has_command() {
  _has_bits_[1] |= 0x00000200u;
}
inline void MotionCommand::clear_has_command() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void MotionCommand::clear_command() {
  command_ = 4000;
  clear_has_command();
}
inline ::machinetalk::cmd_code_t MotionCommand::command() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.command)
  return static_cast< ::machinetalk::cmd_code_t >(command_);
}
inline void MotionCommand::set_command(::machinetalk::cmd_code_t value) {
  assert(::machinetalk::cmd_code_t_IsValid(value));
  set_has_command();
  command_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.command)
}

// required fixed32 commandNum = 20;
inline bool MotionCommand::has_commandnum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MotionCommand::set_has_commandnum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MotionCommand::clear_has_commandnum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MotionCommand::clear_commandnum() {
  commandnum_ = 0u;
  clear_has_commandnum();
}
inline ::google::protobuf::uint32 MotionCommand::commandnum() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.commandNum)
  return commandnum_;
}
inline void MotionCommand::set_commandnum(::google::protobuf::uint32 value) {
  set_has_commandnum();
  commandnum_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.commandNum)
}

// optional double motor_offset = 30;
inline bool MotionCommand::has_motor_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MotionCommand::set_has_motor_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MotionCommand::clear_has_motor_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MotionCommand::clear_motor_offset() {
  motor_offset_ = 0;
  clear_has_motor_offset();
}
inline double MotionCommand::motor_offset() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.motor_offset)
  return motor_offset_;
}
inline void MotionCommand::set_motor_offset(double value) {
  set_has_motor_offset();
  motor_offset_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.motor_offset)
}

// optional double maxLimit = 40;
inline bool MotionCommand::has_maxlimit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MotionCommand::set_has_maxlimit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MotionCommand::clear_has_maxlimit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MotionCommand::clear_maxlimit() {
  maxlimit_ = 0;
  clear_has_maxlimit();
}
inline double MotionCommand::maxlimit() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.maxLimit)
  return maxlimit_;
}
inline void MotionCommand::set_maxlimit(double value) {
  set_has_maxlimit();
  maxlimit_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.maxLimit)
}

// optional double minLimit = 50;
inline bool MotionCommand::has_minlimit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MotionCommand::set_has_minlimit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MotionCommand::clear_has_minlimit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MotionCommand::clear_minlimit() {
  minlimit_ = 0;
  clear_has_minlimit();
}
inline double MotionCommand::minlimit() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.minLimit)
  return minlimit_;
}
inline void MotionCommand::set_minlimit(double value) {
  set_has_minlimit();
  minlimit_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.minLimit)
}

// optional .machinetalk.EmcPose pos = 60;
inline bool MotionCommand::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MotionCommand::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MotionCommand::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::machinetalk::EmcPose& MotionCommand::_internal_pos() const {
  return *pos_;
}
inline const ::machinetalk::EmcPose& MotionCommand::pos() const {
  const ::machinetalk::EmcPose* p = pos_;
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcPose*>(
      &::machinetalk::_EmcPose_default_instance_);
}
inline ::machinetalk::EmcPose* MotionCommand::release_pos() {
  // @@protoc_insertion_point(field_release:machinetalk.MotionCommand.pos)
  clear_has_pos();
  ::machinetalk::EmcPose* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline ::machinetalk::EmcPose* MotionCommand::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcPose>(GetArenaNoVirtual());
    pos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.MotionCommand.pos)
  return pos_;
}
inline void MotionCommand::set_allocated_pos(::machinetalk::EmcPose* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pos_);
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    set_has_pos();
  } else {
    clear_has_pos();
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.MotionCommand.pos)
}

// optional .machinetalk.PmCartesian center = 70;
inline bool MotionCommand::has_center() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MotionCommand::set_has_center() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MotionCommand::clear_has_center() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::machinetalk::PmCartesian& MotionCommand::_internal_center() const {
  return *center_;
}
inline const ::machinetalk::PmCartesian& MotionCommand::center() const {
  const ::machinetalk::PmCartesian* p = center_;
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.center)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::PmCartesian*>(
      &::machinetalk::_PmCartesian_default_instance_);
}
inline ::machinetalk::PmCartesian* MotionCommand::release_center() {
  // @@protoc_insertion_point(field_release:machinetalk.MotionCommand.center)
  clear_has_center();
  ::machinetalk::PmCartesian* temp = center_;
  center_ = NULL;
  return temp;
}
inline ::machinetalk::PmCartesian* MotionCommand::mutable_center() {
  set_has_center();
  if (center_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::PmCartesian>(GetArenaNoVirtual());
    center_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.MotionCommand.center)
  return center_;
}
inline void MotionCommand::set_allocated_center(::machinetalk::PmCartesian* center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(center_);
  }
  if (center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    set_has_center();
  } else {
    clear_has_center();
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.MotionCommand.center)
}

// optional .machinetalk.PmCartesian normal = 80;
inline bool MotionCommand::has_normal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MotionCommand::set_has_normal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MotionCommand::clear_has_normal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::machinetalk::PmCartesian& MotionCommand::_internal_normal() const {
  return *normal_;
}
inline const ::machinetalk::PmCartesian& MotionCommand::normal() const {
  const ::machinetalk::PmCartesian* p = normal_;
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.normal)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::PmCartesian*>(
      &::machinetalk::_PmCartesian_default_instance_);
}
inline ::machinetalk::PmCartesian* MotionCommand::release_normal() {
  // @@protoc_insertion_point(field_release:machinetalk.MotionCommand.normal)
  clear_has_normal();
  ::machinetalk::PmCartesian* temp = normal_;
  normal_ = NULL;
  return temp;
}
inline ::machinetalk::PmCartesian* MotionCommand::mutable_normal() {
  set_has_normal();
  if (normal_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::PmCartesian>(GetArenaNoVirtual());
    normal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.MotionCommand.normal)
  return normal_;
}
inline void MotionCommand::set_allocated_normal(::machinetalk::PmCartesian* normal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(normal_);
  }
  if (normal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      normal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, normal, submessage_arena);
    }
    set_has_normal();
  } else {
    clear_has_normal();
  }
  normal_ = normal;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.MotionCommand.normal)
}

// optional fixed32 turn = 90;
inline bool MotionCommand::has_turn() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MotionCommand::set_has_turn() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MotionCommand::clear_has_turn() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MotionCommand::clear_turn() {
  turn_ = 0u;
  clear_has_turn();
}
inline ::google::protobuf::uint32 MotionCommand::turn() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.turn)
  return turn_;
}
inline void MotionCommand::set_turn(::google::protobuf::uint32 value) {
  set_has_turn();
  turn_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.turn)
}

// optional double vel = 100;
inline bool MotionCommand::has_vel() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MotionCommand::set_has_vel() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MotionCommand::clear_has_vel() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MotionCommand::clear_vel() {
  vel_ = 0;
  clear_has_vel();
}
inline double MotionCommand::vel() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.vel)
  return vel_;
}
inline void MotionCommand::set_vel(double value) {
  set_has_vel();
  vel_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.vel)
}

// optional double ini_maxvel = 110;
inline bool MotionCommand::has_ini_maxvel() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MotionCommand::set_has_ini_maxvel() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MotionCommand::clear_has_ini_maxvel() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MotionCommand::clear_ini_maxvel() {
  ini_maxvel_ = 0;
  clear_has_ini_maxvel();
}
inline double MotionCommand::ini_maxvel() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.ini_maxvel)
  return ini_maxvel_;
}
inline void MotionCommand::set_ini_maxvel(double value) {
  set_has_ini_maxvel();
  ini_maxvel_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.ini_maxvel)
}

// optional .machinetalk.MotionType motion_type = 120;
inline bool MotionCommand::has_motion_type() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MotionCommand::set_has_motion_type() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MotionCommand::clear_has_motion_type() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MotionCommand::clear_motion_type() {
  motion_type_ = 0;
  clear_has_motion_type();
}
inline ::machinetalk::MotionType MotionCommand::motion_type() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.motion_type)
  return static_cast< ::machinetalk::MotionType >(motion_type_);
}
inline void MotionCommand::set_motion_type(::machinetalk::MotionType value) {
  assert(::machinetalk::MotionType_IsValid(value));
  set_has_motion_type();
  motion_type_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.motion_type)
}

// optional double spindlesync = 130;
inline bool MotionCommand::has_spindlesync() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MotionCommand::set_has_spindlesync() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MotionCommand::clear_has_spindlesync() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MotionCommand::clear_spindlesync() {
  spindlesync_ = 0;
  clear_has_spindlesync();
}
inline double MotionCommand::spindlesync() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.spindlesync)
  return spindlesync_;
}
inline void MotionCommand::set_spindlesync(double value) {
  set_has_spindlesync();
  spindlesync_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.spindlesync)
}

// optional double acc = 140;
inline bool MotionCommand::has_acc() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MotionCommand::set_has_acc() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MotionCommand::clear_has_acc() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MotionCommand::clear_acc() {
  acc_ = 0;
  clear_has_acc();
}
inline double MotionCommand::acc() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.acc)
  return acc_;
}
inline void MotionCommand::set_acc(double value) {
  set_has_acc();
  acc_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.acc)
}

// optional double backlash = 150;
inline bool MotionCommand::has_backlash() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MotionCommand::set_has_backlash() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MotionCommand::clear_has_backlash() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MotionCommand::clear_backlash() {
  backlash_ = 0;
  clear_has_backlash();
}
inline double MotionCommand::backlash() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.backlash)
  return backlash_;
}
inline void MotionCommand::set_backlash(double value) {
  set_has_backlash();
  backlash_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.backlash)
}

// optional fixed32 id = 160;
inline bool MotionCommand::has_id() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MotionCommand::set_has_id() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MotionCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MotionCommand::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MotionCommand::id() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.id)
  return id_;
}
inline void MotionCommand::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.id)
}

// optional fixed32 termCond = 170;
inline bool MotionCommand::has_termcond() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MotionCommand::set_has_termcond() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MotionCommand::clear_has_termcond() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MotionCommand::clear_termcond() {
  termcond_ = 0u;
  clear_has_termcond();
}
inline ::google::protobuf::uint32 MotionCommand::termcond() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.termCond)
  return termcond_;
}
inline void MotionCommand::set_termcond(::google::protobuf::uint32 value) {
  set_has_termcond();
  termcond_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.termCond)
}

// optional double tolerance = 180;
inline bool MotionCommand::has_tolerance() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MotionCommand::set_has_tolerance() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MotionCommand::clear_has_tolerance() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MotionCommand::clear_tolerance() {
  tolerance_ = 0;
  clear_has_tolerance();
}
inline double MotionCommand::tolerance() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.tolerance)
  return tolerance_;
}
inline void MotionCommand::set_tolerance(double value) {
  set_has_tolerance();
  tolerance_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.tolerance)
}

// optional fixed32 axis = 190;
inline bool MotionCommand::has_axis() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MotionCommand::set_has_axis() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MotionCommand::clear_has_axis() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MotionCommand::clear_axis() {
  axis_ = 0u;
  clear_has_axis();
}
inline ::google::protobuf::uint32 MotionCommand::axis() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.axis)
  return axis_;
}
inline void MotionCommand::set_axis(::google::protobuf::uint32 value) {
  set_has_axis();
  axis_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.axis)
}

// optional double scale = 200;
inline bool MotionCommand::has_scale() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MotionCommand::set_has_scale() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MotionCommand::clear_has_scale() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MotionCommand::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline double MotionCommand::scale() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.scale)
  return scale_;
}
inline void MotionCommand::set_scale(double value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.scale)
}

// optional double offset = 210;
inline bool MotionCommand::has_offset() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MotionCommand::set_has_offset() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MotionCommand::clear_has_offset() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MotionCommand::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline double MotionCommand::offset() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.offset)
  return offset_;
}
inline void MotionCommand::set_offset(double value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.offset)
}

// optional double home = 220;
inline bool MotionCommand::has_home() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MotionCommand::set_has_home() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MotionCommand::clear_has_home() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MotionCommand::clear_home() {
  home_ = 0;
  clear_has_home();
}
inline double MotionCommand::home() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.home)
  return home_;
}
inline void MotionCommand::set_home(double value) {
  set_has_home();
  home_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.home)
}

// optional double home_final_vel = 230;
inline bool MotionCommand::has_home_final_vel() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MotionCommand::set_has_home_final_vel() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MotionCommand::clear_has_home_final_vel() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MotionCommand::clear_home_final_vel() {
  home_final_vel_ = 0;
  clear_has_home_final_vel();
}
inline double MotionCommand::home_final_vel() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.home_final_vel)
  return home_final_vel_;
}
inline void MotionCommand::set_home_final_vel(double value) {
  set_has_home_final_vel();
  home_final_vel_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.home_final_vel)
}

// optional double search_vel = 240;
inline bool MotionCommand::has_search_vel() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MotionCommand::set_has_search_vel() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MotionCommand::clear_has_search_vel() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MotionCommand::clear_search_vel() {
  search_vel_ = 0;
  clear_has_search_vel();
}
inline double MotionCommand::search_vel() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.search_vel)
  return search_vel_;
}
inline void MotionCommand::set_search_vel(double value) {
  set_has_search_vel();
  search_vel_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.search_vel)
}

// optional double latch_vel = 250;
inline bool MotionCommand::has_latch_vel() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MotionCommand::set_has_latch_vel() {
  _has_bits_[0] |= 0x02000000u;
}
inline void MotionCommand::clear_has_latch_vel() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void MotionCommand::clear_latch_vel() {
  latch_vel_ = 0;
  clear_has_latch_vel();
}
inline double MotionCommand::latch_vel() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.latch_vel)
  return latch_vel_;
}
inline void MotionCommand::set_latch_vel(double value) {
  set_has_latch_vel();
  latch_vel_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.latch_vel)
}

// optional fixed32 flags = 260;
inline bool MotionCommand::has_flags() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void MotionCommand::set_has_flags() {
  _has_bits_[0] |= 0x04000000u;
}
inline void MotionCommand::clear_has_flags() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void MotionCommand::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 MotionCommand::flags() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.flags)
  return flags_;
}
inline void MotionCommand::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.flags)
}

// optional fixed32 home_sequence = 270;
inline bool MotionCommand::has_home_sequence() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void MotionCommand::set_has_home_sequence() {
  _has_bits_[0] |= 0x08000000u;
}
inline void MotionCommand::clear_has_home_sequence() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void MotionCommand::clear_home_sequence() {
  home_sequence_ = 0u;
  clear_has_home_sequence();
}
inline ::google::protobuf::uint32 MotionCommand::home_sequence() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.home_sequence)
  return home_sequence_;
}
inline void MotionCommand::set_home_sequence(::google::protobuf::uint32 value) {
  set_has_home_sequence();
  home_sequence_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.home_sequence)
}

// optional fixed32 volatile_home = 280;
inline bool MotionCommand::has_volatile_home() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void MotionCommand::set_has_volatile_home() {
  _has_bits_[0] |= 0x20000000u;
}
inline void MotionCommand::clear_has_volatile_home() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void MotionCommand::clear_volatile_home() {
  volatile_home_ = 0u;
  clear_has_volatile_home();
}
inline ::google::protobuf::uint32 MotionCommand::volatile_home() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.volatile_home)
  return volatile_home_;
}
inline void MotionCommand::set_volatile_home(::google::protobuf::uint32 value) {
  set_has_volatile_home();
  volatile_home_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.volatile_home)
}

// optional double minFerror = 290;
inline bool MotionCommand::has_minferror() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void MotionCommand::set_has_minferror() {
  _has_bits_[0] |= 0x10000000u;
}
inline void MotionCommand::clear_has_minferror() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void MotionCommand::clear_minferror() {
  minferror_ = 0;
  clear_has_minferror();
}
inline double MotionCommand::minferror() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.minFerror)
  return minferror_;
}
inline void MotionCommand::set_minferror(double value) {
  set_has_minferror();
  minferror_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.minFerror)
}

// optional double maxFerror = 300;
inline bool MotionCommand::has_maxferror() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void MotionCommand::set_has_maxferror() {
  _has_bits_[0] |= 0x80000000u;
}
inline void MotionCommand::clear_has_maxferror() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void MotionCommand::clear_maxferror() {
  maxferror_ = 0;
  clear_has_maxferror();
}
inline double MotionCommand::maxferror() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.maxFerror)
  return maxferror_;
}
inline void MotionCommand::set_maxferror(double value) {
  set_has_maxferror();
  maxferror_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.maxFerror)
}

// optional fixed32 wdWait = 310;
inline bool MotionCommand::has_wdwait() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void MotionCommand::set_has_wdwait() {
  _has_bits_[0] |= 0x40000000u;
}
inline void MotionCommand::clear_has_wdwait() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void MotionCommand::clear_wdwait() {
  wdwait_ = 0u;
  clear_has_wdwait();
}
inline ::google::protobuf::uint32 MotionCommand::wdwait() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.wdWait)
  return wdwait_;
}
inline void MotionCommand::set_wdwait(::google::protobuf::uint32 value) {
  set_has_wdwait();
  wdwait_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.wdWait)
}

// optional fixed32 debug = 320;
inline bool MotionCommand::has_debug() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void MotionCommand::set_has_debug() {
  _has_bits_[1] |= 0x00000001u;
}
inline void MotionCommand::clear_has_debug() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void MotionCommand::clear_debug() {
  debug_ = 0u;
  clear_has_debug();
}
inline ::google::protobuf::uint32 MotionCommand::debug() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.debug)
  return debug_;
}
inline void MotionCommand::set_debug(::google::protobuf::uint32 value) {
  set_has_debug();
  debug_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.debug)
}

// optional int32 now = 330;
inline bool MotionCommand::has_now() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void MotionCommand::set_has_now() {
  _has_bits_[1] |= 0x00000002u;
}
inline void MotionCommand::clear_has_now() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void MotionCommand::clear_now() {
  now_ = 0;
  clear_has_now();
}
inline ::google::protobuf::int32 MotionCommand::now() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.now)
  return now_;
}
inline void MotionCommand::set_now(::google::protobuf::int32 value) {
  set_has_now();
  now_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.now)
}

// optional int32 out = 340;
inline bool MotionCommand::has_out() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void MotionCommand::set_has_out() {
  _has_bits_[1] |= 0x00000004u;
}
inline void MotionCommand::clear_has_out() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void MotionCommand::clear_out() {
  out_ = 0;
  clear_has_out();
}
inline ::google::protobuf::int32 MotionCommand::out() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.out)
  return out_;
}
inline void MotionCommand::set_out(::google::protobuf::int32 value) {
  set_has_out();
  out_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.out)
}

// optional int32 start = 350;
inline bool MotionCommand::has_start() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void MotionCommand::set_has_start() {
  _has_bits_[1] |= 0x00000008u;
}
inline void MotionCommand::clear_has_start() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void MotionCommand::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline ::google::protobuf::int32 MotionCommand::start() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.start)
  return start_;
}
inline void MotionCommand::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.start)
}

// optional int32 end = 360;
inline bool MotionCommand::has_end() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void MotionCommand::set_has_end() {
  _has_bits_[1] |= 0x00000010u;
}
inline void MotionCommand::clear_has_end() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void MotionCommand::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 MotionCommand::end() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.end)
  return end_;
}
inline void MotionCommand::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.end)
}

// optional int32 mode = 370;
inline bool MotionCommand::has_mode() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void MotionCommand::set_has_mode() {
  _has_bits_[1] |= 0x00000020u;
}
inline void MotionCommand::clear_has_mode() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void MotionCommand::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::google::protobuf::int32 MotionCommand::mode() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.mode)
  return mode_;
}
inline void MotionCommand::set_mode(::google::protobuf::int32 value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.mode)
}

// optional double comp_nominal = 380;
inline bool MotionCommand::has_comp_nominal() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void MotionCommand::set_has_comp_nominal() {
  _has_bits_[1] |= 0x00000040u;
}
inline void MotionCommand::clear_has_comp_nominal() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void MotionCommand::clear_comp_nominal() {
  comp_nominal_ = 0;
  clear_has_comp_nominal();
}
inline double MotionCommand::comp_nominal() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.comp_nominal)
  return comp_nominal_;
}
inline void MotionCommand::set_comp_nominal(double value) {
  set_has_comp_nominal();
  comp_nominal_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.comp_nominal)
}

// optional double comp_forward = 390;
inline bool MotionCommand::has_comp_forward() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void MotionCommand::set_has_comp_forward() {
  _has_bits_[1] |= 0x00000080u;
}
inline void MotionCommand::clear_has_comp_forward() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void MotionCommand::clear_comp_forward() {
  comp_forward_ = 0;
  clear_has_comp_forward();
}
inline double MotionCommand::comp_forward() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.comp_forward)
  return comp_forward_;
}
inline void MotionCommand::set_comp_forward(double value) {
  set_has_comp_forward();
  comp_forward_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.comp_forward)
}

// optional double comp_reverse = 400;
inline bool MotionCommand::has_comp_reverse() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void MotionCommand::set_has_comp_reverse() {
  _has_bits_[1] |= 0x00000100u;
}
inline void MotionCommand::clear_has_comp_reverse() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void MotionCommand::clear_comp_reverse() {
  comp_reverse_ = 0;
  clear_has_comp_reverse();
}
inline double MotionCommand::comp_reverse() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.comp_reverse)
  return comp_reverse_;
}
inline void MotionCommand::set_comp_reverse(double value) {
  set_has_comp_reverse();
  comp_reverse_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.comp_reverse)
}

// optional int32 probe_type = 410;
inline bool MotionCommand::has_probe_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MotionCommand::set_has_probe_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MotionCommand::clear_has_probe_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MotionCommand::clear_probe_type() {
  probe_type_ = 0;
  clear_has_probe_type();
}
inline ::google::protobuf::int32 MotionCommand::probe_type() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.probe_type)
  return probe_type_;
}
inline void MotionCommand::set_probe_type(::google::protobuf::int32 value) {
  set_has_probe_type();
  probe_type_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionCommand.probe_type)
}

// optional .machinetalk.EmcPose tool_offset = 420;
inline bool MotionCommand::has_tool_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MotionCommand::set_has_tool_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MotionCommand::clear_has_tool_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::machinetalk::EmcPose& MotionCommand::_internal_tool_offset() const {
  return *tool_offset_;
}
inline const ::machinetalk::EmcPose& MotionCommand::tool_offset() const {
  const ::machinetalk::EmcPose* p = tool_offset_;
  // @@protoc_insertion_point(field_get:machinetalk.MotionCommand.tool_offset)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcPose*>(
      &::machinetalk::_EmcPose_default_instance_);
}
inline ::machinetalk::EmcPose* MotionCommand::release_tool_offset() {
  // @@protoc_insertion_point(field_release:machinetalk.MotionCommand.tool_offset)
  clear_has_tool_offset();
  ::machinetalk::EmcPose* temp = tool_offset_;
  tool_offset_ = NULL;
  return temp;
}
inline ::machinetalk::EmcPose* MotionCommand::mutable_tool_offset() {
  set_has_tool_offset();
  if (tool_offset_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcPose>(GetArenaNoVirtual());
    tool_offset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.MotionCommand.tool_offset)
  return tool_offset_;
}
inline void MotionCommand::set_allocated_tool_offset(::machinetalk::EmcPose* tool_offset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tool_offset_);
  }
  if (tool_offset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tool_offset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tool_offset, submessage_arena);
    }
    set_has_tool_offset();
  } else {
    clear_has_tool_offset();
  }
  tool_offset_ = tool_offset;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.MotionCommand.tool_offset)
}

// -------------------------------------------------------------------

// MotionStatus

// required .machinetalk.cmd_code_t commandEcho = 10;
inline bool MotionStatus::has_commandecho() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MotionStatus::set_has_commandecho() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MotionStatus::clear_has_commandecho() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MotionStatus::clear_commandecho() {
  commandecho_ = 4000;
  clear_has_commandecho();
}
inline ::machinetalk::cmd_code_t MotionStatus::commandecho() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionStatus.commandEcho)
  return static_cast< ::machinetalk::cmd_code_t >(commandecho_);
}
inline void MotionStatus::set_commandecho(::machinetalk::cmd_code_t value) {
  assert(::machinetalk::cmd_code_t_IsValid(value));
  set_has_commandecho();
  commandecho_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionStatus.commandEcho)
}

// required fixed32 commandNumEcho = 20;
inline bool MotionStatus::has_commandnumecho() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MotionStatus::set_has_commandnumecho() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MotionStatus::clear_has_commandnumecho() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MotionStatus::clear_commandnumecho() {
  commandnumecho_ = 0u;
  clear_has_commandnumecho();
}
inline ::google::protobuf::uint32 MotionStatus::commandnumecho() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionStatus.commandNumEcho)
  return commandnumecho_;
}
inline void MotionStatus::set_commandnumecho(::google::protobuf::uint32 value) {
  set_has_commandnumecho();
  commandnumecho_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionStatus.commandNumEcho)
}

// required .machinetalk.cmd_status_t commandStatus = 30;
inline bool MotionStatus::has_commandstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MotionStatus::set_has_commandstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MotionStatus::clear_has_commandstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MotionStatus::clear_commandstatus() {
  commandstatus_ = 0;
  clear_has_commandstatus();
}
inline ::machinetalk::cmd_status_t MotionStatus::commandstatus() const {
  // @@protoc_insertion_point(field_get:machinetalk.MotionStatus.commandStatus)
  return static_cast< ::machinetalk::cmd_status_t >(commandstatus_);
}
inline void MotionStatus::set_commandstatus(::machinetalk::cmd_status_t value) {
  assert(::machinetalk::cmd_status_t_IsValid(value));
  set_has_commandstatus();
  commandstatus_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.MotionStatus.commandStatus)
}

// optional .machinetalk.EmcPose carte_pos_fb = 40;
inline bool MotionStatus::has_carte_pos_fb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MotionStatus::set_has_carte_pos_fb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MotionStatus::clear_has_carte_pos_fb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::machinetalk::EmcPose& MotionStatus::_internal_carte_pos_fb() const {
  return *carte_pos_fb_;
}
inline const ::machinetalk::EmcPose& MotionStatus::carte_pos_fb() const {
  const ::machinetalk::EmcPose* p = carte_pos_fb_;
  // @@protoc_insertion_point(field_get:machinetalk.MotionStatus.carte_pos_fb)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcPose*>(
      &::machinetalk::_EmcPose_default_instance_);
}
inline ::machinetalk::EmcPose* MotionStatus::release_carte_pos_fb() {
  // @@protoc_insertion_point(field_release:machinetalk.MotionStatus.carte_pos_fb)
  clear_has_carte_pos_fb();
  ::machinetalk::EmcPose* temp = carte_pos_fb_;
  carte_pos_fb_ = NULL;
  return temp;
}
inline ::machinetalk::EmcPose* MotionStatus::mutable_carte_pos_fb() {
  set_has_carte_pos_fb();
  if (carte_pos_fb_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcPose>(GetArenaNoVirtual());
    carte_pos_fb_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.MotionStatus.carte_pos_fb)
  return carte_pos_fb_;
}
inline void MotionStatus::set_allocated_carte_pos_fb(::machinetalk::EmcPose* carte_pos_fb) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(carte_pos_fb_);
  }
  if (carte_pos_fb) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      carte_pos_fb = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, carte_pos_fb, submessage_arena);
    }
    set_has_carte_pos_fb();
  } else {
    clear_has_carte_pos_fb();
  }
  carte_pos_fb_ = carte_pos_fb;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.MotionStatus.carte_pos_fb)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace machinetalk

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::machinetalk::MotionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::MotionType>() {
  return ::machinetalk::MotionType_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::cmd_code_t> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::cmd_code_t>() {
  return ::machinetalk::cmd_code_t_descriptor();
}
template <> struct is_proto_enum< ::machinetalk::cmd_status_t> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::machinetalk::cmd_status_t>() {
  return ::machinetalk::cmd_status_t_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_machinetalk_2fprotobuf_2fmotcmds_2eproto
