// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: machinetalk/protobuf/message.proto

#ifndef PROTOBUF_INCLUDED_machinetalk_2fprotobuf_2fmessage_2eproto
#define PROTOBUF_INCLUDED_machinetalk_2fprotobuf_2fmessage_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "machinetalk/protobuf/nanopb.pb.h"
#include "machinetalk/protobuf/types.pb.h"
#include "machinetalk/protobuf/object.pb.h"
#include "machinetalk/protobuf/log.pb.h"
#include "machinetalk/protobuf/motcmds.pb.h"
#include "machinetalk/protobuf/task.pb.h"
#include "machinetalk/protobuf/canon.pb.h"
#include "machinetalk/protobuf/value.pb.h"
#include "machinetalk/protobuf/rtapicommand.pb.h"
#include "machinetalk/protobuf/rtapi_message.pb.h"
#include "machinetalk/protobuf/config.pb.h"
#include "machinetalk/protobuf/preview.pb.h"
#include "machinetalk/protobuf/status.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_machinetalk_2fprotobuf_2fmessage_2eproto 

namespace protobuf_machinetalk_2fprotobuf_2fmessage_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[1];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_machinetalk_2fprotobuf_2fmessage_2eproto
namespace machinetalk {
class Container;
class ContainerDefaultTypeInternal;
extern ContainerDefaultTypeInternal _Container_default_instance_;
}  // namespace machinetalk
namespace google {
namespace protobuf {
template<> ::machinetalk::Container* Arena::CreateMaybeMessage<::machinetalk::Container>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace machinetalk {

// ===================================================================

class Container : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Container) */ {
 public:
  Container();
  virtual ~Container();

  Container(const Container& from);

  inline Container& operator=(const Container& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Container(Container&& from) noexcept
    : Container() {
    *this = ::std::move(from);
  }

  inline Container& operator=(Container&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Container& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Container* internal_default_instance() {
    return reinterpret_cast<const Container*>(
               &_Container_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Container* other);
  friend void swap(Container& a, Container& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Container* New() const final {
    return CreateMaybeMessage<Container>(NULL);
  }

  Container* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Container>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Container& from);
  void MergeFrom(const Container& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Container* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .machinetalk.Pin pin = 2 [(.nanopb) = {
  int pin_size() const;
  void clear_pin();
  static const int kPinFieldNumber = 2;
  ::machinetalk::Pin* mutable_pin(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Pin >*
      mutable_pin();
  const ::machinetalk::Pin& pin(int index) const;
  ::machinetalk::Pin* add_pin();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Pin >&
      pin() const;

  // repeated .machinetalk.Signal signal = 3 [(.nanopb) = {
  int signal_size() const;
  void clear_signal();
  static const int kSignalFieldNumber = 3;
  ::machinetalk::Signal* mutable_signal(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Signal >*
      mutable_signal();
  const ::machinetalk::Signal& signal(int index) const;
  ::machinetalk::Signal* add_signal();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Signal >&
      signal() const;

  // repeated .machinetalk.Preview preview = 8 [(.nanopb) = {
  int preview_size() const;
  void clear_preview();
  static const int kPreviewFieldNumber = 8;
  ::machinetalk::Preview* mutable_preview(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Preview >*
      mutable_preview();
  const ::machinetalk::Preview& preview(int index) const;
  ::machinetalk::Preview* add_preview();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Preview >&
      preview() const;

  // repeated string note = 68;
  int note_size() const;
  void clear_note();
  static const int kNoteFieldNumber = 68;
  const ::std::string& note(int index) const;
  ::std::string* mutable_note(int index);
  void set_note(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_note(int index, ::std::string&& value);
  #endif
  void set_note(int index, const char* value);
  void set_note(int index, const char* value, size_t size);
  ::std::string* add_note();
  void add_note(const ::std::string& value);
  #if LANG_CXX11
  void add_note(::std::string&& value);
  #endif
  void add_note(const char* value);
  void add_note(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& note() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_note();

  // repeated .machinetalk.Value value = 85 [(.nanopb) = {
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 85;
  ::machinetalk::Value* mutable_value(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Value >*
      mutable_value();
  const ::machinetalk::Value& value(int index) const;
  ::machinetalk::Value* add_value();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Value >&
      value() const;

  // repeated .machinetalk.ServiceAnnouncement service_announcement = 88 [(.nanopb) = {
  int service_announcement_size() const;
  void clear_service_announcement();
  static const int kServiceAnnouncementFieldNumber = 88;
  ::machinetalk::ServiceAnnouncement* mutable_service_announcement(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::ServiceAnnouncement >*
      mutable_service_announcement();
  const ::machinetalk::ServiceAnnouncement& service_announcement(int index) const;
  ::machinetalk::ServiceAnnouncement* add_service_announcement();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::ServiceAnnouncement >&
      service_announcement() const;

  // repeated .machinetalk.Component comp = 100 [(.nanopb) = {
  int comp_size() const;
  void clear_comp();
  static const int kCompFieldNumber = 100;
  ::machinetalk::Component* mutable_comp(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Component >*
      mutable_comp();
  const ::machinetalk::Component& comp(int index) const;
  ::machinetalk::Component* add_comp();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Component >&
      comp() const;

  // repeated .machinetalk.Param param = 103 [(.nanopb) = {
  int param_size() const;
  void clear_param();
  static const int kParamFieldNumber = 103;
  ::machinetalk::Param* mutable_param(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Param >*
      mutable_param();
  const ::machinetalk::Param& param(int index) const;
  ::machinetalk::Param* add_param();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Param >&
      param() const;

  // repeated .machinetalk.Thread thread = 104 [(.nanopb) = {
  int thread_size() const;
  void clear_thread();
  static const int kThreadFieldNumber = 104;
  ::machinetalk::Thread* mutable_thread(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Thread >*
      mutable_thread();
  const ::machinetalk::Thread& thread(int index) const;
  ::machinetalk::Thread* add_thread();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Thread >&
      thread() const;

  // repeated .machinetalk.Ring ring = 105 [(.nanopb) = {
  int ring_size() const;
  void clear_ring();
  static const int kRingFieldNumber = 105;
  ::machinetalk::Ring* mutable_ring(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Ring >*
      mutable_ring();
  const ::machinetalk::Ring& ring(int index) const;
  ::machinetalk::Ring* add_ring();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Ring >&
      ring() const;

  // repeated .machinetalk.Group group = 106 [(.nanopb) = {
  int group_size() const;
  void clear_group();
  static const int kGroupFieldNumber = 106;
  ::machinetalk::Group* mutable_group(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Group >*
      mutable_group();
  const ::machinetalk::Group& group(int index) const;
  ::machinetalk::Group* add_group();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Group >&
      group() const;

  // repeated .machinetalk.Member member = 107 [(.nanopb) = {
  int member_size() const;
  void clear_member();
  static const int kMemberFieldNumber = 107;
  ::machinetalk::Member* mutable_member(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Member >*
      mutable_member();
  const ::machinetalk::Member& member(int index) const;
  ::machinetalk::Member* add_member();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Member >&
      member() const;

  // repeated .machinetalk.Function function = 108 [(.nanopb) = {
  int function_size() const;
  void clear_function();
  static const int kFunctionFieldNumber = 108;
  ::machinetalk::Function* mutable_function(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Function >*
      mutable_function();
  const ::machinetalk::Function& function(int index) const;
  ::machinetalk::Function* add_function();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Function >&
      function() const;

  // repeated .machinetalk.Vtable vtable = 110 [(.nanopb) = {
  int vtable_size() const;
  void clear_vtable();
  static const int kVtableFieldNumber = 110;
  ::machinetalk::Vtable* mutable_vtable(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Vtable >*
      mutable_vtable();
  const ::machinetalk::Vtable& vtable(int index) const;
  ::machinetalk::Vtable* add_vtable();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Vtable >&
      vtable() const;

  // repeated .machinetalk.Inst inst = 111 [(.nanopb) = {
  int inst_size() const;
  void clear_inst();
  static const int kInstFieldNumber = 111;
  ::machinetalk::Inst* mutable_inst(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Inst >*
      mutable_inst();
  const ::machinetalk::Inst& inst(int index) const;
  ::machinetalk::Inst* add_inst();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Inst >&
      inst() const;

  // repeated .machinetalk.Application app = 120 [(.nanopb) = {
  int app_size() const;
  void clear_app();
  static const int kAppFieldNumber = 120;
  ::machinetalk::Application* mutable_app(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Application >*
      mutable_app();
  const ::machinetalk::Application& app(int index) const;
  ::machinetalk::Application* add_app();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Application >&
      app() const;

  // repeated .machinetalk.Launcher launcher = 130 [(.nanopb) = {
  int launcher_size() const;
  void clear_launcher();
  static const int kLauncherFieldNumber = 130;
  ::machinetalk::Launcher* mutable_launcher(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Launcher >*
      mutable_launcher();
  const ::machinetalk::Launcher& launcher(int index) const;
  ::machinetalk::Launcher* add_launcher();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Launcher >&
      launcher() const;

  // optional bytes legacy_motcmd = 11 [(.nanopb) = {
  bool has_legacy_motcmd() const;
  void clear_legacy_motcmd();
  static const int kLegacyMotcmdFieldNumber = 11;
  const ::std::string& legacy_motcmd() const;
  void set_legacy_motcmd(const ::std::string& value);
  #if LANG_CXX11
  void set_legacy_motcmd(::std::string&& value);
  #endif
  void set_legacy_motcmd(const char* value);
  void set_legacy_motcmd(const void* value, size_t size);
  ::std::string* mutable_legacy_motcmd();
  ::std::string* release_legacy_motcmd();
  void set_allocated_legacy_motcmd(::std::string* legacy_motcmd);

  // optional bytes legacy_motstat = 12 [(.nanopb) = {
  bool has_legacy_motstat() const;
  void clear_legacy_motstat();
  static const int kLegacyMotstatFieldNumber = 12;
  const ::std::string& legacy_motstat() const;
  void set_legacy_motstat(const ::std::string& value);
  #if LANG_CXX11
  void set_legacy_motstat(::std::string&& value);
  #endif
  void set_legacy_motstat(const char* value);
  void set_legacy_motstat(const void* value, size_t size);
  ::std::string* mutable_legacy_motstat();
  ::std::string* release_legacy_motstat();
  void set_allocated_legacy_motstat(::std::string* legacy_motstat);

  // optional bytes syslog = 18 [(.nanopb) = {
  bool has_syslog() const;
  void clear_syslog();
  static const int kSyslogFieldNumber = 18;
  const ::std::string& syslog() const;
  void set_syslog(const ::std::string& value);
  #if LANG_CXX11
  void set_syslog(::std::string&& value);
  #endif
  void set_syslog(const char* value);
  void set_syslog(const void* value, size_t size);
  ::std::string* mutable_syslog();
  ::std::string* release_syslog();
  void set_allocated_syslog(::std::string* syslog);

  // optional bytes legacy_nml = 19 [(.nanopb) = {
  bool has_legacy_nml() const;
  void clear_legacy_nml();
  static const int kLegacyNmlFieldNumber = 19;
  const ::std::string& legacy_nml() const;
  void set_legacy_nml(const ::std::string& value);
  #if LANG_CXX11
  void set_legacy_nml(::std::string&& value);
  #endif
  void set_legacy_nml(const char* value);
  void set_legacy_nml(const void* value, size_t size);
  ::std::string* mutable_legacy_nml();
  ::std::string* release_legacy_nml();
  void set_allocated_legacy_nml(::std::string* legacy_nml);

  // optional bytes legacy_motconfig = 20 [(.nanopb) = {
  bool has_legacy_motconfig() const;
  void clear_legacy_motconfig();
  static const int kLegacyMotconfigFieldNumber = 20;
  const ::std::string& legacy_motconfig() const;
  void set_legacy_motconfig(const ::std::string& value);
  #if LANG_CXX11
  void set_legacy_motconfig(::std::string&& value);
  #endif
  void set_legacy_motconfig(const char* value);
  void set_legacy_motconfig(const void* value, size_t size);
  ::std::string* mutable_legacy_motconfig();
  ::std::string* release_legacy_motconfig();
  void set_allocated_legacy_motconfig(::std::string* legacy_motconfig);

  // optional string topic = 23;
  bool has_topic() const;
  void clear_topic();
  static const int kTopicFieldNumber = 23;
  const ::std::string& topic() const;
  void set_topic(const ::std::string& value);
  #if LANG_CXX11
  void set_topic(::std::string&& value);
  #endif
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  ::std::string* mutable_topic();
  ::std::string* release_topic();
  void set_allocated_topic(::std::string* topic);

  // optional string interp_name = 26;
  bool has_interp_name() const;
  void clear_interp_name();
  static const int kInterpNameFieldNumber = 26;
  const ::std::string& interp_name() const;
  void set_interp_name(const ::std::string& value);
  #if LANG_CXX11
  void set_interp_name(::std::string&& value);
  #endif
  void set_interp_name(const char* value);
  void set_interp_name(const char* value, size_t size);
  ::std::string* mutable_interp_name();
  ::std::string* release_interp_name();
  void set_allocated_interp_name(::std::string* interp_name);

  // optional string name = 67 [(.nanopb) = {
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 67;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bytes uuid = 72 [(.nanopb) = {
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 72;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const void* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // optional .machinetalk.MotionCommand motcmd = 9;
  bool has_motcmd() const;
  void clear_motcmd();
  static const int kMotcmdFieldNumber = 9;
  private:
  const ::machinetalk::MotionCommand& _internal_motcmd() const;
  public:
  const ::machinetalk::MotionCommand& motcmd() const;
  ::machinetalk::MotionCommand* release_motcmd();
  ::machinetalk::MotionCommand* mutable_motcmd();
  void set_allocated_motcmd(::machinetalk::MotionCommand* motcmd);

  // optional .machinetalk.MotionStatus motstat = 10;
  bool has_motstat() const;
  void clear_motstat();
  static const int kMotstatFieldNumber = 10;
  private:
  const ::machinetalk::MotionStatus& _internal_motstat() const;
  public:
  const ::machinetalk::MotionStatus& motstat() const;
  ::machinetalk::MotionStatus* release_motstat();
  ::machinetalk::MotionStatus* mutable_motstat();
  void set_allocated_motstat(::machinetalk::MotionStatus* motstat);

  // optional .machinetalk.RTAPI_Message rtapi_message = 13;
  bool has_rtapi_message() const;
  void clear_rtapi_message();
  static const int kRtapiMessageFieldNumber = 13;
  private:
  const ::machinetalk::RTAPI_Message& _internal_rtapi_message() const;
  public:
  const ::machinetalk::RTAPI_Message& rtapi_message() const;
  ::machinetalk::RTAPI_Message* release_rtapi_message();
  ::machinetalk::RTAPI_Message* mutable_rtapi_message();
  void set_allocated_rtapi_message(::machinetalk::RTAPI_Message* rtapi_message);

  // optional .machinetalk.TaskReply task_reply = 14 [(.nanopb) = {
  bool has_task_reply() const;
  void clear_task_reply();
  static const int kTaskReplyFieldNumber = 14;
  private:
  const ::machinetalk::TaskReply& _internal_task_reply() const;
  public:
  const ::machinetalk::TaskReply& task_reply() const;
  ::machinetalk::TaskReply* release_task_reply();
  ::machinetalk::TaskReply* mutable_task_reply();
  void set_allocated_task_reply(::machinetalk::TaskReply* task_reply);

  // optional .machinetalk.TicketUpdate ticket_update = 15;
  bool has_ticket_update() const;
  void clear_ticket_update();
  static const int kTicketUpdateFieldNumber = 15;
  private:
  const ::machinetalk::TicketUpdate& _internal_ticket_update() const;
  public:
  const ::machinetalk::TicketUpdate& ticket_update() const;
  ::machinetalk::TicketUpdate* release_ticket_update();
  ::machinetalk::TicketUpdate* mutable_ticket_update();
  void set_allocated_ticket_update(::machinetalk::TicketUpdate* ticket_update);

  // optional .machinetalk.RTAPICommand rtapicmd = 86 [(.nanopb) = {
  bool has_rtapicmd() const;
  void clear_rtapicmd();
  static const int kRtapicmdFieldNumber = 86;
  private:
  const ::machinetalk::RTAPICommand& _internal_rtapicmd() const;
  public:
  const ::machinetalk::RTAPICommand& rtapicmd() const;
  ::machinetalk::RTAPICommand* release_rtapicmd();
  ::machinetalk::RTAPICommand* mutable_rtapicmd();
  void set_allocated_rtapicmd(::machinetalk::RTAPICommand* rtapicmd);

  // optional .machinetalk.LogMessage log_message = 87 [(.nanopb) = {
  bool has_log_message() const;
  void clear_log_message();
  static const int kLogMessageFieldNumber = 87;
  private:
  const ::machinetalk::LogMessage& _internal_log_message() const;
  public:
  const ::machinetalk::LogMessage& log_message() const;
  ::machinetalk::LogMessage* release_log_message();
  ::machinetalk::LogMessage* mutable_log_message();
  void set_allocated_log_message(::machinetalk::LogMessage* log_message);

  // optional .machinetalk.ProtocolParameters pparams = 109 [(.nanopb) = {
  bool has_pparams() const;
  void clear_pparams();
  static const int kPparamsFieldNumber = 109;
  private:
  const ::machinetalk::ProtocolParameters& _internal_pparams() const;
  public:
  const ::machinetalk::ProtocolParameters& pparams() const;
  ::machinetalk::ProtocolParameters* release_pparams();
  ::machinetalk::ProtocolParameters* mutable_pparams();
  void set_allocated_pparams(::machinetalk::ProtocolParameters* pparams);

  // optional .machinetalk.TaskPlanExecute tpexecute = 200 [(.nanopb) = {
  bool has_tpexecute() const;
  void clear_tpexecute();
  static const int kTpexecuteFieldNumber = 200;
  private:
  const ::machinetalk::TaskPlanExecute& _internal_tpexecute() const;
  public:
  const ::machinetalk::TaskPlanExecute& tpexecute() const;
  ::machinetalk::TaskPlanExecute* release_tpexecute();
  ::machinetalk::TaskPlanExecute* mutable_tpexecute();
  void set_allocated_tpexecute(::machinetalk::TaskPlanExecute* tpexecute);

  // optional .machinetalk.TaskPlanBlockDelete tpblockdelete = 201 [(.nanopb) = {
  bool has_tpblockdelete() const;
  void clear_tpblockdelete();
  static const int kTpblockdeleteFieldNumber = 201;
  private:
  const ::machinetalk::TaskPlanBlockDelete& _internal_tpblockdelete() const;
  public:
  const ::machinetalk::TaskPlanBlockDelete& tpblockdelete() const;
  ::machinetalk::TaskPlanBlockDelete* release_tpblockdelete();
  ::machinetalk::TaskPlanBlockDelete* mutable_tpblockdelete();
  void set_allocated_tpblockdelete(::machinetalk::TaskPlanBlockDelete* tpblockdelete);

  // optional .machinetalk.TaskPlanOptionalStop tpoptionalstop = 202 [(.nanopb) = {
  bool has_tpoptionalstop() const;
  void clear_tpoptionalstop();
  static const int kTpoptionalstopFieldNumber = 202;
  private:
  const ::machinetalk::TaskPlanOptionalStop& _internal_tpoptionalstop() const;
  public:
  const ::machinetalk::TaskPlanOptionalStop& tpoptionalstop() const;
  ::machinetalk::TaskPlanOptionalStop* release_tpoptionalstop();
  ::machinetalk::TaskPlanOptionalStop* mutable_tpoptionalstop();
  void set_allocated_tpoptionalstop(::machinetalk::TaskPlanOptionalStop* tpoptionalstop);

  // optional .machinetalk.TaskPlanOpen tpopen = 203 [(.nanopb) = {
  bool has_tpopen() const;
  void clear_tpopen();
  static const int kTpopenFieldNumber = 203;
  private:
  const ::machinetalk::TaskPlanOpen& _internal_tpopen() const;
  public:
  const ::machinetalk::TaskPlanOpen& tpopen() const;
  ::machinetalk::TaskPlanOpen* release_tpopen();
  ::machinetalk::TaskPlanOpen* mutable_tpopen();
  void set_allocated_tpopen(::machinetalk::TaskPlanOpen* tpopen);

  // optional .machinetalk.TaskPlanReply taskplan_reply = 210 [(.nanopb) = {
  bool has_taskplan_reply() const;
  void clear_taskplan_reply();
  static const int kTaskplanReplyFieldNumber = 210;
  private:
  const ::machinetalk::TaskPlanReply& _internal_taskplan_reply() const;
  public:
  const ::machinetalk::TaskPlanReply& taskplan_reply() const;
  ::machinetalk::TaskPlanReply* release_taskplan_reply();
  ::machinetalk::TaskPlanReply* mutable_taskplan_reply();
  void set_allocated_taskplan_reply(::machinetalk::TaskPlanReply* taskplan_reply);

  // optional .machinetalk.Emc_Traj_Set_G5x traj_set_g5x = 300;
  bool has_traj_set_g5x() const;
  void clear_traj_set_g5x();
  static const int kTrajSetG5XFieldNumber = 300;
  private:
  const ::machinetalk::Emc_Traj_Set_G5x& _internal_traj_set_g5x() const;
  public:
  const ::machinetalk::Emc_Traj_Set_G5x& traj_set_g5x() const;
  ::machinetalk::Emc_Traj_Set_G5x* release_traj_set_g5x();
  ::machinetalk::Emc_Traj_Set_G5x* mutable_traj_set_g5x();
  void set_allocated_traj_set_g5x(::machinetalk::Emc_Traj_Set_G5x* traj_set_g5x);

  // optional .machinetalk.Emc_Traj_Set_G92 traj_set_g92 = 310;
  bool has_traj_set_g92() const;
  void clear_traj_set_g92();
  static const int kTrajSetG92FieldNumber = 310;
  private:
  const ::machinetalk::Emc_Traj_Set_G92& _internal_traj_set_g92() const;
  public:
  const ::machinetalk::Emc_Traj_Set_G92& traj_set_g92() const;
  ::machinetalk::Emc_Traj_Set_G92* release_traj_set_g92();
  ::machinetalk::Emc_Traj_Set_G92* mutable_traj_set_g92();
  void set_allocated_traj_set_g92(::machinetalk::Emc_Traj_Set_G92* traj_set_g92);

  // optional .machinetalk.Emc_Traj_Set_Rotation traj_set_rotation = 320;
  bool has_traj_set_rotation() const;
  void clear_traj_set_rotation();
  static const int kTrajSetRotationFieldNumber = 320;
  private:
  const ::machinetalk::Emc_Traj_Set_Rotation& _internal_traj_set_rotation() const;
  public:
  const ::machinetalk::Emc_Traj_Set_Rotation& traj_set_rotation() const;
  ::machinetalk::Emc_Traj_Set_Rotation* release_traj_set_rotation();
  ::machinetalk::Emc_Traj_Set_Rotation* mutable_traj_set_rotation();
  void set_allocated_traj_set_rotation(::machinetalk::Emc_Traj_Set_Rotation* traj_set_rotation);

  // optional .machinetalk.Emc_Traj_Linear_Move traj_linear_move = 330;
  bool has_traj_linear_move() const;
  void clear_traj_linear_move();
  static const int kTrajLinearMoveFieldNumber = 330;
  private:
  const ::machinetalk::Emc_Traj_Linear_Move& _internal_traj_linear_move() const;
  public:
  const ::machinetalk::Emc_Traj_Linear_Move& traj_linear_move() const;
  ::machinetalk::Emc_Traj_Linear_Move* release_traj_linear_move();
  ::machinetalk::Emc_Traj_Linear_Move* mutable_traj_linear_move();
  void set_allocated_traj_linear_move(::machinetalk::Emc_Traj_Linear_Move* traj_linear_move);

  // optional .machinetalk.Emc_Traj_Probe traj_probe = 340;
  bool has_traj_probe() const;
  void clear_traj_probe();
  static const int kTrajProbeFieldNumber = 340;
  private:
  const ::machinetalk::Emc_Traj_Probe& _internal_traj_probe() const;
  public:
  const ::machinetalk::Emc_Traj_Probe& traj_probe() const;
  ::machinetalk::Emc_Traj_Probe* release_traj_probe();
  ::machinetalk::Emc_Traj_Probe* mutable_traj_probe();
  void set_allocated_traj_probe(::machinetalk::Emc_Traj_Probe* traj_probe);

  // optional .machinetalk.Emc_Traj_Circular_Move traj_circular_move = 350;
  bool has_traj_circular_move() const;
  void clear_traj_circular_move();
  static const int kTrajCircularMoveFieldNumber = 350;
  private:
  const ::machinetalk::Emc_Traj_Circular_Move& _internal_traj_circular_move() const;
  public:
  const ::machinetalk::Emc_Traj_Circular_Move& traj_circular_move() const;
  ::machinetalk::Emc_Traj_Circular_Move* release_traj_circular_move();
  ::machinetalk::Emc_Traj_Circular_Move* mutable_traj_circular_move();
  void set_allocated_traj_circular_move(::machinetalk::Emc_Traj_Circular_Move* traj_circular_move);

  // optional .machinetalk.Emc_Traj_Rigid_Tap traj_rigid_tap = 360;
  bool has_traj_rigid_tap() const;
  void clear_traj_rigid_tap();
  static const int kTrajRigidTapFieldNumber = 360;
  private:
  const ::machinetalk::Emc_Traj_Rigid_Tap& _internal_traj_rigid_tap() const;
  public:
  const ::machinetalk::Emc_Traj_Rigid_Tap& traj_rigid_tap() const;
  ::machinetalk::Emc_Traj_Rigid_Tap* release_traj_rigid_tap();
  ::machinetalk::Emc_Traj_Rigid_Tap* mutable_traj_rigid_tap();
  void set_allocated_traj_rigid_tap(::machinetalk::Emc_Traj_Rigid_Tap* traj_rigid_tap);

  // optional .machinetalk.Emc_Traj_Set_Term_Cond traj_set_term_cond = 370;
  bool has_traj_set_term_cond() const;
  void clear_traj_set_term_cond();
  static const int kTrajSetTermCondFieldNumber = 370;
  private:
  const ::machinetalk::Emc_Traj_Set_Term_Cond& _internal_traj_set_term_cond() const;
  public:
  const ::machinetalk::Emc_Traj_Set_Term_Cond& traj_set_term_cond() const;
  ::machinetalk::Emc_Traj_Set_Term_Cond* release_traj_set_term_cond();
  ::machinetalk::Emc_Traj_Set_Term_Cond* mutable_traj_set_term_cond();
  void set_allocated_traj_set_term_cond(::machinetalk::Emc_Traj_Set_Term_Cond* traj_set_term_cond);

  // optional .machinetalk.Emc_Traj_Set_Spindlesync traj_set_spindlesync = 380;
  bool has_traj_set_spindlesync() const;
  void clear_traj_set_spindlesync();
  static const int kTrajSetSpindlesyncFieldNumber = 380;
  private:
  const ::machinetalk::Emc_Traj_Set_Spindlesync& _internal_traj_set_spindlesync() const;
  public:
  const ::machinetalk::Emc_Traj_Set_Spindlesync& traj_set_spindlesync() const;
  ::machinetalk::Emc_Traj_Set_Spindlesync* release_traj_set_spindlesync();
  ::machinetalk::Emc_Traj_Set_Spindlesync* mutable_traj_set_spindlesync();
  void set_allocated_traj_set_spindlesync(::machinetalk::Emc_Traj_Set_Spindlesync* traj_set_spindlesync);

  // optional .machinetalk.Emc_Traj_Delay traj_delay = 390;
  bool has_traj_delay() const;
  void clear_traj_delay();
  static const int kTrajDelayFieldNumber = 390;
  private:
  const ::machinetalk::Emc_Traj_Delay& _internal_traj_delay() const;
  public:
  const ::machinetalk::Emc_Traj_Delay& traj_delay() const;
  ::machinetalk::Emc_Traj_Delay* release_traj_delay();
  ::machinetalk::Emc_Traj_Delay* mutable_traj_delay();
  void set_allocated_traj_delay(::machinetalk::Emc_Traj_Delay* traj_delay);

  // optional .machinetalk.Emc_Spindle_On spindle_on = 400;
  bool has_spindle_on() const;
  void clear_spindle_on();
  static const int kSpindleOnFieldNumber = 400;
  private:
  const ::machinetalk::Emc_Spindle_On& _internal_spindle_on() const;
  public:
  const ::machinetalk::Emc_Spindle_On& spindle_on() const;
  ::machinetalk::Emc_Spindle_On* release_spindle_on();
  ::machinetalk::Emc_Spindle_On* mutable_spindle_on();
  void set_allocated_spindle_on(::machinetalk::Emc_Spindle_On* spindle_on);

  // optional .machinetalk.Emc_Spindle_Speed spindle_speed = 410;
  bool has_spindle_speed() const;
  void clear_spindle_speed();
  static const int kSpindleSpeedFieldNumber = 410;
  private:
  const ::machinetalk::Emc_Spindle_Speed& _internal_spindle_speed() const;
  public:
  const ::machinetalk::Emc_Spindle_Speed& spindle_speed() const;
  ::machinetalk::Emc_Spindle_Speed* release_spindle_speed();
  ::machinetalk::Emc_Spindle_Speed* mutable_spindle_speed();
  void set_allocated_spindle_speed(::machinetalk::Emc_Spindle_Speed* spindle_speed);

  // optional .machinetalk.Emc_Spindle_Orient spindle_orient = 420;
  bool has_spindle_orient() const;
  void clear_spindle_orient();
  static const int kSpindleOrientFieldNumber = 420;
  private:
  const ::machinetalk::Emc_Spindle_Orient& _internal_spindle_orient() const;
  public:
  const ::machinetalk::Emc_Spindle_Orient& spindle_orient() const;
  ::machinetalk::Emc_Spindle_Orient* release_spindle_orient();
  ::machinetalk::Emc_Spindle_Orient* mutable_spindle_orient();
  void set_allocated_spindle_orient(::machinetalk::Emc_Spindle_Orient* spindle_orient);

  // optional .machinetalk.Emc_Spindle_Wait_Orient_Complete spindle_wait_orient_complete = 430;
  bool has_spindle_wait_orient_complete() const;
  void clear_spindle_wait_orient_complete();
  static const int kSpindleWaitOrientCompleteFieldNumber = 430;
  private:
  const ::machinetalk::Emc_Spindle_Wait_Orient_Complete& _internal_spindle_wait_orient_complete() const;
  public:
  const ::machinetalk::Emc_Spindle_Wait_Orient_Complete& spindle_wait_orient_complete() const;
  ::machinetalk::Emc_Spindle_Wait_Orient_Complete* release_spindle_wait_orient_complete();
  ::machinetalk::Emc_Spindle_Wait_Orient_Complete* mutable_spindle_wait_orient_complete();
  void set_allocated_spindle_wait_orient_complete(::machinetalk::Emc_Spindle_Wait_Orient_Complete* spindle_wait_orient_complete);

  // optional .machinetalk.Emc_Tool_Set_Offset tool_set_offet = 440;
  bool has_tool_set_offet() const;
  void clear_tool_set_offet();
  static const int kToolSetOffetFieldNumber = 440;
  private:
  const ::machinetalk::Emc_Tool_Set_Offset& _internal_tool_set_offet() const;
  public:
  const ::machinetalk::Emc_Tool_Set_Offset& tool_set_offet() const;
  ::machinetalk::Emc_Tool_Set_Offset* release_tool_set_offet();
  ::machinetalk::Emc_Tool_Set_Offset* mutable_tool_set_offet();
  void set_allocated_tool_set_offet(::machinetalk::Emc_Tool_Set_Offset* tool_set_offet);

  // optional .machinetalk.Emc_Traj_Set_Offset traj_set_offset = 450;
  bool has_traj_set_offset() const;
  void clear_traj_set_offset();
  static const int kTrajSetOffsetFieldNumber = 450;
  private:
  const ::machinetalk::Emc_Traj_Set_Offset& _internal_traj_set_offset() const;
  public:
  const ::machinetalk::Emc_Traj_Set_Offset& traj_set_offset() const;
  ::machinetalk::Emc_Traj_Set_Offset* release_traj_set_offset();
  ::machinetalk::Emc_Traj_Set_Offset* mutable_traj_set_offset();
  void set_allocated_traj_set_offset(::machinetalk::Emc_Traj_Set_Offset* traj_set_offset);

  // optional .machinetalk.Emc_Tool_Prepare tool_prepare = 460;
  bool has_tool_prepare() const;
  void clear_tool_prepare();
  static const int kToolPrepareFieldNumber = 460;
  private:
  const ::machinetalk::Emc_Tool_Prepare& _internal_tool_prepare() const;
  public:
  const ::machinetalk::Emc_Tool_Prepare& tool_prepare() const;
  ::machinetalk::Emc_Tool_Prepare* release_tool_prepare();
  ::machinetalk::Emc_Tool_Prepare* mutable_tool_prepare();
  void set_allocated_tool_prepare(::machinetalk::Emc_Tool_Prepare* tool_prepare);

  // optional .machinetalk.Emc_Tool_Set_Number tool_set_number = 470;
  bool has_tool_set_number() const;
  void clear_tool_set_number();
  static const int kToolSetNumberFieldNumber = 470;
  private:
  const ::machinetalk::Emc_Tool_Set_Number& _internal_tool_set_number() const;
  public:
  const ::machinetalk::Emc_Tool_Set_Number& tool_set_number() const;
  ::machinetalk::Emc_Tool_Set_Number* release_tool_set_number();
  ::machinetalk::Emc_Tool_Set_Number* mutable_tool_set_number();
  void set_allocated_tool_set_number(::machinetalk::Emc_Tool_Set_Number* tool_set_number);

  // optional .machinetalk.Emc_Traj_Set_Fo_Enable traj_set_fo_enable = 480;
  bool has_traj_set_fo_enable() const;
  void clear_traj_set_fo_enable();
  static const int kTrajSetFoEnableFieldNumber = 480;
  private:
  const ::machinetalk::Emc_Traj_Set_Fo_Enable& _internal_traj_set_fo_enable() const;
  public:
  const ::machinetalk::Emc_Traj_Set_Fo_Enable& traj_set_fo_enable() const;
  ::machinetalk::Emc_Traj_Set_Fo_Enable* release_traj_set_fo_enable();
  ::machinetalk::Emc_Traj_Set_Fo_Enable* mutable_traj_set_fo_enable();
  void set_allocated_traj_set_fo_enable(::machinetalk::Emc_Traj_Set_Fo_Enable* traj_set_fo_enable);

  // optional .machinetalk.Emc_Traj_Set_So_Enable traj_set_so_enable = 490;
  bool has_traj_set_so_enable() const;
  void clear_traj_set_so_enable();
  static const int kTrajSetSoEnableFieldNumber = 490;
  private:
  const ::machinetalk::Emc_Traj_Set_So_Enable& _internal_traj_set_so_enable() const;
  public:
  const ::machinetalk::Emc_Traj_Set_So_Enable& traj_set_so_enable() const;
  ::machinetalk::Emc_Traj_Set_So_Enable* release_traj_set_so_enable();
  ::machinetalk::Emc_Traj_Set_So_Enable* mutable_traj_set_so_enable();
  void set_allocated_traj_set_so_enable(::machinetalk::Emc_Traj_Set_So_Enable* traj_set_so_enable);

  // optional .machinetalk.Emc_Traj_Set_Fh_Enable traj_set_fh_enable = 500;
  bool has_traj_set_fh_enable() const;
  void clear_traj_set_fh_enable();
  static const int kTrajSetFhEnableFieldNumber = 500;
  private:
  const ::machinetalk::Emc_Traj_Set_Fh_Enable& _internal_traj_set_fh_enable() const;
  public:
  const ::machinetalk::Emc_Traj_Set_Fh_Enable& traj_set_fh_enable() const;
  ::machinetalk::Emc_Traj_Set_Fh_Enable* release_traj_set_fh_enable();
  ::machinetalk::Emc_Traj_Set_Fh_Enable* mutable_traj_set_fh_enable();
  void set_allocated_traj_set_fh_enable(::machinetalk::Emc_Traj_Set_Fh_Enable* traj_set_fh_enable);

  // optional .machinetalk.Emc_Motion_Adaptive motion_adaptive = 510;
  bool has_motion_adaptive() const;
  void clear_motion_adaptive();
  static const int kMotionAdaptiveFieldNumber = 510;
  private:
  const ::machinetalk::Emc_Motion_Adaptive& _internal_motion_adaptive() const;
  public:
  const ::machinetalk::Emc_Motion_Adaptive& motion_adaptive() const;
  ::machinetalk::Emc_Motion_Adaptive* release_motion_adaptive();
  ::machinetalk::Emc_Motion_Adaptive* mutable_motion_adaptive();
  void set_allocated_motion_adaptive(::machinetalk::Emc_Motion_Adaptive* motion_adaptive);

  // optional .machinetalk.Emc_Operator_Display operator_display = 520;
  bool has_operator_display() const;
  void clear_operator_display();
  static const int kOperatorDisplayFieldNumber = 520;
  private:
  const ::machinetalk::Emc_Operator_Display& _internal_operator_display() const;
  public:
  const ::machinetalk::Emc_Operator_Display& operator_display() const;
  ::machinetalk::Emc_Operator_Display* release_operator_display();
  ::machinetalk::Emc_Operator_Display* mutable_operator_display();
  void set_allocated_operator_display(::machinetalk::Emc_Operator_Display* operator_display);

  // optional .machinetalk.Emc_Operator_Text operator_text = 530;
  bool has_operator_text() const;
  void clear_operator_text();
  static const int kOperatorTextFieldNumber = 530;
  private:
  const ::machinetalk::Emc_Operator_Text& _internal_operator_text() const;
  public:
  const ::machinetalk::Emc_Operator_Text& operator_text() const;
  ::machinetalk::Emc_Operator_Text* release_operator_text();
  ::machinetalk::Emc_Operator_Text* mutable_operator_text();
  void set_allocated_operator_text(::machinetalk::Emc_Operator_Text* operator_text);

  // optional .machinetalk.Emc_Operator_Error operator_error = 540;
  bool has_operator_error() const;
  void clear_operator_error();
  static const int kOperatorErrorFieldNumber = 540;
  private:
  const ::machinetalk::Emc_Operator_Error& _internal_operator_error() const;
  public:
  const ::machinetalk::Emc_Operator_Error& operator_error() const;
  ::machinetalk::Emc_Operator_Error* release_operator_error();
  ::machinetalk::Emc_Operator_Error* mutable_operator_error();
  void set_allocated_operator_error(::machinetalk::Emc_Operator_Error* operator_error);

  // optional .machinetalk.Emc_Motion_Set_Dout motion_set_dout = 550;
  bool has_motion_set_dout() const;
  void clear_motion_set_dout();
  static const int kMotionSetDoutFieldNumber = 550;
  private:
  const ::machinetalk::Emc_Motion_Set_Dout& _internal_motion_set_dout() const;
  public:
  const ::machinetalk::Emc_Motion_Set_Dout& motion_set_dout() const;
  ::machinetalk::Emc_Motion_Set_Dout* release_motion_set_dout();
  ::machinetalk::Emc_Motion_Set_Dout* mutable_motion_set_dout();
  void set_allocated_motion_set_dout(::machinetalk::Emc_Motion_Set_Dout* motion_set_dout);

  // optional .machinetalk.Emc_Motion_Set_Aout motion_set_aout = 560;
  bool has_motion_set_aout() const;
  void clear_motion_set_aout();
  static const int kMotionSetAoutFieldNumber = 560;
  private:
  const ::machinetalk::Emc_Motion_Set_Aout& _internal_motion_set_aout() const;
  public:
  const ::machinetalk::Emc_Motion_Set_Aout& motion_set_aout() const;
  ::machinetalk::Emc_Motion_Set_Aout* release_motion_set_aout();
  ::machinetalk::Emc_Motion_Set_Aout* mutable_motion_set_aout();
  void set_allocated_motion_set_aout(::machinetalk::Emc_Motion_Set_Aout* motion_set_aout);

  // optional .machinetalk.Emc_Aux_Input_Wait aux_input_wait = 570;
  bool has_aux_input_wait() const;
  void clear_aux_input_wait();
  static const int kAuxInputWaitFieldNumber = 570;
  private:
  const ::machinetalk::Emc_Aux_Input_Wait& _internal_aux_input_wait() const;
  public:
  const ::machinetalk::Emc_Aux_Input_Wait& aux_input_wait() const;
  ::machinetalk::Emc_Aux_Input_Wait* release_aux_input_wait();
  ::machinetalk::Emc_Aux_Input_Wait* mutable_aux_input_wait();
  void set_allocated_aux_input_wait(::machinetalk::Emc_Aux_Input_Wait* aux_input_wait);

  // optional .machinetalk.Emc_Exec_Plugin_Ca1l exec_plugin_call = 580;
  bool has_exec_plugin_call() const;
  void clear_exec_plugin_call();
  static const int kExecPluginCallFieldNumber = 580;
  private:
  const ::machinetalk::Emc_Exec_Plugin_Ca1l& _internal_exec_plugin_call() const;
  public:
  const ::machinetalk::Emc_Exec_Plugin_Ca1l& exec_plugin_call() const;
  ::machinetalk::Emc_Exec_Plugin_Ca1l* release_exec_plugin_call();
  ::machinetalk::Emc_Exec_Plugin_Ca1l* mutable_exec_plugin_call();
  void set_allocated_exec_plugin_call(::machinetalk::Emc_Exec_Plugin_Ca1l* exec_plugin_call);

  // optional .machinetalk.Emc_Io_Plugin_Call io_plugin_call = 590;
  bool has_io_plugin_call() const;
  void clear_io_plugin_call();
  static const int kIoPluginCallFieldNumber = 590;
  private:
  const ::machinetalk::Emc_Io_Plugin_Call& _internal_io_plugin_call() const;
  public:
  const ::machinetalk::Emc_Io_Plugin_Call& io_plugin_call() const;
  ::machinetalk::Emc_Io_Plugin_Call* release_io_plugin_call();
  ::machinetalk::Emc_Io_Plugin_Call* mutable_io_plugin_call();
  void set_allocated_io_plugin_call(::machinetalk::Emc_Io_Plugin_Call* io_plugin_call);

  // optional .machinetalk.EmcStatusConfig emc_status_config = 600 [(.nanopb) = {
  bool has_emc_status_config() const;
  void clear_emc_status_config();
  static const int kEmcStatusConfigFieldNumber = 600;
  private:
  const ::machinetalk::EmcStatusConfig& _internal_emc_status_config() const;
  public:
  const ::machinetalk::EmcStatusConfig& emc_status_config() const;
  ::machinetalk::EmcStatusConfig* release_emc_status_config();
  ::machinetalk::EmcStatusConfig* mutable_emc_status_config();
  void set_allocated_emc_status_config(::machinetalk::EmcStatusConfig* emc_status_config);

  // optional .machinetalk.EmcStatusMotion emc_status_motion = 601 [(.nanopb) = {
  bool has_emc_status_motion() const;
  void clear_emc_status_motion();
  static const int kEmcStatusMotionFieldNumber = 601;
  private:
  const ::machinetalk::EmcStatusMotion& _internal_emc_status_motion() const;
  public:
  const ::machinetalk::EmcStatusMotion& emc_status_motion() const;
  ::machinetalk::EmcStatusMotion* release_emc_status_motion();
  ::machinetalk::EmcStatusMotion* mutable_emc_status_motion();
  void set_allocated_emc_status_motion(::machinetalk::EmcStatusMotion* emc_status_motion);

  // optional .machinetalk.EmcStatusIo emc_status_io = 602 [(.nanopb) = {
  bool has_emc_status_io() const;
  void clear_emc_status_io();
  static const int kEmcStatusIoFieldNumber = 602;
  private:
  const ::machinetalk::EmcStatusIo& _internal_emc_status_io() const;
  public:
  const ::machinetalk::EmcStatusIo& emc_status_io() const;
  ::machinetalk::EmcStatusIo* release_emc_status_io();
  ::machinetalk::EmcStatusIo* mutable_emc_status_io();
  void set_allocated_emc_status_io(::machinetalk::EmcStatusIo* emc_status_io);

  // optional .machinetalk.EmcStatusTask emc_status_task = 603 [(.nanopb) = {
  bool has_emc_status_task() const;
  void clear_emc_status_task();
  static const int kEmcStatusTaskFieldNumber = 603;
  private:
  const ::machinetalk::EmcStatusTask& _internal_emc_status_task() const;
  public:
  const ::machinetalk::EmcStatusTask& emc_status_task() const;
  ::machinetalk::EmcStatusTask* release_emc_status_task();
  ::machinetalk::EmcStatusTask* mutable_emc_status_task();
  void set_allocated_emc_status_task(::machinetalk::EmcStatusTask* emc_status_task);

  // optional .machinetalk.EmcStatusInterp emc_status_interp = 604 [(.nanopb) = {
  bool has_emc_status_interp() const;
  void clear_emc_status_interp();
  static const int kEmcStatusInterpFieldNumber = 604;
  private:
  const ::machinetalk::EmcStatusInterp& _internal_emc_status_interp() const;
  public:
  const ::machinetalk::EmcStatusInterp& emc_status_interp() const;
  ::machinetalk::EmcStatusInterp* release_emc_status_interp();
  ::machinetalk::EmcStatusInterp* mutable_emc_status_interp();
  void set_allocated_emc_status_interp(::machinetalk::EmcStatusInterp* emc_status_interp);

  // optional .machinetalk.EmcStatusUI emc_status_ui = 605 [(.nanopb) = {
  bool has_emc_status_ui() const;
  void clear_emc_status_ui();
  static const int kEmcStatusUiFieldNumber = 605;
  private:
  const ::machinetalk::EmcStatusUI& _internal_emc_status_ui() const;
  public:
  const ::machinetalk::EmcStatusUI& emc_status_ui() const;
  ::machinetalk::EmcStatusUI* release_emc_status_ui();
  ::machinetalk::EmcStatusUI* mutable_emc_status_ui();
  void set_allocated_emc_status_ui(::machinetalk::EmcStatusUI* emc_status_ui);

  // optional .machinetalk.EmcCommandParameters emc_command_params = 610 [(.nanopb) = {
  bool has_emc_command_params() const;
  void clear_emc_command_params();
  static const int kEmcCommandParamsFieldNumber = 610;
  private:
  const ::machinetalk::EmcCommandParameters& _internal_emc_command_params() const;
  public:
  const ::machinetalk::EmcCommandParameters& emc_command_params() const;
  ::machinetalk::EmcCommandParameters* release_emc_command_params();
  ::machinetalk::EmcCommandParameters* mutable_emc_command_params();
  void set_allocated_emc_command_params(::machinetalk::EmcCommandParameters* emc_command_params);

  // optional sfixed64 tsc = 7;
  bool has_tsc() const;
  void clear_tsc();
  static const int kTscFieldNumber = 7;
  ::google::protobuf::int64 tsc() const;
  void set_tsc(::google::protobuf::int64 value);

  // optional int32 tv_sec = 21;
  bool has_tv_sec() const;
  void clear_tv_sec();
  static const int kTvSecFieldNumber = 21;
  ::google::protobuf::int32 tv_sec() const;
  void set_tv_sec(::google::protobuf::int32 value);

  // optional int32 tv_nsec = 22;
  bool has_tv_nsec() const;
  void clear_tv_nsec();
  static const int kTvNsecFieldNumber = 22;
  ::google::protobuf::int32 tv_nsec() const;
  void set_tv_nsec(::google::protobuf::int32 value);

  // optional int32 rsvp = 30;
  bool has_rsvp() const;
  void clear_rsvp();
  static const int kRsvpFieldNumber = 30;
  ::google::protobuf::int32 rsvp() const;
  void set_rsvp(::google::protobuf::int32 value);

  // optional int32 serial = 45;
  bool has_serial() const;
  void clear_serial();
  static const int kSerialFieldNumber = 45;
  ::google::protobuf::int32 serial() const;
  void set_serial(::google::protobuf::int32 value);

  // optional bool reply_required = 24;
  bool has_reply_required() const;
  void clear_reply_required();
  static const int kReplyRequiredFieldNumber = 24;
  bool reply_required() const;
  void set_reply_required(bool value);

  // optional bool trace = 75;
  bool has_trace() const;
  void clear_trace();
  static const int kTraceFieldNumber = 75;
  bool trace() const;
  void set_trace(bool value);

  // optional int32 reply_serial = 50;
  bool has_reply_serial() const;
  void clear_reply_serial();
  static const int kReplySerialFieldNumber = 50;
  ::google::protobuf::int32 reply_serial() const;
  void set_reply_serial(::google::protobuf::int32 value);

  // optional int32 ticket = 55;
  bool has_ticket() const;
  void clear_ticket();
  static const int kTicketFieldNumber = 55;
  ::google::protobuf::int32 ticket() const;
  void set_ticket(::google::protobuf::int32 value);

  // optional int32 reply_ticket = 60;
  bool has_reply_ticket() const;
  void clear_reply_ticket();
  static const int kReplyTicketFieldNumber = 60;
  ::google::protobuf::int32 reply_ticket() const;
  void set_reply_ticket(::google::protobuf::int32 value);

  // optional int32 sequence = 62;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 62;
  ::google::protobuf::int32 sequence() const;
  void set_sequence(::google::protobuf::int32 value);

  // optional int32 credit = 65;
  bool has_credit() const;
  void clear_credit();
  static const int kCreditFieldNumber = 65;
  ::google::protobuf::int32 credit() const;
  void set_credit(::google::protobuf::int32 value);

  // optional int32 line_number = 66;
  bool has_line_number() const;
  void clear_line_number();
  static const int kLineNumberFieldNumber = 66;
  ::google::protobuf::int32 line_number() const;
  void set_line_number(::google::protobuf::int32 value);

  // optional int32 retcode = 69;
  bool has_retcode() const;
  void clear_retcode();
  static const int kRetcodeFieldNumber = 69;
  ::google::protobuf::int32 retcode() const;
  void set_retcode(::google::protobuf::int32 value);

  // optional int32 instance = 77;
  bool has_instance() const;
  void clear_instance();
  static const int kInstanceFieldNumber = 77;
  ::google::protobuf::int32 instance() const;
  void set_instance(::google::protobuf::int32 value);

  // optional int32 index = 131 [(.nanopb) = {
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 131;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // optional .machinetalk.StatusType status = 40;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 40;
  ::machinetalk::StatusType status() const;
  void set_status(::machinetalk::StatusType value);

  // required .machinetalk.ContainerType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::machinetalk::ContainerType type() const;
  void set_type(::machinetalk::ContainerType value);

  // optional .machinetalk.InterpreterStateType interp_state = 25 [(.nanopb) = {
  bool has_interp_state() const;
  void clear_interp_state();
  static const int kInterpStateFieldNumber = 25;
  ::machinetalk::InterpreterStateType interp_state() const;
  void set_interp_state(::machinetalk::InterpreterStateType value);

  // optional .machinetalk.ContainerType in_reply_to = 33;
  bool has_in_reply_to() const;
  void clear_in_reply_to();
  static const int kInReplyToFieldNumber = 33;
  ::machinetalk::ContainerType in_reply_to() const;
  void set_in_reply_to(::machinetalk::ContainerType value);

  // optional .machinetalk.RCS_STATUS rcs_status = 35;
  bool has_rcs_status() const;
  void clear_rcs_status();
  static const int kRcsStatusFieldNumber = 35;
  ::machinetalk::RCS_STATUS rcs_status() const;
  void set_rcs_status(::machinetalk::RCS_STATUS value);

  // @@protoc_insertion_point(class_scope:machinetalk.Container)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_tsc();
  void clear_has_tsc();
  void set_has_motcmd();
  void clear_has_motcmd();
  void set_has_motstat();
  void clear_has_motstat();
  void set_has_legacy_motcmd();
  void clear_has_legacy_motcmd();
  void set_has_legacy_motstat();
  void clear_has_legacy_motstat();
  void set_has_rtapi_message();
  void clear_has_rtapi_message();
  void set_has_task_reply();
  void clear_has_task_reply();
  void set_has_ticket_update();
  void clear_has_ticket_update();
  void set_has_syslog();
  void clear_has_syslog();
  void set_has_legacy_nml();
  void clear_has_legacy_nml();
  void set_has_legacy_motconfig();
  void clear_has_legacy_motconfig();
  void set_has_tv_sec();
  void clear_has_tv_sec();
  void set_has_tv_nsec();
  void clear_has_tv_nsec();
  void set_has_topic();
  void clear_has_topic();
  void set_has_reply_required();
  void clear_has_reply_required();
  void set_has_interp_state();
  void clear_has_interp_state();
  void set_has_interp_name();
  void clear_has_interp_name();
  void set_has_rsvp();
  void clear_has_rsvp();
  void set_has_in_reply_to();
  void clear_has_in_reply_to();
  void set_has_rcs_status();
  void clear_has_rcs_status();
  void set_has_status();
  void clear_has_status();
  void set_has_serial();
  void clear_has_serial();
  void set_has_reply_serial();
  void clear_has_reply_serial();
  void set_has_ticket();
  void clear_has_ticket();
  void set_has_reply_ticket();
  void clear_has_reply_ticket();
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_credit();
  void clear_has_credit();
  void set_has_line_number();
  void clear_has_line_number();
  void set_has_name();
  void clear_has_name();
  void set_has_retcode();
  void clear_has_retcode();
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_trace();
  void clear_has_trace();
  void set_has_instance();
  void clear_has_instance();
  void set_has_rtapicmd();
  void clear_has_rtapicmd();
  void set_has_pparams();
  void clear_has_pparams();
  void set_has_index();
  void clear_has_index();
  void set_has_log_message();
  void clear_has_log_message();
  void set_has_tpexecute();
  void clear_has_tpexecute();
  void set_has_tpblockdelete();
  void clear_has_tpblockdelete();
  void set_has_tpoptionalstop();
  void clear_has_tpoptionalstop();
  void set_has_tpopen();
  void clear_has_tpopen();
  void set_has_taskplan_reply();
  void clear_has_taskplan_reply();
  void set_has_traj_set_g5x();
  void clear_has_traj_set_g5x();
  void set_has_traj_set_g92();
  void clear_has_traj_set_g92();
  void set_has_traj_set_rotation();
  void clear_has_traj_set_rotation();
  void set_has_traj_linear_move();
  void clear_has_traj_linear_move();
  void set_has_traj_probe();
  void clear_has_traj_probe();
  void set_has_traj_circular_move();
  void clear_has_traj_circular_move();
  void set_has_traj_rigid_tap();
  void clear_has_traj_rigid_tap();
  void set_has_traj_set_term_cond();
  void clear_has_traj_set_term_cond();
  void set_has_traj_set_spindlesync();
  void clear_has_traj_set_spindlesync();
  void set_has_traj_delay();
  void clear_has_traj_delay();
  void set_has_spindle_on();
  void clear_has_spindle_on();
  void set_has_spindle_speed();
  void clear_has_spindle_speed();
  void set_has_spindle_orient();
  void clear_has_spindle_orient();
  void set_has_spindle_wait_orient_complete();
  void clear_has_spindle_wait_orient_complete();
  void set_has_tool_set_offet();
  void clear_has_tool_set_offet();
  void set_has_traj_set_offset();
  void clear_has_traj_set_offset();
  void set_has_tool_prepare();
  void clear_has_tool_prepare();
  void set_has_tool_set_number();
  void clear_has_tool_set_number();
  void set_has_traj_set_fo_enable();
  void clear_has_traj_set_fo_enable();
  void set_has_traj_set_so_enable();
  void clear_has_traj_set_so_enable();
  void set_has_traj_set_fh_enable();
  void clear_has_traj_set_fh_enable();
  void set_has_motion_adaptive();
  void clear_has_motion_adaptive();
  void set_has_operator_display();
  void clear_has_operator_display();
  void set_has_operator_text();
  void clear_has_operator_text();
  void set_has_operator_error();
  void clear_has_operator_error();
  void set_has_motion_set_dout();
  void clear_has_motion_set_dout();
  void set_has_motion_set_aout();
  void clear_has_motion_set_aout();
  void set_has_aux_input_wait();
  void clear_has_aux_input_wait();
  void set_has_exec_plugin_call();
  void clear_has_exec_plugin_call();
  void set_has_io_plugin_call();
  void clear_has_io_plugin_call();
  void set_has_emc_status_config();
  void clear_has_emc_status_config();
  void set_has_emc_status_motion();
  void clear_has_emc_status_motion();
  void set_has_emc_status_io();
  void clear_has_emc_status_io();
  void set_has_emc_status_task();
  void clear_has_emc_status_task();
  void set_has_emc_status_interp();
  void clear_has_emc_status_interp();
  void set_has_emc_status_ui();
  void clear_has_emc_status_ui();
  void set_has_emc_command_params();
  void clear_has_emc_command_params();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<3> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Pin > pin_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Signal > signal_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Preview > preview_;
  ::google::protobuf::RepeatedPtrField< ::std::string> note_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Value > value_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::ServiceAnnouncement > service_announcement_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Component > comp_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Param > param_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Thread > thread_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Ring > ring_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Group > group_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Member > member_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Function > function_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Vtable > vtable_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Inst > inst_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Application > app_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Launcher > launcher_;
  ::google::protobuf::internal::ArenaStringPtr legacy_motcmd_;
  ::google::protobuf::internal::ArenaStringPtr legacy_motstat_;
  ::google::protobuf::internal::ArenaStringPtr syslog_;
  ::google::protobuf::internal::ArenaStringPtr legacy_nml_;
  ::google::protobuf::internal::ArenaStringPtr legacy_motconfig_;
  ::google::protobuf::internal::ArenaStringPtr topic_;
  ::google::protobuf::internal::ArenaStringPtr interp_name_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::machinetalk::MotionCommand* motcmd_;
  ::machinetalk::MotionStatus* motstat_;
  ::machinetalk::RTAPI_Message* rtapi_message_;
  ::machinetalk::TaskReply* task_reply_;
  ::machinetalk::TicketUpdate* ticket_update_;
  ::machinetalk::RTAPICommand* rtapicmd_;
  ::machinetalk::LogMessage* log_message_;
  ::machinetalk::ProtocolParameters* pparams_;
  ::machinetalk::TaskPlanExecute* tpexecute_;
  ::machinetalk::TaskPlanBlockDelete* tpblockdelete_;
  ::machinetalk::TaskPlanOptionalStop* tpoptionalstop_;
  ::machinetalk::TaskPlanOpen* tpopen_;
  ::machinetalk::TaskPlanReply* taskplan_reply_;
  ::machinetalk::Emc_Traj_Set_G5x* traj_set_g5x_;
  ::machinetalk::Emc_Traj_Set_G92* traj_set_g92_;
  ::machinetalk::Emc_Traj_Set_Rotation* traj_set_rotation_;
  ::machinetalk::Emc_Traj_Linear_Move* traj_linear_move_;
  ::machinetalk::Emc_Traj_Probe* traj_probe_;
  ::machinetalk::Emc_Traj_Circular_Move* traj_circular_move_;
  ::machinetalk::Emc_Traj_Rigid_Tap* traj_rigid_tap_;
  ::machinetalk::Emc_Traj_Set_Term_Cond* traj_set_term_cond_;
  ::machinetalk::Emc_Traj_Set_Spindlesync* traj_set_spindlesync_;
  ::machinetalk::Emc_Traj_Delay* traj_delay_;
  ::machinetalk::Emc_Spindle_On* spindle_on_;
  ::machinetalk::Emc_Spindle_Speed* spindle_speed_;
  ::machinetalk::Emc_Spindle_Orient* spindle_orient_;
  ::machinetalk::Emc_Spindle_Wait_Orient_Complete* spindle_wait_orient_complete_;
  ::machinetalk::Emc_Tool_Set_Offset* tool_set_offet_;
  ::machinetalk::Emc_Traj_Set_Offset* traj_set_offset_;
  ::machinetalk::Emc_Tool_Prepare* tool_prepare_;
  ::machinetalk::Emc_Tool_Set_Number* tool_set_number_;
  ::machinetalk::Emc_Traj_Set_Fo_Enable* traj_set_fo_enable_;
  ::machinetalk::Emc_Traj_Set_So_Enable* traj_set_so_enable_;
  ::machinetalk::Emc_Traj_Set_Fh_Enable* traj_set_fh_enable_;
  ::machinetalk::Emc_Motion_Adaptive* motion_adaptive_;
  ::machinetalk::Emc_Operator_Display* operator_display_;
  ::machinetalk::Emc_Operator_Text* operator_text_;
  ::machinetalk::Emc_Operator_Error* operator_error_;
  ::machinetalk::Emc_Motion_Set_Dout* motion_set_dout_;
  ::machinetalk::Emc_Motion_Set_Aout* motion_set_aout_;
  ::machinetalk::Emc_Aux_Input_Wait* aux_input_wait_;
  ::machinetalk::Emc_Exec_Plugin_Ca1l* exec_plugin_call_;
  ::machinetalk::Emc_Io_Plugin_Call* io_plugin_call_;
  ::machinetalk::EmcStatusConfig* emc_status_config_;
  ::machinetalk::EmcStatusMotion* emc_status_motion_;
  ::machinetalk::EmcStatusIo* emc_status_io_;
  ::machinetalk::EmcStatusTask* emc_status_task_;
  ::machinetalk::EmcStatusInterp* emc_status_interp_;
  ::machinetalk::EmcStatusUI* emc_status_ui_;
  ::machinetalk::EmcCommandParameters* emc_command_params_;
  ::google::protobuf::int64 tsc_;
  ::google::protobuf::int32 tv_sec_;
  ::google::protobuf::int32 tv_nsec_;
  ::google::protobuf::int32 rsvp_;
  ::google::protobuf::int32 serial_;
  bool reply_required_;
  bool trace_;
  ::google::protobuf::int32 reply_serial_;
  ::google::protobuf::int32 ticket_;
  ::google::protobuf::int32 reply_ticket_;
  ::google::protobuf::int32 sequence_;
  ::google::protobuf::int32 credit_;
  ::google::protobuf::int32 line_number_;
  ::google::protobuf::int32 retcode_;
  ::google::protobuf::int32 instance_;
  ::google::protobuf::int32 index_;
  int status_;
  int type_;
  int interp_state_;
  int in_reply_to_;
  int rcs_status_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fmessage_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Container

// required .machinetalk.ContainerType type = 1;
inline bool Container::has_type() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void Container::set_has_type() {
  _has_bits_[2] |= 0x00001000u;
}
inline void Container::clear_has_type() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void Container::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline ::machinetalk::ContainerType Container::type() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.type)
  return static_cast< ::machinetalk::ContainerType >(type_);
}
inline void Container::set_type(::machinetalk::ContainerType value) {
  assert(::machinetalk::ContainerType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.type)
}

// optional sfixed64 tsc = 7;
inline bool Container::has_tsc() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void Container::set_has_tsc() {
  _has_bits_[1] |= 0x08000000u;
}
inline void Container::clear_has_tsc() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void Container::clear_tsc() {
  tsc_ = GOOGLE_LONGLONG(0);
  clear_has_tsc();
}
inline ::google::protobuf::int64 Container::tsc() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.tsc)
  return tsc_;
}
inline void Container::set_tsc(::google::protobuf::int64 value) {
  set_has_tsc();
  tsc_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.tsc)
}

// repeated .machinetalk.Preview preview = 8 [(.nanopb) = {
inline int Container::preview_size() const {
  return preview_.size();
}
inline ::machinetalk::Preview* Container::mutable_preview(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.preview)
  return preview_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Preview >*
Container::mutable_preview() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.preview)
  return &preview_;
}
inline const ::machinetalk::Preview& Container::preview(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.preview)
  return preview_.Get(index);
}
inline ::machinetalk::Preview* Container::add_preview() {
  // @@protoc_insertion_point(field_add:machinetalk.Container.preview)
  return preview_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Preview >&
Container::preview() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.preview)
  return preview_;
}

// optional .machinetalk.MotionCommand motcmd = 9;
inline bool Container::has_motcmd() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Container::set_has_motcmd() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Container::clear_has_motcmd() {
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::machinetalk::MotionCommand& Container::_internal_motcmd() const {
  return *motcmd_;
}
inline const ::machinetalk::MotionCommand& Container::motcmd() const {
  const ::machinetalk::MotionCommand* p = motcmd_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.motcmd)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::MotionCommand*>(
      &::machinetalk::_MotionCommand_default_instance_);
}
inline ::machinetalk::MotionCommand* Container::release_motcmd() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.motcmd)
  clear_has_motcmd();
  ::machinetalk::MotionCommand* temp = motcmd_;
  motcmd_ = NULL;
  return temp;
}
inline ::machinetalk::MotionCommand* Container::mutable_motcmd() {
  set_has_motcmd();
  if (motcmd_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::MotionCommand>(GetArenaNoVirtual());
    motcmd_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.motcmd)
  return motcmd_;
}
inline void Container::set_allocated_motcmd(::machinetalk::MotionCommand* motcmd) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(motcmd_);
  }
  if (motcmd) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      motcmd = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, motcmd, submessage_arena);
    }
    set_has_motcmd();
  } else {
    clear_has_motcmd();
  }
  motcmd_ = motcmd;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.motcmd)
}

// optional .machinetalk.MotionStatus motstat = 10;
inline bool Container::has_motstat() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Container::set_has_motstat() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Container::clear_has_motstat() {
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::machinetalk::MotionStatus& Container::_internal_motstat() const {
  return *motstat_;
}
inline const ::machinetalk::MotionStatus& Container::motstat() const {
  const ::machinetalk::MotionStatus* p = motstat_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.motstat)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::MotionStatus*>(
      &::machinetalk::_MotionStatus_default_instance_);
}
inline ::machinetalk::MotionStatus* Container::release_motstat() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.motstat)
  clear_has_motstat();
  ::machinetalk::MotionStatus* temp = motstat_;
  motstat_ = NULL;
  return temp;
}
inline ::machinetalk::MotionStatus* Container::mutable_motstat() {
  set_has_motstat();
  if (motstat_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::MotionStatus>(GetArenaNoVirtual());
    motstat_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.motstat)
  return motstat_;
}
inline void Container::set_allocated_motstat(::machinetalk::MotionStatus* motstat) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(motstat_);
  }
  if (motstat) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      motstat = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, motstat, submessage_arena);
    }
    set_has_motstat();
  } else {
    clear_has_motstat();
  }
  motstat_ = motstat;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.motstat)
}

// optional bytes legacy_motcmd = 11 [(.nanopb) = {
inline bool Container::has_legacy_motcmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Container::set_has_legacy_motcmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Container::clear_has_legacy_motcmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Container::clear_legacy_motcmd() {
  legacy_motcmd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_legacy_motcmd();
}
inline const ::std::string& Container::legacy_motcmd() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.legacy_motcmd)
  return legacy_motcmd_.GetNoArena();
}
inline void Container::set_legacy_motcmd(const ::std::string& value) {
  set_has_legacy_motcmd();
  legacy_motcmd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Container.legacy_motcmd)
}
#if LANG_CXX11
inline void Container::set_legacy_motcmd(::std::string&& value) {
  set_has_legacy_motcmd();
  legacy_motcmd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Container.legacy_motcmd)
}
#endif
inline void Container::set_legacy_motcmd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_legacy_motcmd();
  legacy_motcmd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Container.legacy_motcmd)
}
inline void Container::set_legacy_motcmd(const void* value, size_t size) {
  set_has_legacy_motcmd();
  legacy_motcmd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Container.legacy_motcmd)
}
inline ::std::string* Container::mutable_legacy_motcmd() {
  set_has_legacy_motcmd();
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.legacy_motcmd)
  return legacy_motcmd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_legacy_motcmd() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.legacy_motcmd)
  if (!has_legacy_motcmd()) {
    return NULL;
  }
  clear_has_legacy_motcmd();
  return legacy_motcmd_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_legacy_motcmd(::std::string* legacy_motcmd) {
  if (legacy_motcmd != NULL) {
    set_has_legacy_motcmd();
  } else {
    clear_has_legacy_motcmd();
  }
  legacy_motcmd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), legacy_motcmd);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.legacy_motcmd)
}

// optional bytes legacy_motstat = 12 [(.nanopb) = {
inline bool Container::has_legacy_motstat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Container::set_has_legacy_motstat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Container::clear_has_legacy_motstat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Container::clear_legacy_motstat() {
  legacy_motstat_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_legacy_motstat();
}
inline const ::std::string& Container::legacy_motstat() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.legacy_motstat)
  return legacy_motstat_.GetNoArena();
}
inline void Container::set_legacy_motstat(const ::std::string& value) {
  set_has_legacy_motstat();
  legacy_motstat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Container.legacy_motstat)
}
#if LANG_CXX11
inline void Container::set_legacy_motstat(::std::string&& value) {
  set_has_legacy_motstat();
  legacy_motstat_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Container.legacy_motstat)
}
#endif
inline void Container::set_legacy_motstat(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_legacy_motstat();
  legacy_motstat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Container.legacy_motstat)
}
inline void Container::set_legacy_motstat(const void* value, size_t size) {
  set_has_legacy_motstat();
  legacy_motstat_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Container.legacy_motstat)
}
inline ::std::string* Container::mutable_legacy_motstat() {
  set_has_legacy_motstat();
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.legacy_motstat)
  return legacy_motstat_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_legacy_motstat() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.legacy_motstat)
  if (!has_legacy_motstat()) {
    return NULL;
  }
  clear_has_legacy_motstat();
  return legacy_motstat_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_legacy_motstat(::std::string* legacy_motstat) {
  if (legacy_motstat != NULL) {
    set_has_legacy_motstat();
  } else {
    clear_has_legacy_motstat();
  }
  legacy_motstat_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), legacy_motstat);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.legacy_motstat)
}

// optional .machinetalk.RTAPI_Message rtapi_message = 13;
inline bool Container::has_rtapi_message() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Container::set_has_rtapi_message() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Container::clear_has_rtapi_message() {
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::machinetalk::RTAPI_Message& Container::_internal_rtapi_message() const {
  return *rtapi_message_;
}
inline const ::machinetalk::RTAPI_Message& Container::rtapi_message() const {
  const ::machinetalk::RTAPI_Message* p = rtapi_message_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.rtapi_message)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::RTAPI_Message*>(
      &::machinetalk::_RTAPI_Message_default_instance_);
}
inline ::machinetalk::RTAPI_Message* Container::release_rtapi_message() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.rtapi_message)
  clear_has_rtapi_message();
  ::machinetalk::RTAPI_Message* temp = rtapi_message_;
  rtapi_message_ = NULL;
  return temp;
}
inline ::machinetalk::RTAPI_Message* Container::mutable_rtapi_message() {
  set_has_rtapi_message();
  if (rtapi_message_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::RTAPI_Message>(GetArenaNoVirtual());
    rtapi_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.rtapi_message)
  return rtapi_message_;
}
inline void Container::set_allocated_rtapi_message(::machinetalk::RTAPI_Message* rtapi_message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(rtapi_message_);
  }
  if (rtapi_message) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rtapi_message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rtapi_message, submessage_arena);
    }
    set_has_rtapi_message();
  } else {
    clear_has_rtapi_message();
  }
  rtapi_message_ = rtapi_message;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.rtapi_message)
}

// optional .machinetalk.TaskReply task_reply = 14 [(.nanopb) = {
inline bool Container::has_task_reply() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Container::set_has_task_reply() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Container::clear_has_task_reply() {
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::machinetalk::TaskReply& Container::_internal_task_reply() const {
  return *task_reply_;
}
inline const ::machinetalk::TaskReply& Container::task_reply() const {
  const ::machinetalk::TaskReply* p = task_reply_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.task_reply)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::TaskReply*>(
      &::machinetalk::_TaskReply_default_instance_);
}
inline ::machinetalk::TaskReply* Container::release_task_reply() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.task_reply)
  clear_has_task_reply();
  ::machinetalk::TaskReply* temp = task_reply_;
  task_reply_ = NULL;
  return temp;
}
inline ::machinetalk::TaskReply* Container::mutable_task_reply() {
  set_has_task_reply();
  if (task_reply_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::TaskReply>(GetArenaNoVirtual());
    task_reply_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.task_reply)
  return task_reply_;
}
inline void Container::set_allocated_task_reply(::machinetalk::TaskReply* task_reply) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(task_reply_);
  }
  if (task_reply) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      task_reply = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_reply, submessage_arena);
    }
    set_has_task_reply();
  } else {
    clear_has_task_reply();
  }
  task_reply_ = task_reply;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.task_reply)
}

// optional .machinetalk.TicketUpdate ticket_update = 15;
inline bool Container::has_ticket_update() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Container::set_has_ticket_update() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Container::clear_has_ticket_update() {
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::machinetalk::TicketUpdate& Container::_internal_ticket_update() const {
  return *ticket_update_;
}
inline const ::machinetalk::TicketUpdate& Container::ticket_update() const {
  const ::machinetalk::TicketUpdate* p = ticket_update_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.ticket_update)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::TicketUpdate*>(
      &::machinetalk::_TicketUpdate_default_instance_);
}
inline ::machinetalk::TicketUpdate* Container::release_ticket_update() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.ticket_update)
  clear_has_ticket_update();
  ::machinetalk::TicketUpdate* temp = ticket_update_;
  ticket_update_ = NULL;
  return temp;
}
inline ::machinetalk::TicketUpdate* Container::mutable_ticket_update() {
  set_has_ticket_update();
  if (ticket_update_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::TicketUpdate>(GetArenaNoVirtual());
    ticket_update_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.ticket_update)
  return ticket_update_;
}
inline void Container::set_allocated_ticket_update(::machinetalk::TicketUpdate* ticket_update) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ticket_update_);
  }
  if (ticket_update) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ticket_update = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ticket_update, submessage_arena);
    }
    set_has_ticket_update();
  } else {
    clear_has_ticket_update();
  }
  ticket_update_ = ticket_update;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.ticket_update)
}

// optional bytes syslog = 18 [(.nanopb) = {
inline bool Container::has_syslog() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Container::set_has_syslog() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Container::clear_has_syslog() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Container::clear_syslog() {
  syslog_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_syslog();
}
inline const ::std::string& Container::syslog() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.syslog)
  return syslog_.GetNoArena();
}
inline void Container::set_syslog(const ::std::string& value) {
  set_has_syslog();
  syslog_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Container.syslog)
}
#if LANG_CXX11
inline void Container::set_syslog(::std::string&& value) {
  set_has_syslog();
  syslog_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Container.syslog)
}
#endif
inline void Container::set_syslog(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_syslog();
  syslog_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Container.syslog)
}
inline void Container::set_syslog(const void* value, size_t size) {
  set_has_syslog();
  syslog_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Container.syslog)
}
inline ::std::string* Container::mutable_syslog() {
  set_has_syslog();
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.syslog)
  return syslog_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_syslog() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.syslog)
  if (!has_syslog()) {
    return NULL;
  }
  clear_has_syslog();
  return syslog_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_syslog(::std::string* syslog) {
  if (syslog != NULL) {
    set_has_syslog();
  } else {
    clear_has_syslog();
  }
  syslog_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), syslog);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.syslog)
}

// optional bytes legacy_nml = 19 [(.nanopb) = {
inline bool Container::has_legacy_nml() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Container::set_has_legacy_nml() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Container::clear_has_legacy_nml() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Container::clear_legacy_nml() {
  legacy_nml_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_legacy_nml();
}
inline const ::std::string& Container::legacy_nml() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.legacy_nml)
  return legacy_nml_.GetNoArena();
}
inline void Container::set_legacy_nml(const ::std::string& value) {
  set_has_legacy_nml();
  legacy_nml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Container.legacy_nml)
}
#if LANG_CXX11
inline void Container::set_legacy_nml(::std::string&& value) {
  set_has_legacy_nml();
  legacy_nml_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Container.legacy_nml)
}
#endif
inline void Container::set_legacy_nml(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_legacy_nml();
  legacy_nml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Container.legacy_nml)
}
inline void Container::set_legacy_nml(const void* value, size_t size) {
  set_has_legacy_nml();
  legacy_nml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Container.legacy_nml)
}
inline ::std::string* Container::mutable_legacy_nml() {
  set_has_legacy_nml();
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.legacy_nml)
  return legacy_nml_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_legacy_nml() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.legacy_nml)
  if (!has_legacy_nml()) {
    return NULL;
  }
  clear_has_legacy_nml();
  return legacy_nml_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_legacy_nml(::std::string* legacy_nml) {
  if (legacy_nml != NULL) {
    set_has_legacy_nml();
  } else {
    clear_has_legacy_nml();
  }
  legacy_nml_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), legacy_nml);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.legacy_nml)
}

// optional bytes legacy_motconfig = 20 [(.nanopb) = {
inline bool Container::has_legacy_motconfig() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Container::set_has_legacy_motconfig() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Container::clear_has_legacy_motconfig() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Container::clear_legacy_motconfig() {
  legacy_motconfig_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_legacy_motconfig();
}
inline const ::std::string& Container::legacy_motconfig() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.legacy_motconfig)
  return legacy_motconfig_.GetNoArena();
}
inline void Container::set_legacy_motconfig(const ::std::string& value) {
  set_has_legacy_motconfig();
  legacy_motconfig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Container.legacy_motconfig)
}
#if LANG_CXX11
inline void Container::set_legacy_motconfig(::std::string&& value) {
  set_has_legacy_motconfig();
  legacy_motconfig_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Container.legacy_motconfig)
}
#endif
inline void Container::set_legacy_motconfig(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_legacy_motconfig();
  legacy_motconfig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Container.legacy_motconfig)
}
inline void Container::set_legacy_motconfig(const void* value, size_t size) {
  set_has_legacy_motconfig();
  legacy_motconfig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Container.legacy_motconfig)
}
inline ::std::string* Container::mutable_legacy_motconfig() {
  set_has_legacy_motconfig();
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.legacy_motconfig)
  return legacy_motconfig_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_legacy_motconfig() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.legacy_motconfig)
  if (!has_legacy_motconfig()) {
    return NULL;
  }
  clear_has_legacy_motconfig();
  return legacy_motconfig_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_legacy_motconfig(::std::string* legacy_motconfig) {
  if (legacy_motconfig != NULL) {
    set_has_legacy_motconfig();
  } else {
    clear_has_legacy_motconfig();
  }
  legacy_motconfig_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), legacy_motconfig);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.legacy_motconfig)
}

// optional int32 tv_sec = 21;
inline bool Container::has_tv_sec() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void Container::set_has_tv_sec() {
  _has_bits_[1] |= 0x10000000u;
}
inline void Container::clear_has_tv_sec() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void Container::clear_tv_sec() {
  tv_sec_ = 0;
  clear_has_tv_sec();
}
inline ::google::protobuf::int32 Container::tv_sec() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.tv_sec)
  return tv_sec_;
}
inline void Container::set_tv_sec(::google::protobuf::int32 value) {
  set_has_tv_sec();
  tv_sec_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.tv_sec)
}

// optional int32 tv_nsec = 22;
inline bool Container::has_tv_nsec() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void Container::set_has_tv_nsec() {
  _has_bits_[1] |= 0x20000000u;
}
inline void Container::clear_has_tv_nsec() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void Container::clear_tv_nsec() {
  tv_nsec_ = 0;
  clear_has_tv_nsec();
}
inline ::google::protobuf::int32 Container::tv_nsec() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.tv_nsec)
  return tv_nsec_;
}
inline void Container::set_tv_nsec(::google::protobuf::int32 value) {
  set_has_tv_nsec();
  tv_nsec_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.tv_nsec)
}

// optional string topic = 23;
inline bool Container::has_topic() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Container::set_has_topic() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Container::clear_has_topic() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Container::clear_topic() {
  topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic();
}
inline const ::std::string& Container::topic() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.topic)
  return topic_.GetNoArena();
}
inline void Container::set_topic(const ::std::string& value) {
  set_has_topic();
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Container.topic)
}
#if LANG_CXX11
inline void Container::set_topic(::std::string&& value) {
  set_has_topic();
  topic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Container.topic)
}
#endif
inline void Container::set_topic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_topic();
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Container.topic)
}
inline void Container::set_topic(const char* value, size_t size) {
  set_has_topic();
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Container.topic)
}
inline ::std::string* Container::mutable_topic() {
  set_has_topic();
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.topic)
  return topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_topic() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.topic)
  if (!has_topic()) {
    return NULL;
  }
  clear_has_topic();
  return topic_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_topic(::std::string* topic) {
  if (topic != NULL) {
    set_has_topic();
  } else {
    clear_has_topic();
  }
  topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.topic)
}

// optional bool reply_required = 24;
inline bool Container::has_reply_required() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void Container::set_has_reply_required() {
  _has_bits_[2] |= 0x00000001u;
}
inline void Container::clear_has_reply_required() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void Container::clear_reply_required() {
  reply_required_ = false;
  clear_has_reply_required();
}
inline bool Container::reply_required() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.reply_required)
  return reply_required_;
}
inline void Container::set_reply_required(bool value) {
  set_has_reply_required();
  reply_required_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.reply_required)
}

// optional .machinetalk.InterpreterStateType interp_state = 25 [(.nanopb) = {
inline bool Container::has_interp_state() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void Container::set_has_interp_state() {
  _has_bits_[2] |= 0x00002000u;
}
inline void Container::clear_has_interp_state() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void Container::clear_interp_state() {
  interp_state_ = 1;
  clear_has_interp_state();
}
inline ::machinetalk::InterpreterStateType Container::interp_state() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.interp_state)
  return static_cast< ::machinetalk::InterpreterStateType >(interp_state_);
}
inline void Container::set_interp_state(::machinetalk::InterpreterStateType value) {
  assert(::machinetalk::InterpreterStateType_IsValid(value));
  set_has_interp_state();
  interp_state_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.interp_state)
}

// optional string interp_name = 26;
inline bool Container::has_interp_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Container::set_has_interp_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Container::clear_has_interp_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Container::clear_interp_name() {
  interp_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_interp_name();
}
inline const ::std::string& Container::interp_name() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.interp_name)
  return interp_name_.GetNoArena();
}
inline void Container::set_interp_name(const ::std::string& value) {
  set_has_interp_name();
  interp_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Container.interp_name)
}
#if LANG_CXX11
inline void Container::set_interp_name(::std::string&& value) {
  set_has_interp_name();
  interp_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Container.interp_name)
}
#endif
inline void Container::set_interp_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_interp_name();
  interp_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Container.interp_name)
}
inline void Container::set_interp_name(const char* value, size_t size) {
  set_has_interp_name();
  interp_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Container.interp_name)
}
inline ::std::string* Container::mutable_interp_name() {
  set_has_interp_name();
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.interp_name)
  return interp_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_interp_name() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.interp_name)
  if (!has_interp_name()) {
    return NULL;
  }
  clear_has_interp_name();
  return interp_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_interp_name(::std::string* interp_name) {
  if (interp_name != NULL) {
    set_has_interp_name();
  } else {
    clear_has_interp_name();
  }
  interp_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), interp_name);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.interp_name)
}

// optional int32 rsvp = 30;
inline bool Container::has_rsvp() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void Container::set_has_rsvp() {
  _has_bits_[1] |= 0x40000000u;
}
inline void Container::clear_has_rsvp() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void Container::clear_rsvp() {
  rsvp_ = 0;
  clear_has_rsvp();
}
inline ::google::protobuf::int32 Container::rsvp() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.rsvp)
  return rsvp_;
}
inline void Container::set_rsvp(::google::protobuf::int32 value) {
  set_has_rsvp();
  rsvp_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.rsvp)
}

// optional .machinetalk.ContainerType in_reply_to = 33;
inline bool Container::has_in_reply_to() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void Container::set_has_in_reply_to() {
  _has_bits_[2] |= 0x00004000u;
}
inline void Container::clear_has_in_reply_to() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void Container::clear_in_reply_to() {
  in_reply_to_ = 2;
  clear_has_in_reply_to();
}
inline ::machinetalk::ContainerType Container::in_reply_to() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.in_reply_to)
  return static_cast< ::machinetalk::ContainerType >(in_reply_to_);
}
inline void Container::set_in_reply_to(::machinetalk::ContainerType value) {
  assert(::machinetalk::ContainerType_IsValid(value));
  set_has_in_reply_to();
  in_reply_to_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.in_reply_to)
}

// optional .machinetalk.RCS_STATUS rcs_status = 35;
inline bool Container::has_rcs_status() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void Container::set_has_rcs_status() {
  _has_bits_[2] |= 0x00008000u;
}
inline void Container::clear_has_rcs_status() {
  _has_bits_[2] &= ~0x00008000u;
}
inline void Container::clear_rcs_status() {
  rcs_status_ = -1;
  clear_has_rcs_status();
}
inline ::machinetalk::RCS_STATUS Container::rcs_status() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.rcs_status)
  return static_cast< ::machinetalk::RCS_STATUS >(rcs_status_);
}
inline void Container::set_rcs_status(::machinetalk::RCS_STATUS value) {
  assert(::machinetalk::RCS_STATUS_IsValid(value));
  set_has_rcs_status();
  rcs_status_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.rcs_status)
}

// optional .machinetalk.StatusType status = 40;
inline bool Container::has_status() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void Container::set_has_status() {
  _has_bits_[2] |= 0x00000800u;
}
inline void Container::clear_has_status() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void Container::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::machinetalk::StatusType Container::status() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.status)
  return static_cast< ::machinetalk::StatusType >(status_);
}
inline void Container::set_status(::machinetalk::StatusType value) {
  assert(::machinetalk::StatusType_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.status)
}

// optional int32 serial = 45;
inline bool Container::has_serial() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void Container::set_has_serial() {
  _has_bits_[1] |= 0x80000000u;
}
inline void Container::clear_has_serial() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void Container::clear_serial() {
  serial_ = 0;
  clear_has_serial();
}
inline ::google::protobuf::int32 Container::serial() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.serial)
  return serial_;
}
inline void Container::set_serial(::google::protobuf::int32 value) {
  set_has_serial();
  serial_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.serial)
}

// optional int32 reply_serial = 50;
inline bool Container::has_reply_serial() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void Container::set_has_reply_serial() {
  _has_bits_[2] |= 0x00000004u;
}
inline void Container::clear_has_reply_serial() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void Container::clear_reply_serial() {
  reply_serial_ = 0;
  clear_has_reply_serial();
}
inline ::google::protobuf::int32 Container::reply_serial() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.reply_serial)
  return reply_serial_;
}
inline void Container::set_reply_serial(::google::protobuf::int32 value) {
  set_has_reply_serial();
  reply_serial_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.reply_serial)
}

// optional int32 ticket = 55;
inline bool Container::has_ticket() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void Container::set_has_ticket() {
  _has_bits_[2] |= 0x00000008u;
}
inline void Container::clear_has_ticket() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void Container::clear_ticket() {
  ticket_ = 0;
  clear_has_ticket();
}
inline ::google::protobuf::int32 Container::ticket() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.ticket)
  return ticket_;
}
inline void Container::set_ticket(::google::protobuf::int32 value) {
  set_has_ticket();
  ticket_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.ticket)
}

// optional int32 reply_ticket = 60;
inline bool Container::has_reply_ticket() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void Container::set_has_reply_ticket() {
  _has_bits_[2] |= 0x00000010u;
}
inline void Container::clear_has_reply_ticket() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void Container::clear_reply_ticket() {
  reply_ticket_ = 0;
  clear_has_reply_ticket();
}
inline ::google::protobuf::int32 Container::reply_ticket() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.reply_ticket)
  return reply_ticket_;
}
inline void Container::set_reply_ticket(::google::protobuf::int32 value) {
  set_has_reply_ticket();
  reply_ticket_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.reply_ticket)
}

// optional int32 sequence = 62;
inline bool Container::has_sequence() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void Container::set_has_sequence() {
  _has_bits_[2] |= 0x00000020u;
}
inline void Container::clear_has_sequence() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void Container::clear_sequence() {
  sequence_ = 0;
  clear_has_sequence();
}
inline ::google::protobuf::int32 Container::sequence() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.sequence)
  return sequence_;
}
inline void Container::set_sequence(::google::protobuf::int32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.sequence)
}

// optional int32 credit = 65;
inline bool Container::has_credit() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void Container::set_has_credit() {
  _has_bits_[2] |= 0x00000040u;
}
inline void Container::clear_has_credit() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void Container::clear_credit() {
  credit_ = 0;
  clear_has_credit();
}
inline ::google::protobuf::int32 Container::credit() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.credit)
  return credit_;
}
inline void Container::set_credit(::google::protobuf::int32 value) {
  set_has_credit();
  credit_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.credit)
}

// optional int32 line_number = 66;
inline bool Container::has_line_number() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void Container::set_has_line_number() {
  _has_bits_[2] |= 0x00000080u;
}
inline void Container::clear_has_line_number() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void Container::clear_line_number() {
  line_number_ = 0;
  clear_has_line_number();
}
inline ::google::protobuf::int32 Container::line_number() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.line_number)
  return line_number_;
}
inline void Container::set_line_number(::google::protobuf::int32 value) {
  set_has_line_number();
  line_number_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.line_number)
}

// optional string name = 67 [(.nanopb) = {
inline bool Container::has_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Container::set_has_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Container::clear_has_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Container::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Container::name() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.name)
  return name_.GetNoArena();
}
inline void Container::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Container.name)
}
#if LANG_CXX11
inline void Container::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Container.name)
}
#endif
inline void Container::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Container.name)
}
inline void Container::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Container.name)
}
inline ::std::string* Container::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_name() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.name)
}

// repeated string note = 68;
inline int Container::note_size() const {
  return note_.size();
}
inline void Container::clear_note() {
  note_.Clear();
}
inline const ::std::string& Container::note(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.note)
  return note_.Get(index);
}
inline ::std::string* Container::mutable_note(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.note)
  return note_.Mutable(index);
}
inline void Container::set_note(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:machinetalk.Container.note)
  note_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Container::set_note(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:machinetalk.Container.note)
  note_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Container::set_note(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  note_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:machinetalk.Container.note)
}
inline void Container::set_note(int index, const char* value, size_t size) {
  note_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Container.note)
}
inline ::std::string* Container::add_note() {
  // @@protoc_insertion_point(field_add_mutable:machinetalk.Container.note)
  return note_.Add();
}
inline void Container::add_note(const ::std::string& value) {
  note_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:machinetalk.Container.note)
}
#if LANG_CXX11
inline void Container::add_note(::std::string&& value) {
  note_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:machinetalk.Container.note)
}
#endif
inline void Container::add_note(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  note_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:machinetalk.Container.note)
}
inline void Container::add_note(const char* value, size_t size) {
  note_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:machinetalk.Container.note)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Container::note() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.note)
  return note_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Container::mutable_note() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.note)
  return &note_;
}

// optional int32 retcode = 69;
inline bool Container::has_retcode() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void Container::set_has_retcode() {
  _has_bits_[2] |= 0x00000100u;
}
inline void Container::clear_has_retcode() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void Container::clear_retcode() {
  retcode_ = 0;
  clear_has_retcode();
}
inline ::google::protobuf::int32 Container::retcode() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.retcode)
  return retcode_;
}
inline void Container::set_retcode(::google::protobuf::int32 value) {
  set_has_retcode();
  retcode_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.retcode)
}

// optional bytes uuid = 72 [(.nanopb) = {
inline bool Container::has_uuid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Container::set_has_uuid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Container::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Container::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uuid();
}
inline const ::std::string& Container::uuid() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.uuid)
  return uuid_.GetNoArena();
}
inline void Container::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Container.uuid)
}
#if LANG_CXX11
inline void Container::set_uuid(::std::string&& value) {
  set_has_uuid();
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Container.uuid)
}
#endif
inline void Container::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Container.uuid)
}
inline void Container::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Container.uuid)
}
inline ::std::string* Container::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Container::release_uuid() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.uuid)
  if (!has_uuid()) {
    return NULL;
  }
  clear_has_uuid();
  return uuid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Container::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.uuid)
}

// optional bool trace = 75;
inline bool Container::has_trace() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void Container::set_has_trace() {
  _has_bits_[2] |= 0x00000002u;
}
inline void Container::clear_has_trace() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void Container::clear_trace() {
  trace_ = false;
  clear_has_trace();
}
inline bool Container::trace() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.trace)
  return trace_;
}
inline void Container::set_trace(bool value) {
  set_has_trace();
  trace_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.trace)
}

// optional int32 instance = 77;
inline bool Container::has_instance() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void Container::set_has_instance() {
  _has_bits_[2] |= 0x00000200u;
}
inline void Container::clear_has_instance() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void Container::clear_instance() {
  instance_ = 0;
  clear_has_instance();
}
inline ::google::protobuf::int32 Container::instance() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.instance)
  return instance_;
}
inline void Container::set_instance(::google::protobuf::int32 value) {
  set_has_instance();
  instance_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.instance)
}

// repeated .machinetalk.Value value = 85 [(.nanopb) = {
inline int Container::value_size() const {
  return value_.size();
}
inline ::machinetalk::Value* Container::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.value)
  return value_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Value >*
Container::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.value)
  return &value_;
}
inline const ::machinetalk::Value& Container::value(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.value)
  return value_.Get(index);
}
inline ::machinetalk::Value* Container::add_value() {
  // @@protoc_insertion_point(field_add:machinetalk.Container.value)
  return value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Value >&
Container::value() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.value)
  return value_;
}

// optional .machinetalk.RTAPICommand rtapicmd = 86 [(.nanopb) = {
inline bool Container::has_rtapicmd() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Container::set_has_rtapicmd() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Container::clear_has_rtapicmd() {
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::machinetalk::RTAPICommand& Container::_internal_rtapicmd() const {
  return *rtapicmd_;
}
inline const ::machinetalk::RTAPICommand& Container::rtapicmd() const {
  const ::machinetalk::RTAPICommand* p = rtapicmd_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.rtapicmd)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::RTAPICommand*>(
      &::machinetalk::_RTAPICommand_default_instance_);
}
inline ::machinetalk::RTAPICommand* Container::release_rtapicmd() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.rtapicmd)
  clear_has_rtapicmd();
  ::machinetalk::RTAPICommand* temp = rtapicmd_;
  rtapicmd_ = NULL;
  return temp;
}
inline ::machinetalk::RTAPICommand* Container::mutable_rtapicmd() {
  set_has_rtapicmd();
  if (rtapicmd_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::RTAPICommand>(GetArenaNoVirtual());
    rtapicmd_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.rtapicmd)
  return rtapicmd_;
}
inline void Container::set_allocated_rtapicmd(::machinetalk::RTAPICommand* rtapicmd) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(rtapicmd_);
  }
  if (rtapicmd) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rtapicmd = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rtapicmd, submessage_arena);
    }
    set_has_rtapicmd();
  } else {
    clear_has_rtapicmd();
  }
  rtapicmd_ = rtapicmd;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.rtapicmd)
}

// repeated .machinetalk.ServiceAnnouncement service_announcement = 88 [(.nanopb) = {
inline int Container::service_announcement_size() const {
  return service_announcement_.size();
}
inline ::machinetalk::ServiceAnnouncement* Container::mutable_service_announcement(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.service_announcement)
  return service_announcement_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::ServiceAnnouncement >*
Container::mutable_service_announcement() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.service_announcement)
  return &service_announcement_;
}
inline const ::machinetalk::ServiceAnnouncement& Container::service_announcement(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.service_announcement)
  return service_announcement_.Get(index);
}
inline ::machinetalk::ServiceAnnouncement* Container::add_service_announcement() {
  // @@protoc_insertion_point(field_add:machinetalk.Container.service_announcement)
  return service_announcement_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::ServiceAnnouncement >&
Container::service_announcement() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.service_announcement)
  return service_announcement_;
}

// repeated .machinetalk.Component comp = 100 [(.nanopb) = {
inline int Container::comp_size() const {
  return comp_.size();
}
inline ::machinetalk::Component* Container::mutable_comp(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.comp)
  return comp_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Component >*
Container::mutable_comp() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.comp)
  return &comp_;
}
inline const ::machinetalk::Component& Container::comp(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.comp)
  return comp_.Get(index);
}
inline ::machinetalk::Component* Container::add_comp() {
  // @@protoc_insertion_point(field_add:machinetalk.Container.comp)
  return comp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Component >&
Container::comp() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.comp)
  return comp_;
}

// repeated .machinetalk.Pin pin = 2 [(.nanopb) = {
inline int Container::pin_size() const {
  return pin_.size();
}
inline ::machinetalk::Pin* Container::mutable_pin(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.pin)
  return pin_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Pin >*
Container::mutable_pin() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.pin)
  return &pin_;
}
inline const ::machinetalk::Pin& Container::pin(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.pin)
  return pin_.Get(index);
}
inline ::machinetalk::Pin* Container::add_pin() {
  // @@protoc_insertion_point(field_add:machinetalk.Container.pin)
  return pin_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Pin >&
Container::pin() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.pin)
  return pin_;
}

// repeated .machinetalk.Signal signal = 3 [(.nanopb) = {
inline int Container::signal_size() const {
  return signal_.size();
}
inline ::machinetalk::Signal* Container::mutable_signal(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.signal)
  return signal_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Signal >*
Container::mutable_signal() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.signal)
  return &signal_;
}
inline const ::machinetalk::Signal& Container::signal(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.signal)
  return signal_.Get(index);
}
inline ::machinetalk::Signal* Container::add_signal() {
  // @@protoc_insertion_point(field_add:machinetalk.Container.signal)
  return signal_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Signal >&
Container::signal() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.signal)
  return signal_;
}

// repeated .machinetalk.Param param = 103 [(.nanopb) = {
inline int Container::param_size() const {
  return param_.size();
}
inline ::machinetalk::Param* Container::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.param)
  return param_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Param >*
Container::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.param)
  return &param_;
}
inline const ::machinetalk::Param& Container::param(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.param)
  return param_.Get(index);
}
inline ::machinetalk::Param* Container::add_param() {
  // @@protoc_insertion_point(field_add:machinetalk.Container.param)
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Param >&
Container::param() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.param)
  return param_;
}

// repeated .machinetalk.Thread thread = 104 [(.nanopb) = {
inline int Container::thread_size() const {
  return thread_.size();
}
inline ::machinetalk::Thread* Container::mutable_thread(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.thread)
  return thread_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Thread >*
Container::mutable_thread() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.thread)
  return &thread_;
}
inline const ::machinetalk::Thread& Container::thread(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.thread)
  return thread_.Get(index);
}
inline ::machinetalk::Thread* Container::add_thread() {
  // @@protoc_insertion_point(field_add:machinetalk.Container.thread)
  return thread_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Thread >&
Container::thread() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.thread)
  return thread_;
}

// repeated .machinetalk.Ring ring = 105 [(.nanopb) = {
inline int Container::ring_size() const {
  return ring_.size();
}
inline ::machinetalk::Ring* Container::mutable_ring(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.ring)
  return ring_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Ring >*
Container::mutable_ring() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.ring)
  return &ring_;
}
inline const ::machinetalk::Ring& Container::ring(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.ring)
  return ring_.Get(index);
}
inline ::machinetalk::Ring* Container::add_ring() {
  // @@protoc_insertion_point(field_add:machinetalk.Container.ring)
  return ring_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Ring >&
Container::ring() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.ring)
  return ring_;
}

// repeated .machinetalk.Group group = 106 [(.nanopb) = {
inline int Container::group_size() const {
  return group_.size();
}
inline ::machinetalk::Group* Container::mutable_group(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.group)
  return group_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Group >*
Container::mutable_group() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.group)
  return &group_;
}
inline const ::machinetalk::Group& Container::group(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.group)
  return group_.Get(index);
}
inline ::machinetalk::Group* Container::add_group() {
  // @@protoc_insertion_point(field_add:machinetalk.Container.group)
  return group_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Group >&
Container::group() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.group)
  return group_;
}

// repeated .machinetalk.Member member = 107 [(.nanopb) = {
inline int Container::member_size() const {
  return member_.size();
}
inline ::machinetalk::Member* Container::mutable_member(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.member)
  return member_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Member >*
Container::mutable_member() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.member)
  return &member_;
}
inline const ::machinetalk::Member& Container::member(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.member)
  return member_.Get(index);
}
inline ::machinetalk::Member* Container::add_member() {
  // @@protoc_insertion_point(field_add:machinetalk.Container.member)
  return member_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Member >&
Container::member() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.member)
  return member_;
}

// repeated .machinetalk.Function function = 108 [(.nanopb) = {
inline int Container::function_size() const {
  return function_.size();
}
inline ::machinetalk::Function* Container::mutable_function(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.function)
  return function_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Function >*
Container::mutable_function() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.function)
  return &function_;
}
inline const ::machinetalk::Function& Container::function(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.function)
  return function_.Get(index);
}
inline ::machinetalk::Function* Container::add_function() {
  // @@protoc_insertion_point(field_add:machinetalk.Container.function)
  return function_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Function >&
Container::function() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.function)
  return function_;
}

// optional .machinetalk.ProtocolParameters pparams = 109 [(.nanopb) = {
inline bool Container::has_pparams() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Container::set_has_pparams() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Container::clear_has_pparams() {
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::machinetalk::ProtocolParameters& Container::_internal_pparams() const {
  return *pparams_;
}
inline const ::machinetalk::ProtocolParameters& Container::pparams() const {
  const ::machinetalk::ProtocolParameters* p = pparams_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.pparams)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::ProtocolParameters*>(
      &::machinetalk::_ProtocolParameters_default_instance_);
}
inline ::machinetalk::ProtocolParameters* Container::release_pparams() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.pparams)
  clear_has_pparams();
  ::machinetalk::ProtocolParameters* temp = pparams_;
  pparams_ = NULL;
  return temp;
}
inline ::machinetalk::ProtocolParameters* Container::mutable_pparams() {
  set_has_pparams();
  if (pparams_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::ProtocolParameters>(GetArenaNoVirtual());
    pparams_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.pparams)
  return pparams_;
}
inline void Container::set_allocated_pparams(::machinetalk::ProtocolParameters* pparams) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pparams_);
  }
  if (pparams) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pparams = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pparams, submessage_arena);
    }
    set_has_pparams();
  } else {
    clear_has_pparams();
  }
  pparams_ = pparams;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.pparams)
}

// repeated .machinetalk.Vtable vtable = 110 [(.nanopb) = {
inline int Container::vtable_size() const {
  return vtable_.size();
}
inline ::machinetalk::Vtable* Container::mutable_vtable(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.vtable)
  return vtable_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Vtable >*
Container::mutable_vtable() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.vtable)
  return &vtable_;
}
inline const ::machinetalk::Vtable& Container::vtable(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.vtable)
  return vtable_.Get(index);
}
inline ::machinetalk::Vtable* Container::add_vtable() {
  // @@protoc_insertion_point(field_add:machinetalk.Container.vtable)
  return vtable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Vtable >&
Container::vtable() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.vtable)
  return vtable_;
}

// repeated .machinetalk.Inst inst = 111 [(.nanopb) = {
inline int Container::inst_size() const {
  return inst_.size();
}
inline ::machinetalk::Inst* Container::mutable_inst(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.inst)
  return inst_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Inst >*
Container::mutable_inst() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.inst)
  return &inst_;
}
inline const ::machinetalk::Inst& Container::inst(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.inst)
  return inst_.Get(index);
}
inline ::machinetalk::Inst* Container::add_inst() {
  // @@protoc_insertion_point(field_add:machinetalk.Container.inst)
  return inst_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Inst >&
Container::inst() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.inst)
  return inst_;
}

// repeated .machinetalk.Application app = 120 [(.nanopb) = {
inline int Container::app_size() const {
  return app_.size();
}
inline ::machinetalk::Application* Container::mutable_app(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.app)
  return app_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Application >*
Container::mutable_app() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.app)
  return &app_;
}
inline const ::machinetalk::Application& Container::app(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.app)
  return app_.Get(index);
}
inline ::machinetalk::Application* Container::add_app() {
  // @@protoc_insertion_point(field_add:machinetalk.Container.app)
  return app_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Application >&
Container::app() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.app)
  return app_;
}

// repeated .machinetalk.Launcher launcher = 130 [(.nanopb) = {
inline int Container::launcher_size() const {
  return launcher_.size();
}
inline ::machinetalk::Launcher* Container::mutable_launcher(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.launcher)
  return launcher_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Launcher >*
Container::mutable_launcher() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Container.launcher)
  return &launcher_;
}
inline const ::machinetalk::Launcher& Container::launcher(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.launcher)
  return launcher_.Get(index);
}
inline ::machinetalk::Launcher* Container::add_launcher() {
  // @@protoc_insertion_point(field_add:machinetalk.Container.launcher)
  return launcher_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Launcher >&
Container::launcher() const {
  // @@protoc_insertion_point(field_list:machinetalk.Container.launcher)
  return launcher_;
}

// optional int32 index = 131 [(.nanopb) = {
inline bool Container::has_index() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void Container::set_has_index() {
  _has_bits_[2] |= 0x00000400u;
}
inline void Container::clear_has_index() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void Container::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 Container::index() const {
  // @@protoc_insertion_point(field_get:machinetalk.Container.index)
  return index_;
}
inline void Container::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Container.index)
}

// optional .machinetalk.LogMessage log_message = 87 [(.nanopb) = {
inline bool Container::has_log_message() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Container::set_has_log_message() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Container::clear_has_log_message() {
  _has_bits_[0] &= ~0x00008000u;
}
inline const ::machinetalk::LogMessage& Container::_internal_log_message() const {
  return *log_message_;
}
inline const ::machinetalk::LogMessage& Container::log_message() const {
  const ::machinetalk::LogMessage* p = log_message_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.log_message)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::LogMessage*>(
      &::machinetalk::_LogMessage_default_instance_);
}
inline ::machinetalk::LogMessage* Container::release_log_message() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.log_message)
  clear_has_log_message();
  ::machinetalk::LogMessage* temp = log_message_;
  log_message_ = NULL;
  return temp;
}
inline ::machinetalk::LogMessage* Container::mutable_log_message() {
  set_has_log_message();
  if (log_message_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::LogMessage>(GetArenaNoVirtual());
    log_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.log_message)
  return log_message_;
}
inline void Container::set_allocated_log_message(::machinetalk::LogMessage* log_message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(log_message_);
  }
  if (log_message) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      log_message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, log_message, submessage_arena);
    }
    set_has_log_message();
  } else {
    clear_has_log_message();
  }
  log_message_ = log_message;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.log_message)
}

// optional .machinetalk.TaskPlanExecute tpexecute = 200 [(.nanopb) = {
inline bool Container::has_tpexecute() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Container::set_has_tpexecute() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Container::clear_has_tpexecute() {
  _has_bits_[0] &= ~0x00020000u;
}
inline const ::machinetalk::TaskPlanExecute& Container::_internal_tpexecute() const {
  return *tpexecute_;
}
inline const ::machinetalk::TaskPlanExecute& Container::tpexecute() const {
  const ::machinetalk::TaskPlanExecute* p = tpexecute_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.tpexecute)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::TaskPlanExecute*>(
      &::machinetalk::_TaskPlanExecute_default_instance_);
}
inline ::machinetalk::TaskPlanExecute* Container::release_tpexecute() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.tpexecute)
  clear_has_tpexecute();
  ::machinetalk::TaskPlanExecute* temp = tpexecute_;
  tpexecute_ = NULL;
  return temp;
}
inline ::machinetalk::TaskPlanExecute* Container::mutable_tpexecute() {
  set_has_tpexecute();
  if (tpexecute_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::TaskPlanExecute>(GetArenaNoVirtual());
    tpexecute_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.tpexecute)
  return tpexecute_;
}
inline void Container::set_allocated_tpexecute(::machinetalk::TaskPlanExecute* tpexecute) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tpexecute_);
  }
  if (tpexecute) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tpexecute = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tpexecute, submessage_arena);
    }
    set_has_tpexecute();
  } else {
    clear_has_tpexecute();
  }
  tpexecute_ = tpexecute;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.tpexecute)
}

// optional .machinetalk.TaskPlanBlockDelete tpblockdelete = 201 [(.nanopb) = {
inline bool Container::has_tpblockdelete() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Container::set_has_tpblockdelete() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Container::clear_has_tpblockdelete() {
  _has_bits_[0] &= ~0x00040000u;
}
inline const ::machinetalk::TaskPlanBlockDelete& Container::_internal_tpblockdelete() const {
  return *tpblockdelete_;
}
inline const ::machinetalk::TaskPlanBlockDelete& Container::tpblockdelete() const {
  const ::machinetalk::TaskPlanBlockDelete* p = tpblockdelete_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.tpblockdelete)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::TaskPlanBlockDelete*>(
      &::machinetalk::_TaskPlanBlockDelete_default_instance_);
}
inline ::machinetalk::TaskPlanBlockDelete* Container::release_tpblockdelete() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.tpblockdelete)
  clear_has_tpblockdelete();
  ::machinetalk::TaskPlanBlockDelete* temp = tpblockdelete_;
  tpblockdelete_ = NULL;
  return temp;
}
inline ::machinetalk::TaskPlanBlockDelete* Container::mutable_tpblockdelete() {
  set_has_tpblockdelete();
  if (tpblockdelete_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::TaskPlanBlockDelete>(GetArenaNoVirtual());
    tpblockdelete_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.tpblockdelete)
  return tpblockdelete_;
}
inline void Container::set_allocated_tpblockdelete(::machinetalk::TaskPlanBlockDelete* tpblockdelete) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tpblockdelete_);
  }
  if (tpblockdelete) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tpblockdelete = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tpblockdelete, submessage_arena);
    }
    set_has_tpblockdelete();
  } else {
    clear_has_tpblockdelete();
  }
  tpblockdelete_ = tpblockdelete;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.tpblockdelete)
}

// optional .machinetalk.TaskPlanOptionalStop tpoptionalstop = 202 [(.nanopb) = {
inline bool Container::has_tpoptionalstop() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Container::set_has_tpoptionalstop() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Container::clear_has_tpoptionalstop() {
  _has_bits_[0] &= ~0x00080000u;
}
inline const ::machinetalk::TaskPlanOptionalStop& Container::_internal_tpoptionalstop() const {
  return *tpoptionalstop_;
}
inline const ::machinetalk::TaskPlanOptionalStop& Container::tpoptionalstop() const {
  const ::machinetalk::TaskPlanOptionalStop* p = tpoptionalstop_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.tpoptionalstop)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::TaskPlanOptionalStop*>(
      &::machinetalk::_TaskPlanOptionalStop_default_instance_);
}
inline ::machinetalk::TaskPlanOptionalStop* Container::release_tpoptionalstop() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.tpoptionalstop)
  clear_has_tpoptionalstop();
  ::machinetalk::TaskPlanOptionalStop* temp = tpoptionalstop_;
  tpoptionalstop_ = NULL;
  return temp;
}
inline ::machinetalk::TaskPlanOptionalStop* Container::mutable_tpoptionalstop() {
  set_has_tpoptionalstop();
  if (tpoptionalstop_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::TaskPlanOptionalStop>(GetArenaNoVirtual());
    tpoptionalstop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.tpoptionalstop)
  return tpoptionalstop_;
}
inline void Container::set_allocated_tpoptionalstop(::machinetalk::TaskPlanOptionalStop* tpoptionalstop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tpoptionalstop_);
  }
  if (tpoptionalstop) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tpoptionalstop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tpoptionalstop, submessage_arena);
    }
    set_has_tpoptionalstop();
  } else {
    clear_has_tpoptionalstop();
  }
  tpoptionalstop_ = tpoptionalstop;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.tpoptionalstop)
}

// optional .machinetalk.TaskPlanOpen tpopen = 203 [(.nanopb) = {
inline bool Container::has_tpopen() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Container::set_has_tpopen() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Container::clear_has_tpopen() {
  _has_bits_[0] &= ~0x00100000u;
}
inline const ::machinetalk::TaskPlanOpen& Container::_internal_tpopen() const {
  return *tpopen_;
}
inline const ::machinetalk::TaskPlanOpen& Container::tpopen() const {
  const ::machinetalk::TaskPlanOpen* p = tpopen_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.tpopen)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::TaskPlanOpen*>(
      &::machinetalk::_TaskPlanOpen_default_instance_);
}
inline ::machinetalk::TaskPlanOpen* Container::release_tpopen() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.tpopen)
  clear_has_tpopen();
  ::machinetalk::TaskPlanOpen* temp = tpopen_;
  tpopen_ = NULL;
  return temp;
}
inline ::machinetalk::TaskPlanOpen* Container::mutable_tpopen() {
  set_has_tpopen();
  if (tpopen_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::TaskPlanOpen>(GetArenaNoVirtual());
    tpopen_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.tpopen)
  return tpopen_;
}
inline void Container::set_allocated_tpopen(::machinetalk::TaskPlanOpen* tpopen) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tpopen_);
  }
  if (tpopen) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tpopen = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tpopen, submessage_arena);
    }
    set_has_tpopen();
  } else {
    clear_has_tpopen();
  }
  tpopen_ = tpopen;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.tpopen)
}

// optional .machinetalk.TaskPlanReply taskplan_reply = 210 [(.nanopb) = {
inline bool Container::has_taskplan_reply() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Container::set_has_taskplan_reply() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Container::clear_has_taskplan_reply() {
  _has_bits_[0] &= ~0x00200000u;
}
inline const ::machinetalk::TaskPlanReply& Container::_internal_taskplan_reply() const {
  return *taskplan_reply_;
}
inline const ::machinetalk::TaskPlanReply& Container::taskplan_reply() const {
  const ::machinetalk::TaskPlanReply* p = taskplan_reply_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.taskplan_reply)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::TaskPlanReply*>(
      &::machinetalk::_TaskPlanReply_default_instance_);
}
inline ::machinetalk::TaskPlanReply* Container::release_taskplan_reply() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.taskplan_reply)
  clear_has_taskplan_reply();
  ::machinetalk::TaskPlanReply* temp = taskplan_reply_;
  taskplan_reply_ = NULL;
  return temp;
}
inline ::machinetalk::TaskPlanReply* Container::mutable_taskplan_reply() {
  set_has_taskplan_reply();
  if (taskplan_reply_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::TaskPlanReply>(GetArenaNoVirtual());
    taskplan_reply_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.taskplan_reply)
  return taskplan_reply_;
}
inline void Container::set_allocated_taskplan_reply(::machinetalk::TaskPlanReply* taskplan_reply) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(taskplan_reply_);
  }
  if (taskplan_reply) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      taskplan_reply = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, taskplan_reply, submessage_arena);
    }
    set_has_taskplan_reply();
  } else {
    clear_has_taskplan_reply();
  }
  taskplan_reply_ = taskplan_reply;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.taskplan_reply)
}

// optional .machinetalk.Emc_Traj_Set_G5x traj_set_g5x = 300;
inline bool Container::has_traj_set_g5x() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Container::set_has_traj_set_g5x() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Container::clear_has_traj_set_g5x() {
  _has_bits_[0] &= ~0x00400000u;
}
inline const ::machinetalk::Emc_Traj_Set_G5x& Container::_internal_traj_set_g5x() const {
  return *traj_set_g5x_;
}
inline const ::machinetalk::Emc_Traj_Set_G5x& Container::traj_set_g5x() const {
  const ::machinetalk::Emc_Traj_Set_G5x* p = traj_set_g5x_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.traj_set_g5x)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Traj_Set_G5x*>(
      &::machinetalk::_Emc_Traj_Set_G5x_default_instance_);
}
inline ::machinetalk::Emc_Traj_Set_G5x* Container::release_traj_set_g5x() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.traj_set_g5x)
  clear_has_traj_set_g5x();
  ::machinetalk::Emc_Traj_Set_G5x* temp = traj_set_g5x_;
  traj_set_g5x_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Traj_Set_G5x* Container::mutable_traj_set_g5x() {
  set_has_traj_set_g5x();
  if (traj_set_g5x_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Traj_Set_G5x>(GetArenaNoVirtual());
    traj_set_g5x_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.traj_set_g5x)
  return traj_set_g5x_;
}
inline void Container::set_allocated_traj_set_g5x(::machinetalk::Emc_Traj_Set_G5x* traj_set_g5x) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(traj_set_g5x_);
  }
  if (traj_set_g5x) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traj_set_g5x = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traj_set_g5x, submessage_arena);
    }
    set_has_traj_set_g5x();
  } else {
    clear_has_traj_set_g5x();
  }
  traj_set_g5x_ = traj_set_g5x;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.traj_set_g5x)
}

// optional .machinetalk.Emc_Traj_Set_G92 traj_set_g92 = 310;
inline bool Container::has_traj_set_g92() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Container::set_has_traj_set_g92() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Container::clear_has_traj_set_g92() {
  _has_bits_[0] &= ~0x00800000u;
}
inline const ::machinetalk::Emc_Traj_Set_G92& Container::_internal_traj_set_g92() const {
  return *traj_set_g92_;
}
inline const ::machinetalk::Emc_Traj_Set_G92& Container::traj_set_g92() const {
  const ::machinetalk::Emc_Traj_Set_G92* p = traj_set_g92_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.traj_set_g92)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Traj_Set_G92*>(
      &::machinetalk::_Emc_Traj_Set_G92_default_instance_);
}
inline ::machinetalk::Emc_Traj_Set_G92* Container::release_traj_set_g92() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.traj_set_g92)
  clear_has_traj_set_g92();
  ::machinetalk::Emc_Traj_Set_G92* temp = traj_set_g92_;
  traj_set_g92_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Traj_Set_G92* Container::mutable_traj_set_g92() {
  set_has_traj_set_g92();
  if (traj_set_g92_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Traj_Set_G92>(GetArenaNoVirtual());
    traj_set_g92_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.traj_set_g92)
  return traj_set_g92_;
}
inline void Container::set_allocated_traj_set_g92(::machinetalk::Emc_Traj_Set_G92* traj_set_g92) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(traj_set_g92_);
  }
  if (traj_set_g92) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traj_set_g92 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traj_set_g92, submessage_arena);
    }
    set_has_traj_set_g92();
  } else {
    clear_has_traj_set_g92();
  }
  traj_set_g92_ = traj_set_g92;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.traj_set_g92)
}

// optional .machinetalk.Emc_Traj_Set_Rotation traj_set_rotation = 320;
inline bool Container::has_traj_set_rotation() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Container::set_has_traj_set_rotation() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Container::clear_has_traj_set_rotation() {
  _has_bits_[0] &= ~0x01000000u;
}
inline const ::machinetalk::Emc_Traj_Set_Rotation& Container::_internal_traj_set_rotation() const {
  return *traj_set_rotation_;
}
inline const ::machinetalk::Emc_Traj_Set_Rotation& Container::traj_set_rotation() const {
  const ::machinetalk::Emc_Traj_Set_Rotation* p = traj_set_rotation_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.traj_set_rotation)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Traj_Set_Rotation*>(
      &::machinetalk::_Emc_Traj_Set_Rotation_default_instance_);
}
inline ::machinetalk::Emc_Traj_Set_Rotation* Container::release_traj_set_rotation() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.traj_set_rotation)
  clear_has_traj_set_rotation();
  ::machinetalk::Emc_Traj_Set_Rotation* temp = traj_set_rotation_;
  traj_set_rotation_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Traj_Set_Rotation* Container::mutable_traj_set_rotation() {
  set_has_traj_set_rotation();
  if (traj_set_rotation_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Traj_Set_Rotation>(GetArenaNoVirtual());
    traj_set_rotation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.traj_set_rotation)
  return traj_set_rotation_;
}
inline void Container::set_allocated_traj_set_rotation(::machinetalk::Emc_Traj_Set_Rotation* traj_set_rotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(traj_set_rotation_);
  }
  if (traj_set_rotation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traj_set_rotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traj_set_rotation, submessage_arena);
    }
    set_has_traj_set_rotation();
  } else {
    clear_has_traj_set_rotation();
  }
  traj_set_rotation_ = traj_set_rotation;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.traj_set_rotation)
}

// optional .machinetalk.Emc_Traj_Linear_Move traj_linear_move = 330;
inline bool Container::has_traj_linear_move() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Container::set_has_traj_linear_move() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Container::clear_has_traj_linear_move() {
  _has_bits_[0] &= ~0x02000000u;
}
inline const ::machinetalk::Emc_Traj_Linear_Move& Container::_internal_traj_linear_move() const {
  return *traj_linear_move_;
}
inline const ::machinetalk::Emc_Traj_Linear_Move& Container::traj_linear_move() const {
  const ::machinetalk::Emc_Traj_Linear_Move* p = traj_linear_move_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.traj_linear_move)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Traj_Linear_Move*>(
      &::machinetalk::_Emc_Traj_Linear_Move_default_instance_);
}
inline ::machinetalk::Emc_Traj_Linear_Move* Container::release_traj_linear_move() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.traj_linear_move)
  clear_has_traj_linear_move();
  ::machinetalk::Emc_Traj_Linear_Move* temp = traj_linear_move_;
  traj_linear_move_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Traj_Linear_Move* Container::mutable_traj_linear_move() {
  set_has_traj_linear_move();
  if (traj_linear_move_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Traj_Linear_Move>(GetArenaNoVirtual());
    traj_linear_move_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.traj_linear_move)
  return traj_linear_move_;
}
inline void Container::set_allocated_traj_linear_move(::machinetalk::Emc_Traj_Linear_Move* traj_linear_move) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(traj_linear_move_);
  }
  if (traj_linear_move) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traj_linear_move = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traj_linear_move, submessage_arena);
    }
    set_has_traj_linear_move();
  } else {
    clear_has_traj_linear_move();
  }
  traj_linear_move_ = traj_linear_move;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.traj_linear_move)
}

// optional .machinetalk.Emc_Traj_Probe traj_probe = 340;
inline bool Container::has_traj_probe() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Container::set_has_traj_probe() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Container::clear_has_traj_probe() {
  _has_bits_[0] &= ~0x04000000u;
}
inline const ::machinetalk::Emc_Traj_Probe& Container::_internal_traj_probe() const {
  return *traj_probe_;
}
inline const ::machinetalk::Emc_Traj_Probe& Container::traj_probe() const {
  const ::machinetalk::Emc_Traj_Probe* p = traj_probe_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.traj_probe)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Traj_Probe*>(
      &::machinetalk::_Emc_Traj_Probe_default_instance_);
}
inline ::machinetalk::Emc_Traj_Probe* Container::release_traj_probe() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.traj_probe)
  clear_has_traj_probe();
  ::machinetalk::Emc_Traj_Probe* temp = traj_probe_;
  traj_probe_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Traj_Probe* Container::mutable_traj_probe() {
  set_has_traj_probe();
  if (traj_probe_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Traj_Probe>(GetArenaNoVirtual());
    traj_probe_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.traj_probe)
  return traj_probe_;
}
inline void Container::set_allocated_traj_probe(::machinetalk::Emc_Traj_Probe* traj_probe) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(traj_probe_);
  }
  if (traj_probe) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traj_probe = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traj_probe, submessage_arena);
    }
    set_has_traj_probe();
  } else {
    clear_has_traj_probe();
  }
  traj_probe_ = traj_probe;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.traj_probe)
}

// optional .machinetalk.Emc_Traj_Circular_Move traj_circular_move = 350;
inline bool Container::has_traj_circular_move() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Container::set_has_traj_circular_move() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Container::clear_has_traj_circular_move() {
  _has_bits_[0] &= ~0x08000000u;
}
inline const ::machinetalk::Emc_Traj_Circular_Move& Container::_internal_traj_circular_move() const {
  return *traj_circular_move_;
}
inline const ::machinetalk::Emc_Traj_Circular_Move& Container::traj_circular_move() const {
  const ::machinetalk::Emc_Traj_Circular_Move* p = traj_circular_move_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.traj_circular_move)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Traj_Circular_Move*>(
      &::machinetalk::_Emc_Traj_Circular_Move_default_instance_);
}
inline ::machinetalk::Emc_Traj_Circular_Move* Container::release_traj_circular_move() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.traj_circular_move)
  clear_has_traj_circular_move();
  ::machinetalk::Emc_Traj_Circular_Move* temp = traj_circular_move_;
  traj_circular_move_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Traj_Circular_Move* Container::mutable_traj_circular_move() {
  set_has_traj_circular_move();
  if (traj_circular_move_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Traj_Circular_Move>(GetArenaNoVirtual());
    traj_circular_move_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.traj_circular_move)
  return traj_circular_move_;
}
inline void Container::set_allocated_traj_circular_move(::machinetalk::Emc_Traj_Circular_Move* traj_circular_move) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(traj_circular_move_);
  }
  if (traj_circular_move) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traj_circular_move = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traj_circular_move, submessage_arena);
    }
    set_has_traj_circular_move();
  } else {
    clear_has_traj_circular_move();
  }
  traj_circular_move_ = traj_circular_move;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.traj_circular_move)
}

// optional .machinetalk.Emc_Traj_Rigid_Tap traj_rigid_tap = 360;
inline bool Container::has_traj_rigid_tap() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Container::set_has_traj_rigid_tap() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Container::clear_has_traj_rigid_tap() {
  _has_bits_[0] &= ~0x10000000u;
}
inline const ::machinetalk::Emc_Traj_Rigid_Tap& Container::_internal_traj_rigid_tap() const {
  return *traj_rigid_tap_;
}
inline const ::machinetalk::Emc_Traj_Rigid_Tap& Container::traj_rigid_tap() const {
  const ::machinetalk::Emc_Traj_Rigid_Tap* p = traj_rigid_tap_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.traj_rigid_tap)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Traj_Rigid_Tap*>(
      &::machinetalk::_Emc_Traj_Rigid_Tap_default_instance_);
}
inline ::machinetalk::Emc_Traj_Rigid_Tap* Container::release_traj_rigid_tap() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.traj_rigid_tap)
  clear_has_traj_rigid_tap();
  ::machinetalk::Emc_Traj_Rigid_Tap* temp = traj_rigid_tap_;
  traj_rigid_tap_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Traj_Rigid_Tap* Container::mutable_traj_rigid_tap() {
  set_has_traj_rigid_tap();
  if (traj_rigid_tap_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Traj_Rigid_Tap>(GetArenaNoVirtual());
    traj_rigid_tap_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.traj_rigid_tap)
  return traj_rigid_tap_;
}
inline void Container::set_allocated_traj_rigid_tap(::machinetalk::Emc_Traj_Rigid_Tap* traj_rigid_tap) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(traj_rigid_tap_);
  }
  if (traj_rigid_tap) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traj_rigid_tap = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traj_rigid_tap, submessage_arena);
    }
    set_has_traj_rigid_tap();
  } else {
    clear_has_traj_rigid_tap();
  }
  traj_rigid_tap_ = traj_rigid_tap;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.traj_rigid_tap)
}

// optional .machinetalk.Emc_Traj_Set_Term_Cond traj_set_term_cond = 370;
inline bool Container::has_traj_set_term_cond() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Container::set_has_traj_set_term_cond() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Container::clear_has_traj_set_term_cond() {
  _has_bits_[0] &= ~0x20000000u;
}
inline const ::machinetalk::Emc_Traj_Set_Term_Cond& Container::_internal_traj_set_term_cond() const {
  return *traj_set_term_cond_;
}
inline const ::machinetalk::Emc_Traj_Set_Term_Cond& Container::traj_set_term_cond() const {
  const ::machinetalk::Emc_Traj_Set_Term_Cond* p = traj_set_term_cond_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.traj_set_term_cond)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Traj_Set_Term_Cond*>(
      &::machinetalk::_Emc_Traj_Set_Term_Cond_default_instance_);
}
inline ::machinetalk::Emc_Traj_Set_Term_Cond* Container::release_traj_set_term_cond() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.traj_set_term_cond)
  clear_has_traj_set_term_cond();
  ::machinetalk::Emc_Traj_Set_Term_Cond* temp = traj_set_term_cond_;
  traj_set_term_cond_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Traj_Set_Term_Cond* Container::mutable_traj_set_term_cond() {
  set_has_traj_set_term_cond();
  if (traj_set_term_cond_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Traj_Set_Term_Cond>(GetArenaNoVirtual());
    traj_set_term_cond_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.traj_set_term_cond)
  return traj_set_term_cond_;
}
inline void Container::set_allocated_traj_set_term_cond(::machinetalk::Emc_Traj_Set_Term_Cond* traj_set_term_cond) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(traj_set_term_cond_);
  }
  if (traj_set_term_cond) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traj_set_term_cond = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traj_set_term_cond, submessage_arena);
    }
    set_has_traj_set_term_cond();
  } else {
    clear_has_traj_set_term_cond();
  }
  traj_set_term_cond_ = traj_set_term_cond;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.traj_set_term_cond)
}

// optional .machinetalk.Emc_Traj_Set_Spindlesync traj_set_spindlesync = 380;
inline bool Container::has_traj_set_spindlesync() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Container::set_has_traj_set_spindlesync() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Container::clear_has_traj_set_spindlesync() {
  _has_bits_[0] &= ~0x40000000u;
}
inline const ::machinetalk::Emc_Traj_Set_Spindlesync& Container::_internal_traj_set_spindlesync() const {
  return *traj_set_spindlesync_;
}
inline const ::machinetalk::Emc_Traj_Set_Spindlesync& Container::traj_set_spindlesync() const {
  const ::machinetalk::Emc_Traj_Set_Spindlesync* p = traj_set_spindlesync_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.traj_set_spindlesync)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Traj_Set_Spindlesync*>(
      &::machinetalk::_Emc_Traj_Set_Spindlesync_default_instance_);
}
inline ::machinetalk::Emc_Traj_Set_Spindlesync* Container::release_traj_set_spindlesync() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.traj_set_spindlesync)
  clear_has_traj_set_spindlesync();
  ::machinetalk::Emc_Traj_Set_Spindlesync* temp = traj_set_spindlesync_;
  traj_set_spindlesync_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Traj_Set_Spindlesync* Container::mutable_traj_set_spindlesync() {
  set_has_traj_set_spindlesync();
  if (traj_set_spindlesync_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Traj_Set_Spindlesync>(GetArenaNoVirtual());
    traj_set_spindlesync_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.traj_set_spindlesync)
  return traj_set_spindlesync_;
}
inline void Container::set_allocated_traj_set_spindlesync(::machinetalk::Emc_Traj_Set_Spindlesync* traj_set_spindlesync) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(traj_set_spindlesync_);
  }
  if (traj_set_spindlesync) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traj_set_spindlesync = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traj_set_spindlesync, submessage_arena);
    }
    set_has_traj_set_spindlesync();
  } else {
    clear_has_traj_set_spindlesync();
  }
  traj_set_spindlesync_ = traj_set_spindlesync;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.traj_set_spindlesync)
}

// optional .machinetalk.Emc_Traj_Delay traj_delay = 390;
inline bool Container::has_traj_delay() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Container::set_has_traj_delay() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Container::clear_has_traj_delay() {
  _has_bits_[0] &= ~0x80000000u;
}
inline const ::machinetalk::Emc_Traj_Delay& Container::_internal_traj_delay() const {
  return *traj_delay_;
}
inline const ::machinetalk::Emc_Traj_Delay& Container::traj_delay() const {
  const ::machinetalk::Emc_Traj_Delay* p = traj_delay_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.traj_delay)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Traj_Delay*>(
      &::machinetalk::_Emc_Traj_Delay_default_instance_);
}
inline ::machinetalk::Emc_Traj_Delay* Container::release_traj_delay() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.traj_delay)
  clear_has_traj_delay();
  ::machinetalk::Emc_Traj_Delay* temp = traj_delay_;
  traj_delay_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Traj_Delay* Container::mutable_traj_delay() {
  set_has_traj_delay();
  if (traj_delay_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Traj_Delay>(GetArenaNoVirtual());
    traj_delay_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.traj_delay)
  return traj_delay_;
}
inline void Container::set_allocated_traj_delay(::machinetalk::Emc_Traj_Delay* traj_delay) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(traj_delay_);
  }
  if (traj_delay) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traj_delay = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traj_delay, submessage_arena);
    }
    set_has_traj_delay();
  } else {
    clear_has_traj_delay();
  }
  traj_delay_ = traj_delay;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.traj_delay)
}

// optional .machinetalk.Emc_Spindle_On spindle_on = 400;
inline bool Container::has_spindle_on() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Container::set_has_spindle_on() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Container::clear_has_spindle_on() {
  _has_bits_[1] &= ~0x00000001u;
}
inline const ::machinetalk::Emc_Spindle_On& Container::_internal_spindle_on() const {
  return *spindle_on_;
}
inline const ::machinetalk::Emc_Spindle_On& Container::spindle_on() const {
  const ::machinetalk::Emc_Spindle_On* p = spindle_on_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.spindle_on)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Spindle_On*>(
      &::machinetalk::_Emc_Spindle_On_default_instance_);
}
inline ::machinetalk::Emc_Spindle_On* Container::release_spindle_on() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.spindle_on)
  clear_has_spindle_on();
  ::machinetalk::Emc_Spindle_On* temp = spindle_on_;
  spindle_on_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Spindle_On* Container::mutable_spindle_on() {
  set_has_spindle_on();
  if (spindle_on_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Spindle_On>(GetArenaNoVirtual());
    spindle_on_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.spindle_on)
  return spindle_on_;
}
inline void Container::set_allocated_spindle_on(::machinetalk::Emc_Spindle_On* spindle_on) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(spindle_on_);
  }
  if (spindle_on) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      spindle_on = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, spindle_on, submessage_arena);
    }
    set_has_spindle_on();
  } else {
    clear_has_spindle_on();
  }
  spindle_on_ = spindle_on;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.spindle_on)
}

// optional .machinetalk.Emc_Spindle_Speed spindle_speed = 410;
inline bool Container::has_spindle_speed() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Container::set_has_spindle_speed() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Container::clear_has_spindle_speed() {
  _has_bits_[1] &= ~0x00000002u;
}
inline const ::machinetalk::Emc_Spindle_Speed& Container::_internal_spindle_speed() const {
  return *spindle_speed_;
}
inline const ::machinetalk::Emc_Spindle_Speed& Container::spindle_speed() const {
  const ::machinetalk::Emc_Spindle_Speed* p = spindle_speed_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.spindle_speed)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Spindle_Speed*>(
      &::machinetalk::_Emc_Spindle_Speed_default_instance_);
}
inline ::machinetalk::Emc_Spindle_Speed* Container::release_spindle_speed() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.spindle_speed)
  clear_has_spindle_speed();
  ::machinetalk::Emc_Spindle_Speed* temp = spindle_speed_;
  spindle_speed_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Spindle_Speed* Container::mutable_spindle_speed() {
  set_has_spindle_speed();
  if (spindle_speed_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Spindle_Speed>(GetArenaNoVirtual());
    spindle_speed_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.spindle_speed)
  return spindle_speed_;
}
inline void Container::set_allocated_spindle_speed(::machinetalk::Emc_Spindle_Speed* spindle_speed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(spindle_speed_);
  }
  if (spindle_speed) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      spindle_speed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, spindle_speed, submessage_arena);
    }
    set_has_spindle_speed();
  } else {
    clear_has_spindle_speed();
  }
  spindle_speed_ = spindle_speed;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.spindle_speed)
}

// optional .machinetalk.Emc_Spindle_Orient spindle_orient = 420;
inline bool Container::has_spindle_orient() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Container::set_has_spindle_orient() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Container::clear_has_spindle_orient() {
  _has_bits_[1] &= ~0x00000004u;
}
inline const ::machinetalk::Emc_Spindle_Orient& Container::_internal_spindle_orient() const {
  return *spindle_orient_;
}
inline const ::machinetalk::Emc_Spindle_Orient& Container::spindle_orient() const {
  const ::machinetalk::Emc_Spindle_Orient* p = spindle_orient_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.spindle_orient)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Spindle_Orient*>(
      &::machinetalk::_Emc_Spindle_Orient_default_instance_);
}
inline ::machinetalk::Emc_Spindle_Orient* Container::release_spindle_orient() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.spindle_orient)
  clear_has_spindle_orient();
  ::machinetalk::Emc_Spindle_Orient* temp = spindle_orient_;
  spindle_orient_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Spindle_Orient* Container::mutable_spindle_orient() {
  set_has_spindle_orient();
  if (spindle_orient_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Spindle_Orient>(GetArenaNoVirtual());
    spindle_orient_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.spindle_orient)
  return spindle_orient_;
}
inline void Container::set_allocated_spindle_orient(::machinetalk::Emc_Spindle_Orient* spindle_orient) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(spindle_orient_);
  }
  if (spindle_orient) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      spindle_orient = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, spindle_orient, submessage_arena);
    }
    set_has_spindle_orient();
  } else {
    clear_has_spindle_orient();
  }
  spindle_orient_ = spindle_orient;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.spindle_orient)
}

// optional .machinetalk.Emc_Spindle_Wait_Orient_Complete spindle_wait_orient_complete = 430;
inline bool Container::has_spindle_wait_orient_complete() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Container::set_has_spindle_wait_orient_complete() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Container::clear_has_spindle_wait_orient_complete() {
  _has_bits_[1] &= ~0x00000008u;
}
inline const ::machinetalk::Emc_Spindle_Wait_Orient_Complete& Container::_internal_spindle_wait_orient_complete() const {
  return *spindle_wait_orient_complete_;
}
inline const ::machinetalk::Emc_Spindle_Wait_Orient_Complete& Container::spindle_wait_orient_complete() const {
  const ::machinetalk::Emc_Spindle_Wait_Orient_Complete* p = spindle_wait_orient_complete_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.spindle_wait_orient_complete)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Spindle_Wait_Orient_Complete*>(
      &::machinetalk::_Emc_Spindle_Wait_Orient_Complete_default_instance_);
}
inline ::machinetalk::Emc_Spindle_Wait_Orient_Complete* Container::release_spindle_wait_orient_complete() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.spindle_wait_orient_complete)
  clear_has_spindle_wait_orient_complete();
  ::machinetalk::Emc_Spindle_Wait_Orient_Complete* temp = spindle_wait_orient_complete_;
  spindle_wait_orient_complete_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Spindle_Wait_Orient_Complete* Container::mutable_spindle_wait_orient_complete() {
  set_has_spindle_wait_orient_complete();
  if (spindle_wait_orient_complete_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Spindle_Wait_Orient_Complete>(GetArenaNoVirtual());
    spindle_wait_orient_complete_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.spindle_wait_orient_complete)
  return spindle_wait_orient_complete_;
}
inline void Container::set_allocated_spindle_wait_orient_complete(::machinetalk::Emc_Spindle_Wait_Orient_Complete* spindle_wait_orient_complete) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(spindle_wait_orient_complete_);
  }
  if (spindle_wait_orient_complete) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      spindle_wait_orient_complete = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, spindle_wait_orient_complete, submessage_arena);
    }
    set_has_spindle_wait_orient_complete();
  } else {
    clear_has_spindle_wait_orient_complete();
  }
  spindle_wait_orient_complete_ = spindle_wait_orient_complete;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.spindle_wait_orient_complete)
}

// optional .machinetalk.Emc_Tool_Set_Offset tool_set_offet = 440;
inline bool Container::has_tool_set_offet() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void Container::set_has_tool_set_offet() {
  _has_bits_[1] |= 0x00000010u;
}
inline void Container::clear_has_tool_set_offet() {
  _has_bits_[1] &= ~0x00000010u;
}
inline const ::machinetalk::Emc_Tool_Set_Offset& Container::_internal_tool_set_offet() const {
  return *tool_set_offet_;
}
inline const ::machinetalk::Emc_Tool_Set_Offset& Container::tool_set_offet() const {
  const ::machinetalk::Emc_Tool_Set_Offset* p = tool_set_offet_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.tool_set_offet)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Tool_Set_Offset*>(
      &::machinetalk::_Emc_Tool_Set_Offset_default_instance_);
}
inline ::machinetalk::Emc_Tool_Set_Offset* Container::release_tool_set_offet() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.tool_set_offet)
  clear_has_tool_set_offet();
  ::machinetalk::Emc_Tool_Set_Offset* temp = tool_set_offet_;
  tool_set_offet_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Tool_Set_Offset* Container::mutable_tool_set_offet() {
  set_has_tool_set_offet();
  if (tool_set_offet_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Tool_Set_Offset>(GetArenaNoVirtual());
    tool_set_offet_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.tool_set_offet)
  return tool_set_offet_;
}
inline void Container::set_allocated_tool_set_offet(::machinetalk::Emc_Tool_Set_Offset* tool_set_offet) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tool_set_offet_);
  }
  if (tool_set_offet) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tool_set_offet = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tool_set_offet, submessage_arena);
    }
    set_has_tool_set_offet();
  } else {
    clear_has_tool_set_offet();
  }
  tool_set_offet_ = tool_set_offet;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.tool_set_offet)
}

// optional .machinetalk.Emc_Traj_Set_Offset traj_set_offset = 450;
inline bool Container::has_traj_set_offset() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void Container::set_has_traj_set_offset() {
  _has_bits_[1] |= 0x00000020u;
}
inline void Container::clear_has_traj_set_offset() {
  _has_bits_[1] &= ~0x00000020u;
}
inline const ::machinetalk::Emc_Traj_Set_Offset& Container::_internal_traj_set_offset() const {
  return *traj_set_offset_;
}
inline const ::machinetalk::Emc_Traj_Set_Offset& Container::traj_set_offset() const {
  const ::machinetalk::Emc_Traj_Set_Offset* p = traj_set_offset_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.traj_set_offset)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Traj_Set_Offset*>(
      &::machinetalk::_Emc_Traj_Set_Offset_default_instance_);
}
inline ::machinetalk::Emc_Traj_Set_Offset* Container::release_traj_set_offset() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.traj_set_offset)
  clear_has_traj_set_offset();
  ::machinetalk::Emc_Traj_Set_Offset* temp = traj_set_offset_;
  traj_set_offset_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Traj_Set_Offset* Container::mutable_traj_set_offset() {
  set_has_traj_set_offset();
  if (traj_set_offset_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Traj_Set_Offset>(GetArenaNoVirtual());
    traj_set_offset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.traj_set_offset)
  return traj_set_offset_;
}
inline void Container::set_allocated_traj_set_offset(::machinetalk::Emc_Traj_Set_Offset* traj_set_offset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(traj_set_offset_);
  }
  if (traj_set_offset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traj_set_offset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traj_set_offset, submessage_arena);
    }
    set_has_traj_set_offset();
  } else {
    clear_has_traj_set_offset();
  }
  traj_set_offset_ = traj_set_offset;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.traj_set_offset)
}

// optional .machinetalk.Emc_Tool_Prepare tool_prepare = 460;
inline bool Container::has_tool_prepare() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void Container::set_has_tool_prepare() {
  _has_bits_[1] |= 0x00000040u;
}
inline void Container::clear_has_tool_prepare() {
  _has_bits_[1] &= ~0x00000040u;
}
inline const ::machinetalk::Emc_Tool_Prepare& Container::_internal_tool_prepare() const {
  return *tool_prepare_;
}
inline const ::machinetalk::Emc_Tool_Prepare& Container::tool_prepare() const {
  const ::machinetalk::Emc_Tool_Prepare* p = tool_prepare_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.tool_prepare)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Tool_Prepare*>(
      &::machinetalk::_Emc_Tool_Prepare_default_instance_);
}
inline ::machinetalk::Emc_Tool_Prepare* Container::release_tool_prepare() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.tool_prepare)
  clear_has_tool_prepare();
  ::machinetalk::Emc_Tool_Prepare* temp = tool_prepare_;
  tool_prepare_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Tool_Prepare* Container::mutable_tool_prepare() {
  set_has_tool_prepare();
  if (tool_prepare_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Tool_Prepare>(GetArenaNoVirtual());
    tool_prepare_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.tool_prepare)
  return tool_prepare_;
}
inline void Container::set_allocated_tool_prepare(::machinetalk::Emc_Tool_Prepare* tool_prepare) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tool_prepare_);
  }
  if (tool_prepare) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tool_prepare = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tool_prepare, submessage_arena);
    }
    set_has_tool_prepare();
  } else {
    clear_has_tool_prepare();
  }
  tool_prepare_ = tool_prepare;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.tool_prepare)
}

// optional .machinetalk.Emc_Tool_Set_Number tool_set_number = 470;
inline bool Container::has_tool_set_number() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void Container::set_has_tool_set_number() {
  _has_bits_[1] |= 0x00000080u;
}
inline void Container::clear_has_tool_set_number() {
  _has_bits_[1] &= ~0x00000080u;
}
inline const ::machinetalk::Emc_Tool_Set_Number& Container::_internal_tool_set_number() const {
  return *tool_set_number_;
}
inline const ::machinetalk::Emc_Tool_Set_Number& Container::tool_set_number() const {
  const ::machinetalk::Emc_Tool_Set_Number* p = tool_set_number_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.tool_set_number)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Tool_Set_Number*>(
      &::machinetalk::_Emc_Tool_Set_Number_default_instance_);
}
inline ::machinetalk::Emc_Tool_Set_Number* Container::release_tool_set_number() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.tool_set_number)
  clear_has_tool_set_number();
  ::machinetalk::Emc_Tool_Set_Number* temp = tool_set_number_;
  tool_set_number_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Tool_Set_Number* Container::mutable_tool_set_number() {
  set_has_tool_set_number();
  if (tool_set_number_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Tool_Set_Number>(GetArenaNoVirtual());
    tool_set_number_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.tool_set_number)
  return tool_set_number_;
}
inline void Container::set_allocated_tool_set_number(::machinetalk::Emc_Tool_Set_Number* tool_set_number) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tool_set_number_);
  }
  if (tool_set_number) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tool_set_number = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tool_set_number, submessage_arena);
    }
    set_has_tool_set_number();
  } else {
    clear_has_tool_set_number();
  }
  tool_set_number_ = tool_set_number;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.tool_set_number)
}

// optional .machinetalk.Emc_Traj_Set_Fo_Enable traj_set_fo_enable = 480;
inline bool Container::has_traj_set_fo_enable() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void Container::set_has_traj_set_fo_enable() {
  _has_bits_[1] |= 0x00000100u;
}
inline void Container::clear_has_traj_set_fo_enable() {
  _has_bits_[1] &= ~0x00000100u;
}
inline const ::machinetalk::Emc_Traj_Set_Fo_Enable& Container::_internal_traj_set_fo_enable() const {
  return *traj_set_fo_enable_;
}
inline const ::machinetalk::Emc_Traj_Set_Fo_Enable& Container::traj_set_fo_enable() const {
  const ::machinetalk::Emc_Traj_Set_Fo_Enable* p = traj_set_fo_enable_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.traj_set_fo_enable)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Traj_Set_Fo_Enable*>(
      &::machinetalk::_Emc_Traj_Set_Fo_Enable_default_instance_);
}
inline ::machinetalk::Emc_Traj_Set_Fo_Enable* Container::release_traj_set_fo_enable() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.traj_set_fo_enable)
  clear_has_traj_set_fo_enable();
  ::machinetalk::Emc_Traj_Set_Fo_Enable* temp = traj_set_fo_enable_;
  traj_set_fo_enable_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Traj_Set_Fo_Enable* Container::mutable_traj_set_fo_enable() {
  set_has_traj_set_fo_enable();
  if (traj_set_fo_enable_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Traj_Set_Fo_Enable>(GetArenaNoVirtual());
    traj_set_fo_enable_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.traj_set_fo_enable)
  return traj_set_fo_enable_;
}
inline void Container::set_allocated_traj_set_fo_enable(::machinetalk::Emc_Traj_Set_Fo_Enable* traj_set_fo_enable) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(traj_set_fo_enable_);
  }
  if (traj_set_fo_enable) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traj_set_fo_enable = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traj_set_fo_enable, submessage_arena);
    }
    set_has_traj_set_fo_enable();
  } else {
    clear_has_traj_set_fo_enable();
  }
  traj_set_fo_enable_ = traj_set_fo_enable;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.traj_set_fo_enable)
}

// optional .machinetalk.Emc_Traj_Set_So_Enable traj_set_so_enable = 490;
inline bool Container::has_traj_set_so_enable() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void Container::set_has_traj_set_so_enable() {
  _has_bits_[1] |= 0x00000200u;
}
inline void Container::clear_has_traj_set_so_enable() {
  _has_bits_[1] &= ~0x00000200u;
}
inline const ::machinetalk::Emc_Traj_Set_So_Enable& Container::_internal_traj_set_so_enable() const {
  return *traj_set_so_enable_;
}
inline const ::machinetalk::Emc_Traj_Set_So_Enable& Container::traj_set_so_enable() const {
  const ::machinetalk::Emc_Traj_Set_So_Enable* p = traj_set_so_enable_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.traj_set_so_enable)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Traj_Set_So_Enable*>(
      &::machinetalk::_Emc_Traj_Set_So_Enable_default_instance_);
}
inline ::machinetalk::Emc_Traj_Set_So_Enable* Container::release_traj_set_so_enable() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.traj_set_so_enable)
  clear_has_traj_set_so_enable();
  ::machinetalk::Emc_Traj_Set_So_Enable* temp = traj_set_so_enable_;
  traj_set_so_enable_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Traj_Set_So_Enable* Container::mutable_traj_set_so_enable() {
  set_has_traj_set_so_enable();
  if (traj_set_so_enable_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Traj_Set_So_Enable>(GetArenaNoVirtual());
    traj_set_so_enable_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.traj_set_so_enable)
  return traj_set_so_enable_;
}
inline void Container::set_allocated_traj_set_so_enable(::machinetalk::Emc_Traj_Set_So_Enable* traj_set_so_enable) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(traj_set_so_enable_);
  }
  if (traj_set_so_enable) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traj_set_so_enable = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traj_set_so_enable, submessage_arena);
    }
    set_has_traj_set_so_enable();
  } else {
    clear_has_traj_set_so_enable();
  }
  traj_set_so_enable_ = traj_set_so_enable;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.traj_set_so_enable)
}

// optional .machinetalk.Emc_Traj_Set_Fh_Enable traj_set_fh_enable = 500;
inline bool Container::has_traj_set_fh_enable() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void Container::set_has_traj_set_fh_enable() {
  _has_bits_[1] |= 0x00000400u;
}
inline void Container::clear_has_traj_set_fh_enable() {
  _has_bits_[1] &= ~0x00000400u;
}
inline const ::machinetalk::Emc_Traj_Set_Fh_Enable& Container::_internal_traj_set_fh_enable() const {
  return *traj_set_fh_enable_;
}
inline const ::machinetalk::Emc_Traj_Set_Fh_Enable& Container::traj_set_fh_enable() const {
  const ::machinetalk::Emc_Traj_Set_Fh_Enable* p = traj_set_fh_enable_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.traj_set_fh_enable)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Traj_Set_Fh_Enable*>(
      &::machinetalk::_Emc_Traj_Set_Fh_Enable_default_instance_);
}
inline ::machinetalk::Emc_Traj_Set_Fh_Enable* Container::release_traj_set_fh_enable() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.traj_set_fh_enable)
  clear_has_traj_set_fh_enable();
  ::machinetalk::Emc_Traj_Set_Fh_Enable* temp = traj_set_fh_enable_;
  traj_set_fh_enable_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Traj_Set_Fh_Enable* Container::mutable_traj_set_fh_enable() {
  set_has_traj_set_fh_enable();
  if (traj_set_fh_enable_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Traj_Set_Fh_Enable>(GetArenaNoVirtual());
    traj_set_fh_enable_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.traj_set_fh_enable)
  return traj_set_fh_enable_;
}
inline void Container::set_allocated_traj_set_fh_enable(::machinetalk::Emc_Traj_Set_Fh_Enable* traj_set_fh_enable) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(traj_set_fh_enable_);
  }
  if (traj_set_fh_enable) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      traj_set_fh_enable = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, traj_set_fh_enable, submessage_arena);
    }
    set_has_traj_set_fh_enable();
  } else {
    clear_has_traj_set_fh_enable();
  }
  traj_set_fh_enable_ = traj_set_fh_enable;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.traj_set_fh_enable)
}

// optional .machinetalk.Emc_Motion_Adaptive motion_adaptive = 510;
inline bool Container::has_motion_adaptive() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void Container::set_has_motion_adaptive() {
  _has_bits_[1] |= 0x00000800u;
}
inline void Container::clear_has_motion_adaptive() {
  _has_bits_[1] &= ~0x00000800u;
}
inline const ::machinetalk::Emc_Motion_Adaptive& Container::_internal_motion_adaptive() const {
  return *motion_adaptive_;
}
inline const ::machinetalk::Emc_Motion_Adaptive& Container::motion_adaptive() const {
  const ::machinetalk::Emc_Motion_Adaptive* p = motion_adaptive_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.motion_adaptive)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Motion_Adaptive*>(
      &::machinetalk::_Emc_Motion_Adaptive_default_instance_);
}
inline ::machinetalk::Emc_Motion_Adaptive* Container::release_motion_adaptive() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.motion_adaptive)
  clear_has_motion_adaptive();
  ::machinetalk::Emc_Motion_Adaptive* temp = motion_adaptive_;
  motion_adaptive_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Motion_Adaptive* Container::mutable_motion_adaptive() {
  set_has_motion_adaptive();
  if (motion_adaptive_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Motion_Adaptive>(GetArenaNoVirtual());
    motion_adaptive_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.motion_adaptive)
  return motion_adaptive_;
}
inline void Container::set_allocated_motion_adaptive(::machinetalk::Emc_Motion_Adaptive* motion_adaptive) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(motion_adaptive_);
  }
  if (motion_adaptive) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      motion_adaptive = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, motion_adaptive, submessage_arena);
    }
    set_has_motion_adaptive();
  } else {
    clear_has_motion_adaptive();
  }
  motion_adaptive_ = motion_adaptive;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.motion_adaptive)
}

// optional .machinetalk.Emc_Operator_Display operator_display = 520;
inline bool Container::has_operator_display() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void Container::set_has_operator_display() {
  _has_bits_[1] |= 0x00001000u;
}
inline void Container::clear_has_operator_display() {
  _has_bits_[1] &= ~0x00001000u;
}
inline const ::machinetalk::Emc_Operator_Display& Container::_internal_operator_display() const {
  return *operator_display_;
}
inline const ::machinetalk::Emc_Operator_Display& Container::operator_display() const {
  const ::machinetalk::Emc_Operator_Display* p = operator_display_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.operator_display)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Operator_Display*>(
      &::machinetalk::_Emc_Operator_Display_default_instance_);
}
inline ::machinetalk::Emc_Operator_Display* Container::release_operator_display() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.operator_display)
  clear_has_operator_display();
  ::machinetalk::Emc_Operator_Display* temp = operator_display_;
  operator_display_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Operator_Display* Container::mutable_operator_display() {
  set_has_operator_display();
  if (operator_display_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Operator_Display>(GetArenaNoVirtual());
    operator_display_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.operator_display)
  return operator_display_;
}
inline void Container::set_allocated_operator_display(::machinetalk::Emc_Operator_Display* operator_display) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(operator_display_);
  }
  if (operator_display) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      operator_display = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, operator_display, submessage_arena);
    }
    set_has_operator_display();
  } else {
    clear_has_operator_display();
  }
  operator_display_ = operator_display;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.operator_display)
}

// optional .machinetalk.Emc_Operator_Text operator_text = 530;
inline bool Container::has_operator_text() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void Container::set_has_operator_text() {
  _has_bits_[1] |= 0x00002000u;
}
inline void Container::clear_has_operator_text() {
  _has_bits_[1] &= ~0x00002000u;
}
inline const ::machinetalk::Emc_Operator_Text& Container::_internal_operator_text() const {
  return *operator_text_;
}
inline const ::machinetalk::Emc_Operator_Text& Container::operator_text() const {
  const ::machinetalk::Emc_Operator_Text* p = operator_text_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.operator_text)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Operator_Text*>(
      &::machinetalk::_Emc_Operator_Text_default_instance_);
}
inline ::machinetalk::Emc_Operator_Text* Container::release_operator_text() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.operator_text)
  clear_has_operator_text();
  ::machinetalk::Emc_Operator_Text* temp = operator_text_;
  operator_text_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Operator_Text* Container::mutable_operator_text() {
  set_has_operator_text();
  if (operator_text_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Operator_Text>(GetArenaNoVirtual());
    operator_text_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.operator_text)
  return operator_text_;
}
inline void Container::set_allocated_operator_text(::machinetalk::Emc_Operator_Text* operator_text) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(operator_text_);
  }
  if (operator_text) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      operator_text = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, operator_text, submessage_arena);
    }
    set_has_operator_text();
  } else {
    clear_has_operator_text();
  }
  operator_text_ = operator_text;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.operator_text)
}

// optional .machinetalk.Emc_Operator_Error operator_error = 540;
inline bool Container::has_operator_error() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void Container::set_has_operator_error() {
  _has_bits_[1] |= 0x00004000u;
}
inline void Container::clear_has_operator_error() {
  _has_bits_[1] &= ~0x00004000u;
}
inline const ::machinetalk::Emc_Operator_Error& Container::_internal_operator_error() const {
  return *operator_error_;
}
inline const ::machinetalk::Emc_Operator_Error& Container::operator_error() const {
  const ::machinetalk::Emc_Operator_Error* p = operator_error_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.operator_error)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Operator_Error*>(
      &::machinetalk::_Emc_Operator_Error_default_instance_);
}
inline ::machinetalk::Emc_Operator_Error* Container::release_operator_error() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.operator_error)
  clear_has_operator_error();
  ::machinetalk::Emc_Operator_Error* temp = operator_error_;
  operator_error_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Operator_Error* Container::mutable_operator_error() {
  set_has_operator_error();
  if (operator_error_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Operator_Error>(GetArenaNoVirtual());
    operator_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.operator_error)
  return operator_error_;
}
inline void Container::set_allocated_operator_error(::machinetalk::Emc_Operator_Error* operator_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(operator_error_);
  }
  if (operator_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      operator_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, operator_error, submessage_arena);
    }
    set_has_operator_error();
  } else {
    clear_has_operator_error();
  }
  operator_error_ = operator_error;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.operator_error)
}

// optional .machinetalk.Emc_Motion_Set_Dout motion_set_dout = 550;
inline bool Container::has_motion_set_dout() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void Container::set_has_motion_set_dout() {
  _has_bits_[1] |= 0x00008000u;
}
inline void Container::clear_has_motion_set_dout() {
  _has_bits_[1] &= ~0x00008000u;
}
inline const ::machinetalk::Emc_Motion_Set_Dout& Container::_internal_motion_set_dout() const {
  return *motion_set_dout_;
}
inline const ::machinetalk::Emc_Motion_Set_Dout& Container::motion_set_dout() const {
  const ::machinetalk::Emc_Motion_Set_Dout* p = motion_set_dout_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.motion_set_dout)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Motion_Set_Dout*>(
      &::machinetalk::_Emc_Motion_Set_Dout_default_instance_);
}
inline ::machinetalk::Emc_Motion_Set_Dout* Container::release_motion_set_dout() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.motion_set_dout)
  clear_has_motion_set_dout();
  ::machinetalk::Emc_Motion_Set_Dout* temp = motion_set_dout_;
  motion_set_dout_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Motion_Set_Dout* Container::mutable_motion_set_dout() {
  set_has_motion_set_dout();
  if (motion_set_dout_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Motion_Set_Dout>(GetArenaNoVirtual());
    motion_set_dout_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.motion_set_dout)
  return motion_set_dout_;
}
inline void Container::set_allocated_motion_set_dout(::machinetalk::Emc_Motion_Set_Dout* motion_set_dout) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(motion_set_dout_);
  }
  if (motion_set_dout) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      motion_set_dout = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, motion_set_dout, submessage_arena);
    }
    set_has_motion_set_dout();
  } else {
    clear_has_motion_set_dout();
  }
  motion_set_dout_ = motion_set_dout;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.motion_set_dout)
}

// optional .machinetalk.Emc_Motion_Set_Aout motion_set_aout = 560;
inline bool Container::has_motion_set_aout() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void Container::set_has_motion_set_aout() {
  _has_bits_[1] |= 0x00010000u;
}
inline void Container::clear_has_motion_set_aout() {
  _has_bits_[1] &= ~0x00010000u;
}
inline const ::machinetalk::Emc_Motion_Set_Aout& Container::_internal_motion_set_aout() const {
  return *motion_set_aout_;
}
inline const ::machinetalk::Emc_Motion_Set_Aout& Container::motion_set_aout() const {
  const ::machinetalk::Emc_Motion_Set_Aout* p = motion_set_aout_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.motion_set_aout)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Motion_Set_Aout*>(
      &::machinetalk::_Emc_Motion_Set_Aout_default_instance_);
}
inline ::machinetalk::Emc_Motion_Set_Aout* Container::release_motion_set_aout() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.motion_set_aout)
  clear_has_motion_set_aout();
  ::machinetalk::Emc_Motion_Set_Aout* temp = motion_set_aout_;
  motion_set_aout_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Motion_Set_Aout* Container::mutable_motion_set_aout() {
  set_has_motion_set_aout();
  if (motion_set_aout_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Motion_Set_Aout>(GetArenaNoVirtual());
    motion_set_aout_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.motion_set_aout)
  return motion_set_aout_;
}
inline void Container::set_allocated_motion_set_aout(::machinetalk::Emc_Motion_Set_Aout* motion_set_aout) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(motion_set_aout_);
  }
  if (motion_set_aout) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      motion_set_aout = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, motion_set_aout, submessage_arena);
    }
    set_has_motion_set_aout();
  } else {
    clear_has_motion_set_aout();
  }
  motion_set_aout_ = motion_set_aout;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.motion_set_aout)
}

// optional .machinetalk.Emc_Aux_Input_Wait aux_input_wait = 570;
inline bool Container::has_aux_input_wait() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void Container::set_has_aux_input_wait() {
  _has_bits_[1] |= 0x00020000u;
}
inline void Container::clear_has_aux_input_wait() {
  _has_bits_[1] &= ~0x00020000u;
}
inline const ::machinetalk::Emc_Aux_Input_Wait& Container::_internal_aux_input_wait() const {
  return *aux_input_wait_;
}
inline const ::machinetalk::Emc_Aux_Input_Wait& Container::aux_input_wait() const {
  const ::machinetalk::Emc_Aux_Input_Wait* p = aux_input_wait_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.aux_input_wait)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Aux_Input_Wait*>(
      &::machinetalk::_Emc_Aux_Input_Wait_default_instance_);
}
inline ::machinetalk::Emc_Aux_Input_Wait* Container::release_aux_input_wait() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.aux_input_wait)
  clear_has_aux_input_wait();
  ::machinetalk::Emc_Aux_Input_Wait* temp = aux_input_wait_;
  aux_input_wait_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Aux_Input_Wait* Container::mutable_aux_input_wait() {
  set_has_aux_input_wait();
  if (aux_input_wait_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Aux_Input_Wait>(GetArenaNoVirtual());
    aux_input_wait_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.aux_input_wait)
  return aux_input_wait_;
}
inline void Container::set_allocated_aux_input_wait(::machinetalk::Emc_Aux_Input_Wait* aux_input_wait) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(aux_input_wait_);
  }
  if (aux_input_wait) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      aux_input_wait = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, aux_input_wait, submessage_arena);
    }
    set_has_aux_input_wait();
  } else {
    clear_has_aux_input_wait();
  }
  aux_input_wait_ = aux_input_wait;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.aux_input_wait)
}

// optional .machinetalk.Emc_Exec_Plugin_Ca1l exec_plugin_call = 580;
inline bool Container::has_exec_plugin_call() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void Container::set_has_exec_plugin_call() {
  _has_bits_[1] |= 0x00040000u;
}
inline void Container::clear_has_exec_plugin_call() {
  _has_bits_[1] &= ~0x00040000u;
}
inline const ::machinetalk::Emc_Exec_Plugin_Ca1l& Container::_internal_exec_plugin_call() const {
  return *exec_plugin_call_;
}
inline const ::machinetalk::Emc_Exec_Plugin_Ca1l& Container::exec_plugin_call() const {
  const ::machinetalk::Emc_Exec_Plugin_Ca1l* p = exec_plugin_call_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.exec_plugin_call)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Exec_Plugin_Ca1l*>(
      &::machinetalk::_Emc_Exec_Plugin_Ca1l_default_instance_);
}
inline ::machinetalk::Emc_Exec_Plugin_Ca1l* Container::release_exec_plugin_call() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.exec_plugin_call)
  clear_has_exec_plugin_call();
  ::machinetalk::Emc_Exec_Plugin_Ca1l* temp = exec_plugin_call_;
  exec_plugin_call_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Exec_Plugin_Ca1l* Container::mutable_exec_plugin_call() {
  set_has_exec_plugin_call();
  if (exec_plugin_call_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Exec_Plugin_Ca1l>(GetArenaNoVirtual());
    exec_plugin_call_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.exec_plugin_call)
  return exec_plugin_call_;
}
inline void Container::set_allocated_exec_plugin_call(::machinetalk::Emc_Exec_Plugin_Ca1l* exec_plugin_call) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(exec_plugin_call_);
  }
  if (exec_plugin_call) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      exec_plugin_call = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, exec_plugin_call, submessage_arena);
    }
    set_has_exec_plugin_call();
  } else {
    clear_has_exec_plugin_call();
  }
  exec_plugin_call_ = exec_plugin_call;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.exec_plugin_call)
}

// optional .machinetalk.Emc_Io_Plugin_Call io_plugin_call = 590;
inline bool Container::has_io_plugin_call() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void Container::set_has_io_plugin_call() {
  _has_bits_[1] |= 0x00080000u;
}
inline void Container::clear_has_io_plugin_call() {
  _has_bits_[1] &= ~0x00080000u;
}
inline const ::machinetalk::Emc_Io_Plugin_Call& Container::_internal_io_plugin_call() const {
  return *io_plugin_call_;
}
inline const ::machinetalk::Emc_Io_Plugin_Call& Container::io_plugin_call() const {
  const ::machinetalk::Emc_Io_Plugin_Call* p = io_plugin_call_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.io_plugin_call)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Emc_Io_Plugin_Call*>(
      &::machinetalk::_Emc_Io_Plugin_Call_default_instance_);
}
inline ::machinetalk::Emc_Io_Plugin_Call* Container::release_io_plugin_call() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.io_plugin_call)
  clear_has_io_plugin_call();
  ::machinetalk::Emc_Io_Plugin_Call* temp = io_plugin_call_;
  io_plugin_call_ = NULL;
  return temp;
}
inline ::machinetalk::Emc_Io_Plugin_Call* Container::mutable_io_plugin_call() {
  set_has_io_plugin_call();
  if (io_plugin_call_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Emc_Io_Plugin_Call>(GetArenaNoVirtual());
    io_plugin_call_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.io_plugin_call)
  return io_plugin_call_;
}
inline void Container::set_allocated_io_plugin_call(::machinetalk::Emc_Io_Plugin_Call* io_plugin_call) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(io_plugin_call_);
  }
  if (io_plugin_call) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      io_plugin_call = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, io_plugin_call, submessage_arena);
    }
    set_has_io_plugin_call();
  } else {
    clear_has_io_plugin_call();
  }
  io_plugin_call_ = io_plugin_call;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.io_plugin_call)
}

// optional .machinetalk.EmcStatusConfig emc_status_config = 600 [(.nanopb) = {
inline bool Container::has_emc_status_config() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void Container::set_has_emc_status_config() {
  _has_bits_[1] |= 0x00100000u;
}
inline void Container::clear_has_emc_status_config() {
  _has_bits_[1] &= ~0x00100000u;
}
inline const ::machinetalk::EmcStatusConfig& Container::_internal_emc_status_config() const {
  return *emc_status_config_;
}
inline const ::machinetalk::EmcStatusConfig& Container::emc_status_config() const {
  const ::machinetalk::EmcStatusConfig* p = emc_status_config_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.emc_status_config)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcStatusConfig*>(
      &::machinetalk::_EmcStatusConfig_default_instance_);
}
inline ::machinetalk::EmcStatusConfig* Container::release_emc_status_config() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.emc_status_config)
  clear_has_emc_status_config();
  ::machinetalk::EmcStatusConfig* temp = emc_status_config_;
  emc_status_config_ = NULL;
  return temp;
}
inline ::machinetalk::EmcStatusConfig* Container::mutable_emc_status_config() {
  set_has_emc_status_config();
  if (emc_status_config_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcStatusConfig>(GetArenaNoVirtual());
    emc_status_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.emc_status_config)
  return emc_status_config_;
}
inline void Container::set_allocated_emc_status_config(::machinetalk::EmcStatusConfig* emc_status_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(emc_status_config_);
  }
  if (emc_status_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      emc_status_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, emc_status_config, submessage_arena);
    }
    set_has_emc_status_config();
  } else {
    clear_has_emc_status_config();
  }
  emc_status_config_ = emc_status_config;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.emc_status_config)
}

// optional .machinetalk.EmcStatusMotion emc_status_motion = 601 [(.nanopb) = {
inline bool Container::has_emc_status_motion() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void Container::set_has_emc_status_motion() {
  _has_bits_[1] |= 0x00200000u;
}
inline void Container::clear_has_emc_status_motion() {
  _has_bits_[1] &= ~0x00200000u;
}
inline const ::machinetalk::EmcStatusMotion& Container::_internal_emc_status_motion() const {
  return *emc_status_motion_;
}
inline const ::machinetalk::EmcStatusMotion& Container::emc_status_motion() const {
  const ::machinetalk::EmcStatusMotion* p = emc_status_motion_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.emc_status_motion)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcStatusMotion*>(
      &::machinetalk::_EmcStatusMotion_default_instance_);
}
inline ::machinetalk::EmcStatusMotion* Container::release_emc_status_motion() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.emc_status_motion)
  clear_has_emc_status_motion();
  ::machinetalk::EmcStatusMotion* temp = emc_status_motion_;
  emc_status_motion_ = NULL;
  return temp;
}
inline ::machinetalk::EmcStatusMotion* Container::mutable_emc_status_motion() {
  set_has_emc_status_motion();
  if (emc_status_motion_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcStatusMotion>(GetArenaNoVirtual());
    emc_status_motion_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.emc_status_motion)
  return emc_status_motion_;
}
inline void Container::set_allocated_emc_status_motion(::machinetalk::EmcStatusMotion* emc_status_motion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(emc_status_motion_);
  }
  if (emc_status_motion) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      emc_status_motion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, emc_status_motion, submessage_arena);
    }
    set_has_emc_status_motion();
  } else {
    clear_has_emc_status_motion();
  }
  emc_status_motion_ = emc_status_motion;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.emc_status_motion)
}

// optional .machinetalk.EmcStatusIo emc_status_io = 602 [(.nanopb) = {
inline bool Container::has_emc_status_io() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void Container::set_has_emc_status_io() {
  _has_bits_[1] |= 0x00400000u;
}
inline void Container::clear_has_emc_status_io() {
  _has_bits_[1] &= ~0x00400000u;
}
inline const ::machinetalk::EmcStatusIo& Container::_internal_emc_status_io() const {
  return *emc_status_io_;
}
inline const ::machinetalk::EmcStatusIo& Container::emc_status_io() const {
  const ::machinetalk::EmcStatusIo* p = emc_status_io_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.emc_status_io)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcStatusIo*>(
      &::machinetalk::_EmcStatusIo_default_instance_);
}
inline ::machinetalk::EmcStatusIo* Container::release_emc_status_io() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.emc_status_io)
  clear_has_emc_status_io();
  ::machinetalk::EmcStatusIo* temp = emc_status_io_;
  emc_status_io_ = NULL;
  return temp;
}
inline ::machinetalk::EmcStatusIo* Container::mutable_emc_status_io() {
  set_has_emc_status_io();
  if (emc_status_io_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcStatusIo>(GetArenaNoVirtual());
    emc_status_io_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.emc_status_io)
  return emc_status_io_;
}
inline void Container::set_allocated_emc_status_io(::machinetalk::EmcStatusIo* emc_status_io) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(emc_status_io_);
  }
  if (emc_status_io) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      emc_status_io = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, emc_status_io, submessage_arena);
    }
    set_has_emc_status_io();
  } else {
    clear_has_emc_status_io();
  }
  emc_status_io_ = emc_status_io;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.emc_status_io)
}

// optional .machinetalk.EmcStatusTask emc_status_task = 603 [(.nanopb) = {
inline bool Container::has_emc_status_task() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void Container::set_has_emc_status_task() {
  _has_bits_[1] |= 0x00800000u;
}
inline void Container::clear_has_emc_status_task() {
  _has_bits_[1] &= ~0x00800000u;
}
inline const ::machinetalk::EmcStatusTask& Container::_internal_emc_status_task() const {
  return *emc_status_task_;
}
inline const ::machinetalk::EmcStatusTask& Container::emc_status_task() const {
  const ::machinetalk::EmcStatusTask* p = emc_status_task_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.emc_status_task)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcStatusTask*>(
      &::machinetalk::_EmcStatusTask_default_instance_);
}
inline ::machinetalk::EmcStatusTask* Container::release_emc_status_task() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.emc_status_task)
  clear_has_emc_status_task();
  ::machinetalk::EmcStatusTask* temp = emc_status_task_;
  emc_status_task_ = NULL;
  return temp;
}
inline ::machinetalk::EmcStatusTask* Container::mutable_emc_status_task() {
  set_has_emc_status_task();
  if (emc_status_task_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcStatusTask>(GetArenaNoVirtual());
    emc_status_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.emc_status_task)
  return emc_status_task_;
}
inline void Container::set_allocated_emc_status_task(::machinetalk::EmcStatusTask* emc_status_task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(emc_status_task_);
  }
  if (emc_status_task) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      emc_status_task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, emc_status_task, submessage_arena);
    }
    set_has_emc_status_task();
  } else {
    clear_has_emc_status_task();
  }
  emc_status_task_ = emc_status_task;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.emc_status_task)
}

// optional .machinetalk.EmcStatusInterp emc_status_interp = 604 [(.nanopb) = {
inline bool Container::has_emc_status_interp() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void Container::set_has_emc_status_interp() {
  _has_bits_[1] |= 0x01000000u;
}
inline void Container::clear_has_emc_status_interp() {
  _has_bits_[1] &= ~0x01000000u;
}
inline const ::machinetalk::EmcStatusInterp& Container::_internal_emc_status_interp() const {
  return *emc_status_interp_;
}
inline const ::machinetalk::EmcStatusInterp& Container::emc_status_interp() const {
  const ::machinetalk::EmcStatusInterp* p = emc_status_interp_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.emc_status_interp)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcStatusInterp*>(
      &::machinetalk::_EmcStatusInterp_default_instance_);
}
inline ::machinetalk::EmcStatusInterp* Container::release_emc_status_interp() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.emc_status_interp)
  clear_has_emc_status_interp();
  ::machinetalk::EmcStatusInterp* temp = emc_status_interp_;
  emc_status_interp_ = NULL;
  return temp;
}
inline ::machinetalk::EmcStatusInterp* Container::mutable_emc_status_interp() {
  set_has_emc_status_interp();
  if (emc_status_interp_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcStatusInterp>(GetArenaNoVirtual());
    emc_status_interp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.emc_status_interp)
  return emc_status_interp_;
}
inline void Container::set_allocated_emc_status_interp(::machinetalk::EmcStatusInterp* emc_status_interp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(emc_status_interp_);
  }
  if (emc_status_interp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      emc_status_interp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, emc_status_interp, submessage_arena);
    }
    set_has_emc_status_interp();
  } else {
    clear_has_emc_status_interp();
  }
  emc_status_interp_ = emc_status_interp;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.emc_status_interp)
}

// optional .machinetalk.EmcStatusUI emc_status_ui = 605 [(.nanopb) = {
inline bool Container::has_emc_status_ui() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void Container::set_has_emc_status_ui() {
  _has_bits_[1] |= 0x02000000u;
}
inline void Container::clear_has_emc_status_ui() {
  _has_bits_[1] &= ~0x02000000u;
}
inline const ::machinetalk::EmcStatusUI& Container::_internal_emc_status_ui() const {
  return *emc_status_ui_;
}
inline const ::machinetalk::EmcStatusUI& Container::emc_status_ui() const {
  const ::machinetalk::EmcStatusUI* p = emc_status_ui_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.emc_status_ui)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcStatusUI*>(
      &::machinetalk::_EmcStatusUI_default_instance_);
}
inline ::machinetalk::EmcStatusUI* Container::release_emc_status_ui() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.emc_status_ui)
  clear_has_emc_status_ui();
  ::machinetalk::EmcStatusUI* temp = emc_status_ui_;
  emc_status_ui_ = NULL;
  return temp;
}
inline ::machinetalk::EmcStatusUI* Container::mutable_emc_status_ui() {
  set_has_emc_status_ui();
  if (emc_status_ui_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcStatusUI>(GetArenaNoVirtual());
    emc_status_ui_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.emc_status_ui)
  return emc_status_ui_;
}
inline void Container::set_allocated_emc_status_ui(::machinetalk::EmcStatusUI* emc_status_ui) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(emc_status_ui_);
  }
  if (emc_status_ui) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      emc_status_ui = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, emc_status_ui, submessage_arena);
    }
    set_has_emc_status_ui();
  } else {
    clear_has_emc_status_ui();
  }
  emc_status_ui_ = emc_status_ui;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.emc_status_ui)
}

// optional .machinetalk.EmcCommandParameters emc_command_params = 610 [(.nanopb) = {
inline bool Container::has_emc_command_params() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void Container::set_has_emc_command_params() {
  _has_bits_[1] |= 0x04000000u;
}
inline void Container::clear_has_emc_command_params() {
  _has_bits_[1] &= ~0x04000000u;
}
inline const ::machinetalk::EmcCommandParameters& Container::_internal_emc_command_params() const {
  return *emc_command_params_;
}
inline const ::machinetalk::EmcCommandParameters& Container::emc_command_params() const {
  const ::machinetalk::EmcCommandParameters* p = emc_command_params_;
  // @@protoc_insertion_point(field_get:machinetalk.Container.emc_command_params)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::EmcCommandParameters*>(
      &::machinetalk::_EmcCommandParameters_default_instance_);
}
inline ::machinetalk::EmcCommandParameters* Container::release_emc_command_params() {
  // @@protoc_insertion_point(field_release:machinetalk.Container.emc_command_params)
  clear_has_emc_command_params();
  ::machinetalk::EmcCommandParameters* temp = emc_command_params_;
  emc_command_params_ = NULL;
  return temp;
}
inline ::machinetalk::EmcCommandParameters* Container::mutable_emc_command_params() {
  set_has_emc_command_params();
  if (emc_command_params_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::EmcCommandParameters>(GetArenaNoVirtual());
    emc_command_params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Container.emc_command_params)
  return emc_command_params_;
}
inline void Container::set_allocated_emc_command_params(::machinetalk::EmcCommandParameters* emc_command_params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(emc_command_params_);
  }
  if (emc_command_params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      emc_command_params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, emc_command_params, submessage_arena);
    }
    set_has_emc_command_params();
  } else {
    clear_has_emc_command_params();
  }
  emc_command_params_ = emc_command_params;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Container.emc_command_params)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace machinetalk

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_machinetalk_2fprotobuf_2fmessage_2eproto
