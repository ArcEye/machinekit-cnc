// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: machinetalk/protobuf/object.proto

#ifndef PROTOBUF_INCLUDED_machinetalk_2fprotobuf_2fobject_2eproto
#define PROTOBUF_INCLUDED_machinetalk_2fprotobuf_2fobject_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "machinetalk/protobuf/nanopb.pb.h"
#include "machinetalk/protobuf/types.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_machinetalk_2fprotobuf_2fobject_2eproto 

namespace protobuf_machinetalk_2fprotobuf_2fobject_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[16];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_machinetalk_2fprotobuf_2fobject_2eproto
namespace machinetalk {
class AnError;
class AnErrorDefaultTypeInternal;
extern AnErrorDefaultTypeInternal _AnError_default_instance_;
class Component;
class ComponentDefaultTypeInternal;
extern ComponentDefaultTypeInternal _Component_default_instance_;
class Function;
class FunctionDefaultTypeInternal;
extern FunctionDefaultTypeInternal _Function_default_instance_;
class Group;
class GroupDefaultTypeInternal;
extern GroupDefaultTypeInternal _Group_default_instance_;
class Inst;
class InstDefaultTypeInternal;
extern InstDefaultTypeInternal _Inst_default_instance_;
class Instance;
class InstanceDefaultTypeInternal;
extern InstanceDefaultTypeInternal _Instance_default_instance_;
class Member;
class MemberDefaultTypeInternal;
extern MemberDefaultTypeInternal _Member_default_instance_;
class Originator;
class OriginatorDefaultTypeInternal;
extern OriginatorDefaultTypeInternal _Originator_default_instance_;
class Param;
class ParamDefaultTypeInternal;
extern ParamDefaultTypeInternal _Param_default_instance_;
class Pin;
class PinDefaultTypeInternal;
extern PinDefaultTypeInternal _Pin_default_instance_;
class ProtocolParameters;
class ProtocolParametersDefaultTypeInternal;
extern ProtocolParametersDefaultTypeInternal _ProtocolParameters_default_instance_;
class Ring;
class RingDefaultTypeInternal;
extern RingDefaultTypeInternal _Ring_default_instance_;
class ServiceAnnouncement;
class ServiceAnnouncementDefaultTypeInternal;
extern ServiceAnnouncementDefaultTypeInternal _ServiceAnnouncement_default_instance_;
class Signal;
class SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class Thread;
class ThreadDefaultTypeInternal;
extern ThreadDefaultTypeInternal _Thread_default_instance_;
class Vtable;
class VtableDefaultTypeInternal;
extern VtableDefaultTypeInternal _Vtable_default_instance_;
}  // namespace machinetalk
namespace google {
namespace protobuf {
template<> ::machinetalk::AnError* Arena::CreateMaybeMessage<::machinetalk::AnError>(Arena*);
template<> ::machinetalk::Component* Arena::CreateMaybeMessage<::machinetalk::Component>(Arena*);
template<> ::machinetalk::Function* Arena::CreateMaybeMessage<::machinetalk::Function>(Arena*);
template<> ::machinetalk::Group* Arena::CreateMaybeMessage<::machinetalk::Group>(Arena*);
template<> ::machinetalk::Inst* Arena::CreateMaybeMessage<::machinetalk::Inst>(Arena*);
template<> ::machinetalk::Instance* Arena::CreateMaybeMessage<::machinetalk::Instance>(Arena*);
template<> ::machinetalk::Member* Arena::CreateMaybeMessage<::machinetalk::Member>(Arena*);
template<> ::machinetalk::Originator* Arena::CreateMaybeMessage<::machinetalk::Originator>(Arena*);
template<> ::machinetalk::Param* Arena::CreateMaybeMessage<::machinetalk::Param>(Arena*);
template<> ::machinetalk::Pin* Arena::CreateMaybeMessage<::machinetalk::Pin>(Arena*);
template<> ::machinetalk::ProtocolParameters* Arena::CreateMaybeMessage<::machinetalk::ProtocolParameters>(Arena*);
template<> ::machinetalk::Ring* Arena::CreateMaybeMessage<::machinetalk::Ring>(Arena*);
template<> ::machinetalk::ServiceAnnouncement* Arena::CreateMaybeMessage<::machinetalk::ServiceAnnouncement>(Arena*);
template<> ::machinetalk::Signal* Arena::CreateMaybeMessage<::machinetalk::Signal>(Arena*);
template<> ::machinetalk::Thread* Arena::CreateMaybeMessage<::machinetalk::Thread>(Arena*);
template<> ::machinetalk::Vtable* Arena::CreateMaybeMessage<::machinetalk::Vtable>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace machinetalk {

// ===================================================================

class Instance : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Instance) */ {
 public:
  Instance();
  virtual ~Instance();

  Instance(const Instance& from);

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Instance(Instance&& from) noexcept
    : Instance() {
    *this = ::std::move(from);
  }

  inline Instance& operator=(Instance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Instance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Instance* internal_default_instance() {
    return reinterpret_cast<const Instance*>(
               &_Instance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Instance* other);
  friend void swap(Instance& a, Instance& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Instance* New() const final {
    return CreateMaybeMessage<Instance>(NULL);
  }

  Instance* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Instance>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Instance& from);
  void MergeFrom(const Instance& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Instance* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional sfixed32 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:machinetalk.Instance)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fobject_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServiceAnnouncement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.ServiceAnnouncement) */ {
 public:
  ServiceAnnouncement();
  virtual ~ServiceAnnouncement();

  ServiceAnnouncement(const ServiceAnnouncement& from);

  inline ServiceAnnouncement& operator=(const ServiceAnnouncement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServiceAnnouncement(ServiceAnnouncement&& from) noexcept
    : ServiceAnnouncement() {
    *this = ::std::move(from);
  }

  inline ServiceAnnouncement& operator=(ServiceAnnouncement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceAnnouncement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServiceAnnouncement* internal_default_instance() {
    return reinterpret_cast<const ServiceAnnouncement*>(
               &_ServiceAnnouncement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ServiceAnnouncement* other);
  friend void swap(ServiceAnnouncement& a, ServiceAnnouncement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServiceAnnouncement* New() const final {
    return CreateMaybeMessage<ServiceAnnouncement>(NULL);
  }

  ServiceAnnouncement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServiceAnnouncement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServiceAnnouncement& from);
  void MergeFrom(const ServiceAnnouncement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceAnnouncement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uri = 6;
  bool has_uri() const;
  void clear_uri();
  static const int kUriFieldNumber = 6;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // optional string description = 7;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 7;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // required fixed32 version = 2 [default = 0];
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // required fixed32 instance = 3 [default = 0];
  bool has_instance() const;
  void clear_instance();
  static const int kInstanceFieldNumber = 3;
  ::google::protobuf::uint32 instance() const;
  void set_instance(::google::protobuf::uint32 value);

  // required .machinetalk.ServiceType stype = 1;
  bool has_stype() const;
  void clear_stype();
  static const int kStypeFieldNumber = 1;
  ::machinetalk::ServiceType stype() const;
  void set_stype(::machinetalk::ServiceType value);

  // required .machinetalk.ServiceAPI api = 8;
  bool has_api() const;
  void clear_api();
  static const int kApiFieldNumber = 8;
  ::machinetalk::ServiceAPI api() const;
  void set_api(::machinetalk::ServiceAPI value);

  // @@protoc_insertion_point(class_scope:machinetalk.ServiceAnnouncement)
 private:
  void set_has_stype();
  void clear_has_stype();
  void set_has_version();
  void clear_has_version();
  void set_has_instance();
  void clear_has_instance();
  void set_has_api();
  void clear_has_api();
  void set_has_uri();
  void clear_has_uri();
  void set_has_description();
  void clear_has_description();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 instance_;
  int stype_;
  int api_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fobject_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Originator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Originator) */ {
 public:
  Originator();
  virtual ~Originator();

  Originator(const Originator& from);

  inline Originator& operator=(const Originator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Originator(Originator&& from) noexcept
    : Originator() {
    *this = ::std::move(from);
  }

  inline Originator& operator=(Originator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Originator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Originator* internal_default_instance() {
    return reinterpret_cast<const Originator*>(
               &_Originator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Originator* other);
  friend void swap(Originator& a, Originator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Originator* New() const final {
    return CreateMaybeMessage<Originator>(NULL);
  }

  Originator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Originator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Originator& from);
  void MergeFrom(const Originator& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Originator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .machinetalk.Instance instance = 5;
  bool has_instance() const;
  void clear_instance();
  static const int kInstanceFieldNumber = 5;
  private:
  const ::machinetalk::Instance& _internal_instance() const;
  public:
  const ::machinetalk::Instance& instance() const;
  ::machinetalk::Instance* release_instance();
  ::machinetalk::Instance* mutable_instance();
  void set_allocated_instance(::machinetalk::Instance* instance);

  // optional sfixed32 id = 4;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 4;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional .machinetalk.OriginType origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  ::machinetalk::OriginType origin() const;
  void set_origin(::machinetalk::OriginType value);

  // optional .machinetalk.OriginDetail detail = 2;
  bool has_detail() const;
  void clear_detail();
  static const int kDetailFieldNumber = 2;
  ::machinetalk::OriginDetail detail() const;
  void set_detail(::machinetalk::OriginDetail value);

  // @@protoc_insertion_point(class_scope:machinetalk.Originator)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_detail();
  void clear_has_detail();
  void set_has_name();
  void clear_has_name();
  void set_has_id();
  void clear_has_id();
  void set_has_instance();
  void clear_has_instance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::machinetalk::Instance* instance_;
  ::google::protobuf::int32 id_;
  int origin_;
  int detail_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fobject_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AnError : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.AnError) */ {
 public:
  AnError();
  virtual ~AnError();

  AnError(const AnError& from);

  inline AnError& operator=(const AnError& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnError(AnError&& from) noexcept
    : AnError() {
    *this = ::std::move(from);
  }

  inline AnError& operator=(AnError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnError* internal_default_instance() {
    return reinterpret_cast<const AnError*>(
               &_AnError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AnError* other);
  friend void swap(AnError& a, AnError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnError* New() const final {
    return CreateMaybeMessage<AnError>(NULL);
  }

  AnError* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AnError>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AnError& from);
  void MergeFrom(const AnError& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string error_text = 3;
  bool has_error_text() const;
  void clear_error_text();
  static const int kErrorTextFieldNumber = 3;
  const ::std::string& error_text() const;
  void set_error_text(const ::std::string& value);
  #if LANG_CXX11
  void set_error_text(::std::string&& value);
  #endif
  void set_error_text(const char* value);
  void set_error_text(const char* value, size_t size);
  ::std::string* mutable_error_text();
  ::std::string* release_error_text();
  void set_allocated_error_text(::std::string* error_text);

  // optional .machinetalk.Originator origin = 4;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 4;
  private:
  const ::machinetalk::Originator& _internal_origin() const;
  public:
  const ::machinetalk::Originator& origin() const;
  ::machinetalk::Originator* release_origin();
  ::machinetalk::Originator* mutable_origin();
  void set_allocated_origin(::machinetalk::Originator* origin);

  // required sfixed32 error_code = 1;
  bool has_error_code() const;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::int32 error_code() const;
  void set_error_code(::google::protobuf::int32 value);

  // optional .machinetalk.Severity severity = 2;
  bool has_severity() const;
  void clear_severity();
  static const int kSeverityFieldNumber = 2;
  ::machinetalk::Severity severity() const;
  void set_severity(::machinetalk::Severity value);

  // @@protoc_insertion_point(class_scope:machinetalk.AnError)
 private:
  void set_has_error_code();
  void clear_has_error_code();
  void set_has_severity();
  void clear_has_severity();
  void set_has_error_text();
  void clear_has_error_text();
  void set_has_origin();
  void clear_has_origin();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_text_;
  ::machinetalk::Originator* origin_;
  ::google::protobuf::int32 error_code_;
  int severity_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fobject_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Pin) */ {
 public:
  Pin();
  virtual ~Pin();

  Pin(const Pin& from);

  inline Pin& operator=(const Pin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pin(Pin&& from) noexcept
    : Pin() {
    *this = ::std::move(from);
  }

  inline Pin& operator=(Pin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pin* internal_default_instance() {
    return reinterpret_cast<const Pin*>(
               &_Pin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Pin* other);
  friend void swap(Pin& a, Pin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pin* New() const final {
    return CreateMaybeMessage<Pin>(NULL);
  }

  Pin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pin& from);
  void MergeFrom(const Pin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string oldname = 11;
  bool has_oldname() const;
  void clear_oldname();
  static const int kOldnameFieldNumber = 11;
  const ::std::string& oldname() const;
  void set_oldname(const ::std::string& value);
  #if LANG_CXX11
  void set_oldname(::std::string&& value);
  #endif
  void set_oldname(const char* value);
  void set_oldname(const char* value, size_t size);
  ::std::string* mutable_oldname();
  ::std::string* release_oldname();
  void set_allocated_oldname(::std::string* oldname);

  // optional fixed32 handle = 3;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 3;
  ::google::protobuf::uint32 handle() const;
  void set_handle(::google::protobuf::uint32 value);

  // optional sfixed32 hals32 = 7;
  bool has_hals32() const;
  void clear_hals32();
  static const int kHals32FieldNumber = 7;
  ::google::protobuf::int32 hals32() const;
  void set_hals32(::google::protobuf::int32 value);

  // optional double halfloat = 6;
  bool has_halfloat() const;
  void clear_halfloat();
  static const int kHalfloatFieldNumber = 6;
  double halfloat() const;
  void set_halfloat(double value);

  // optional bool halbit = 5;
  bool has_halbit() const;
  void clear_halbit();
  static const int kHalbitFieldNumber = 5;
  bool halbit() const;
  void set_halbit(bool value);

  // optional bool linked = 10;
  bool has_linked() const;
  void clear_linked();
  static const int kLinkedFieldNumber = 10;
  bool linked() const;
  void set_linked(bool value);

  // optional fixed32 halu32 = 8;
  bool has_halu32() const;
  void clear_halu32();
  static const int kHalu32FieldNumber = 8;
  ::google::protobuf::uint32 halu32() const;
  void set_halu32(::google::protobuf::uint32 value);

  // optional sfixed32 owner = 9;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 9;
  ::google::protobuf::int32 owner() const;
  void set_owner(::google::protobuf::int32 value);

  // optional fixed32 flags = 13;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 13;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // optional double epsilon = 12;
  bool has_epsilon() const;
  void clear_epsilon();
  static const int kEpsilonFieldNumber = 12;
  double epsilon() const;
  void set_epsilon(double value);

  // optional .machinetalk.ValueType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::machinetalk::ValueType type() const;
  void set_type(::machinetalk::ValueType value);

  // optional .machinetalk.HalPinDirection dir = 4;
  bool has_dir() const;
  void clear_dir();
  static const int kDirFieldNumber = 4;
  ::machinetalk::HalPinDirection dir() const;
  void set_dir(::machinetalk::HalPinDirection value);

  // @@protoc_insertion_point(class_scope:machinetalk.Pin)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_name();
  void clear_has_name();
  void set_has_handle();
  void clear_has_handle();
  void set_has_dir();
  void clear_has_dir();
  void set_has_halbit();
  void clear_has_halbit();
  void set_has_halfloat();
  void clear_has_halfloat();
  void set_has_hals32();
  void clear_has_hals32();
  void set_has_halu32();
  void clear_has_halu32();
  void set_has_owner();
  void clear_has_owner();
  void set_has_linked();
  void clear_has_linked();
  void set_has_oldname();
  void clear_has_oldname();
  void set_has_epsilon();
  void clear_has_epsilon();
  void set_has_flags();
  void clear_has_flags();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr oldname_;
  ::google::protobuf::uint32 handle_;
  ::google::protobuf::int32 hals32_;
  double halfloat_;
  bool halbit_;
  bool linked_;
  ::google::protobuf::uint32 halu32_;
  ::google::protobuf::int32 owner_;
  ::google::protobuf::uint32 flags_;
  double epsilon_;
  int type_;
  int dir_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fobject_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Signal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Signal) */ {
 public:
  Signal();
  virtual ~Signal();

  Signal(const Signal& from);

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal(Signal&& from) noexcept
    : Signal() {
    *this = ::std::move(from);
  }

  inline Signal& operator=(Signal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Signal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Signal* other);
  friend void swap(Signal& a, Signal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal* New() const final {
    return CreateMaybeMessage<Signal>(NULL);
  }

  Signal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Signal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string strval = 9;
  bool has_strval() const;
  void clear_strval();
  static const int kStrvalFieldNumber = 9;
  const ::std::string& strval() const;
  void set_strval(const ::std::string& value);
  #if LANG_CXX11
  void set_strval(::std::string&& value);
  #endif
  void set_strval(const char* value);
  void set_strval(const char* value, size_t size);
  ::std::string* mutable_strval();
  ::std::string* release_strval();
  void set_allocated_strval(::std::string* strval);

  // optional bytes blob = 10;
  bool has_blob() const;
  void clear_blob();
  static const int kBlobFieldNumber = 10;
  const ::std::string& blob() const;
  void set_blob(const ::std::string& value);
  #if LANG_CXX11
  void set_blob(::std::string&& value);
  #endif
  void set_blob(const char* value);
  void set_blob(const void* value, size_t size);
  ::std::string* mutable_blob();
  ::std::string* release_blob();
  void set_allocated_blob(::std::string* blob);

  // optional fixed32 handle = 3;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 3;
  ::google::protobuf::uint32 handle() const;
  void set_handle(::google::protobuf::uint32 value);

  // optional bool halbit = 5;
  bool has_halbit() const;
  void clear_halbit();
  static const int kHalbitFieldNumber = 5;
  bool halbit() const;
  void set_halbit(bool value);

  // optional double halfloat = 6;
  bool has_halfloat() const;
  void clear_halfloat();
  static const int kHalfloatFieldNumber = 6;
  double halfloat() const;
  void set_halfloat(double value);

  // optional sfixed32 hals32 = 7;
  bool has_hals32() const;
  void clear_hals32();
  static const int kHals32FieldNumber = 7;
  ::google::protobuf::int32 hals32() const;
  void set_hals32(::google::protobuf::int32 value);

  // optional fixed32 halu32 = 8;
  bool has_halu32() const;
  void clear_halu32();
  static const int kHalu32FieldNumber = 8;
  ::google::protobuf::uint32 halu32() const;
  void set_halu32(::google::protobuf::uint32 value);

  // optional fixed32 readers = 11;
  bool has_readers() const;
  void clear_readers();
  static const int kReadersFieldNumber = 11;
  ::google::protobuf::uint32 readers() const;
  void set_readers(::google::protobuf::uint32 value);

  // optional fixed32 writers = 12;
  bool has_writers() const;
  void clear_writers();
  static const int kWritersFieldNumber = 12;
  ::google::protobuf::uint32 writers() const;
  void set_writers(::google::protobuf::uint32 value);

  // optional fixed32 bidirs = 13;
  bool has_bidirs() const;
  void clear_bidirs();
  static const int kBidirsFieldNumber = 13;
  ::google::protobuf::uint32 bidirs() const;
  void set_bidirs(::google::protobuf::uint32 value);

  // optional .machinetalk.ValueType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::machinetalk::ValueType type() const;
  void set_type(::machinetalk::ValueType value);

  // @@protoc_insertion_point(class_scope:machinetalk.Signal)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_name();
  void clear_has_name();
  void set_has_handle();
  void clear_has_handle();
  void set_has_halbit();
  void clear_has_halbit();
  void set_has_halfloat();
  void clear_has_halfloat();
  void set_has_hals32();
  void clear_has_hals32();
  void set_has_halu32();
  void clear_has_halu32();
  void set_has_strval();
  void clear_has_strval();
  void set_has_blob();
  void clear_has_blob();
  void set_has_readers();
  void clear_has_readers();
  void set_has_writers();
  void clear_has_writers();
  void set_has_bidirs();
  void clear_has_bidirs();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr strval_;
  ::google::protobuf::internal::ArenaStringPtr blob_;
  ::google::protobuf::uint32 handle_;
  bool halbit_;
  double halfloat_;
  ::google::protobuf::int32 hals32_;
  ::google::protobuf::uint32 halu32_;
  ::google::protobuf::uint32 readers_;
  ::google::protobuf::uint32 writers_;
  ::google::protobuf::uint32 bidirs_;
  int type_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fobject_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Param : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Param) */ {
 public:
  Param();
  virtual ~Param();

  Param(const Param& from);

  inline Param& operator=(const Param& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Param(Param&& from) noexcept
    : Param() {
    *this = ::std::move(from);
  }

  inline Param& operator=(Param&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Param& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Param* internal_default_instance() {
    return reinterpret_cast<const Param*>(
               &_Param_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Param* other);
  friend void swap(Param& a, Param& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Param* New() const final {
    return CreateMaybeMessage<Param>(NULL);
  }

  Param* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Param>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Param& from);
  void MergeFrom(const Param& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Param* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string strval = 9;
  bool has_strval() const;
  void clear_strval();
  static const int kStrvalFieldNumber = 9;
  const ::std::string& strval() const;
  void set_strval(const ::std::string& value);
  #if LANG_CXX11
  void set_strval(::std::string&& value);
  #endif
  void set_strval(const char* value);
  void set_strval(const char* value, size_t size);
  ::std::string* mutable_strval();
  ::std::string* release_strval();
  void set_allocated_strval(::std::string* strval);

  // optional bytes blob = 10;
  bool has_blob() const;
  void clear_blob();
  static const int kBlobFieldNumber = 10;
  const ::std::string& blob() const;
  void set_blob(const ::std::string& value);
  #if LANG_CXX11
  void set_blob(::std::string&& value);
  #endif
  void set_blob(const char* value);
  void set_blob(const void* value, size_t size);
  ::std::string* mutable_blob();
  ::std::string* release_blob();
  void set_allocated_blob(::std::string* blob);

  // optional string oldname = 12;
  bool has_oldname() const;
  void clear_oldname();
  static const int kOldnameFieldNumber = 12;
  const ::std::string& oldname() const;
  void set_oldname(const ::std::string& value);
  #if LANG_CXX11
  void set_oldname(::std::string&& value);
  #endif
  void set_oldname(const char* value);
  void set_oldname(const char* value, size_t size);
  ::std::string* mutable_oldname();
  ::std::string* release_oldname();
  void set_allocated_oldname(::std::string* oldname);

  // optional fixed32 handle = 3;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 3;
  ::google::protobuf::uint32 handle() const;
  void set_handle(::google::protobuf::uint32 value);

  // optional bool halbit = 5;
  bool has_halbit() const;
  void clear_halbit();
  static const int kHalbitFieldNumber = 5;
  bool halbit() const;
  void set_halbit(bool value);

  // optional double halfloat = 6;
  bool has_halfloat() const;
  void clear_halfloat();
  static const int kHalfloatFieldNumber = 6;
  double halfloat() const;
  void set_halfloat(double value);

  // optional sfixed32 hals32 = 7;
  bool has_hals32() const;
  void clear_hals32();
  static const int kHals32FieldNumber = 7;
  ::google::protobuf::int32 hals32() const;
  void set_hals32(::google::protobuf::int32 value);

  // optional fixed32 halu32 = 8;
  bool has_halu32() const;
  void clear_halu32();
  static const int kHalu32FieldNumber = 8;
  ::google::protobuf::uint32 halu32() const;
  void set_halu32(::google::protobuf::uint32 value);

  // optional sfixed32 owner = 13;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 13;
  ::google::protobuf::int32 owner() const;
  void set_owner(::google::protobuf::int32 value);

  // optional sfixed32 runtime = 14;
  bool has_runtime() const;
  void clear_runtime();
  static const int kRuntimeFieldNumber = 14;
  ::google::protobuf::int32 runtime() const;
  void set_runtime(::google::protobuf::int32 value);

  // optional sfixed32 maytime = 15;
  bool has_maytime() const;
  void clear_maytime();
  static const int kMaytimeFieldNumber = 15;
  ::google::protobuf::int32 maytime() const;
  void set_maytime(::google::protobuf::int32 value);

  // optional .machinetalk.ValueType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::machinetalk::ValueType type() const;
  void set_type(::machinetalk::ValueType value);

  // optional .machinetalk.HalParamDirection dir = 11;
  bool has_dir() const;
  void clear_dir();
  static const int kDirFieldNumber = 11;
  ::machinetalk::HalParamDirection dir() const;
  void set_dir(::machinetalk::HalParamDirection value);

  // @@protoc_insertion_point(class_scope:machinetalk.Param)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_name();
  void clear_has_name();
  void set_has_handle();
  void clear_has_handle();
  void set_has_halbit();
  void clear_has_halbit();
  void set_has_halfloat();
  void clear_has_halfloat();
  void set_has_hals32();
  void clear_has_hals32();
  void set_has_halu32();
  void clear_has_halu32();
  void set_has_strval();
  void clear_has_strval();
  void set_has_blob();
  void clear_has_blob();
  void set_has_dir();
  void clear_has_dir();
  void set_has_oldname();
  void clear_has_oldname();
  void set_has_owner();
  void clear_has_owner();
  void set_has_runtime();
  void clear_has_runtime();
  void set_has_maytime();
  void clear_has_maytime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr strval_;
  ::google::protobuf::internal::ArenaStringPtr blob_;
  ::google::protobuf::internal::ArenaStringPtr oldname_;
  ::google::protobuf::uint32 handle_;
  bool halbit_;
  double halfloat_;
  ::google::protobuf::int32 hals32_;
  ::google::protobuf::uint32 halu32_;
  ::google::protobuf::int32 owner_;
  ::google::protobuf::int32 runtime_;
  ::google::protobuf::int32 maytime_;
  int type_;
  int dir_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fobject_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Function : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Function) */ {
 public:
  Function();
  virtual ~Function();

  Function(const Function& from);

  inline Function& operator=(const Function& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Function(Function&& from) noexcept
    : Function() {
    *this = ::std::move(from);
  }

  inline Function& operator=(Function&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Function& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Function* internal_default_instance() {
    return reinterpret_cast<const Function*>(
               &_Function_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Function* other);
  friend void swap(Function& a, Function& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Function* New() const final {
    return CreateMaybeMessage<Function>(NULL);
  }

  Function* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Function>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Function& from);
  void MergeFrom(const Function& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Function* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional fixed32 handle = 2;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 2;
  ::google::protobuf::uint32 handle() const;
  void set_handle(::google::protobuf::uint32 value);

  // optional fixed32 owner_id = 3;
  bool has_owner_id() const;
  void clear_owner_id();
  static const int kOwnerIdFieldNumber = 3;
  ::google::protobuf::uint32 owner_id() const;
  void set_owner_id(::google::protobuf::uint32 value);

  // optional fixed32 users = 4;
  bool has_users() const;
  void clear_users();
  static const int kUsersFieldNumber = 4;
  ::google::protobuf::uint32 users() const;
  void set_users(::google::protobuf::uint32 value);

  // optional fixed32 runtime = 5;
  bool has_runtime() const;
  void clear_runtime();
  static const int kRuntimeFieldNumber = 5;
  ::google::protobuf::uint32 runtime() const;
  void set_runtime(::google::protobuf::uint32 value);

  // optional fixed32 maxtime = 6;
  bool has_maxtime() const;
  void clear_maxtime();
  static const int kMaxtimeFieldNumber = 6;
  ::google::protobuf::uint32 maxtime() const;
  void set_maxtime(::google::protobuf::uint32 value);

  // optional .machinetalk.HalFunctType type = 8;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 8;
  ::machinetalk::HalFunctType type() const;
  void set_type(::machinetalk::HalFunctType value);

  // optional bool reentrant = 7;
  bool has_reentrant() const;
  void clear_reentrant();
  static const int kReentrantFieldNumber = 7;
  bool reentrant() const;
  void set_reentrant(bool value);

  // optional bool maxtime_increased = 9;
  bool has_maxtime_increased() const;
  void clear_maxtime_increased();
  static const int kMaxtimeIncreasedFieldNumber = 9;
  bool maxtime_increased() const;
  void set_maxtime_increased(bool value);

  // @@protoc_insertion_point(class_scope:machinetalk.Function)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_handle();
  void clear_has_handle();
  void set_has_owner_id();
  void clear_has_owner_id();
  void set_has_users();
  void clear_has_users();
  void set_has_runtime();
  void clear_has_runtime();
  void set_has_maxtime();
  void clear_has_maxtime();
  void set_has_reentrant();
  void clear_has_reentrant();
  void set_has_type();
  void clear_has_type();
  void set_has_maxtime_increased();
  void clear_has_maxtime_increased();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 handle_;
  ::google::protobuf::uint32 owner_id_;
  ::google::protobuf::uint32 users_;
  ::google::protobuf::uint32 runtime_;
  ::google::protobuf::uint32 maxtime_;
  int type_;
  bool reentrant_;
  bool maxtime_increased_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fobject_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Thread : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Thread) */ {
 public:
  Thread();
  virtual ~Thread();

  Thread(const Thread& from);

  inline Thread& operator=(const Thread& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Thread(Thread&& from) noexcept
    : Thread() {
    *this = ::std::move(from);
  }

  inline Thread& operator=(Thread&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Thread& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Thread* internal_default_instance() {
    return reinterpret_cast<const Thread*>(
               &_Thread_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Thread* other);
  friend void swap(Thread& a, Thread& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Thread* New() const final {
    return CreateMaybeMessage<Thread>(NULL);
  }

  Thread* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Thread>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Thread& from);
  void MergeFrom(const Thread& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Thread* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string function = 8;
  int function_size() const;
  void clear_function();
  static const int kFunctionFieldNumber = 8;
  const ::std::string& function(int index) const;
  ::std::string* mutable_function(int index);
  void set_function(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_function(int index, ::std::string&& value);
  #endif
  void set_function(int index, const char* value);
  void set_function(int index, const char* value, size_t size);
  ::std::string* add_function();
  void add_function(const ::std::string& value);
  #if LANG_CXX11
  void add_function(::std::string&& value);
  #endif
  void add_function(const char* value);
  void add_function(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& function() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_function();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional fixed32 handle = 2;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 2;
  ::google::protobuf::uint32 handle() const;
  void set_handle(::google::protobuf::uint32 value);

  // optional bool uses_fp = 3;
  bool has_uses_fp() const;
  void clear_uses_fp();
  static const int kUsesFpFieldNumber = 3;
  bool uses_fp() const;
  void set_uses_fp(bool value);

  // optional fixed32 period = 4;
  bool has_period() const;
  void clear_period();
  static const int kPeriodFieldNumber = 4;
  ::google::protobuf::uint32 period() const;
  void set_period(::google::protobuf::uint32 value);

  // optional sfixed32 priority = 5;
  bool has_priority() const;
  void clear_priority();
  static const int kPriorityFieldNumber = 5;
  ::google::protobuf::int32 priority() const;
  void set_priority(::google::protobuf::int32 value);

  // optional fixed32 task_id = 6;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 6;
  ::google::protobuf::uint32 task_id() const;
  void set_task_id(::google::protobuf::uint32 value);

  // optional fixed32 cpu_id = 7;
  bool has_cpu_id() const;
  void clear_cpu_id();
  static const int kCpuIdFieldNumber = 7;
  ::google::protobuf::uint32 cpu_id() const;
  void set_cpu_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:machinetalk.Thread)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_handle();
  void clear_has_handle();
  void set_has_uses_fp();
  void clear_has_uses_fp();
  void set_has_period();
  void clear_has_period();
  void set_has_priority();
  void clear_has_priority();
  void set_has_task_id();
  void clear_has_task_id();
  void set_has_cpu_id();
  void clear_has_cpu_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> function_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 handle_;
  bool uses_fp_;
  ::google::protobuf::uint32 period_;
  ::google::protobuf::int32 priority_;
  ::google::protobuf::uint32 task_id_;
  ::google::protobuf::uint32 cpu_id_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fobject_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Component : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Component) */ {
 public:
  Component();
  virtual ~Component();

  Component(const Component& from);

  inline Component& operator=(const Component& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Component(Component&& from) noexcept
    : Component() {
    *this = ::std::move(from);
  }

  inline Component& operator=(Component&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Component& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Component* internal_default_instance() {
    return reinterpret_cast<const Component*>(
               &_Component_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Component* other);
  friend void swap(Component& a, Component& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Component* New() const final {
    return CreateMaybeMessage<Component>(NULL);
  }

  Component* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Component>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Component& from);
  void MergeFrom(const Component& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Component* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .machinetalk.Pin pin = 16;
  int pin_size() const;
  void clear_pin();
  static const int kPinFieldNumber = 16;
  ::machinetalk::Pin* mutable_pin(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Pin >*
      mutable_pin();
  const ::machinetalk::Pin& pin(int index) const;
  ::machinetalk::Pin* add_pin();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Pin >&
      pin() const;

  // repeated .machinetalk.Param param = 17;
  int param_size() const;
  void clear_param();
  static const int kParamFieldNumber = 17;
  ::machinetalk::Param* mutable_param(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Param >*
      mutable_param();
  const ::machinetalk::Param& param(int index) const;
  ::machinetalk::Param* add_param();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Param >&
      param() const;

  // repeated .machinetalk.Function funct = 19;
  int funct_size() const;
  void clear_funct();
  static const int kFunctFieldNumber = 19;
  ::machinetalk::Function* mutable_funct(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Function >*
      mutable_funct();
  const ::machinetalk::Function& funct(int index) const;
  ::machinetalk::Function* add_funct();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Function >&
      funct() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string args = 11;
  bool has_args() const;
  void clear_args();
  static const int kArgsFieldNumber = 11;
  const ::std::string& args() const;
  void set_args(const ::std::string& value);
  #if LANG_CXX11
  void set_args(::std::string&& value);
  #endif
  void set_args(const char* value);
  void set_args(const char* value, size_t size);
  ::std::string* mutable_args();
  ::std::string* release_args();
  void set_allocated_args(::std::string* args);

  // optional fixed32 ninst = 2;
  bool has_ninst() const;
  void clear_ninst();
  static const int kNinstFieldNumber = 2;
  ::google::protobuf::uint32 ninst() const;
  void set_ninst(::google::protobuf::uint32 value);

  // optional sfixed32 comp_id = 4;
  bool has_comp_id() const;
  void clear_comp_id();
  static const int kCompIdFieldNumber = 4;
  ::google::protobuf::int32 comp_id() const;
  void set_comp_id(::google::protobuf::int32 value);

  // optional fixed32 type = 5;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional fixed32 state = 6;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 6;
  ::google::protobuf::uint32 state() const;
  void set_state(::google::protobuf::uint32 value);

  // optional fixed32 last_update = 7;
  bool has_last_update() const;
  void clear_last_update();
  static const int kLastUpdateFieldNumber = 7;
  ::google::protobuf::uint32 last_update() const;
  void set_last_update(::google::protobuf::uint32 value);

  // optional fixed32 last_bound = 8;
  bool has_last_bound() const;
  void clear_last_bound();
  static const int kLastBoundFieldNumber = 8;
  ::google::protobuf::uint32 last_bound() const;
  void set_last_bound(::google::protobuf::uint32 value);

  // optional fixed32 last_unbound = 9;
  bool has_last_unbound() const;
  void clear_last_unbound();
  static const int kLastUnboundFieldNumber = 9;
  ::google::protobuf::uint32 last_unbound() const;
  void set_last_unbound(::google::protobuf::uint32 value);

  // optional fixed32 pid = 10;
  bool has_pid() const;
  void clear_pid();
  static const int kPidFieldNumber = 10;
  ::google::protobuf::uint32 pid() const;
  void set_pid(::google::protobuf::uint32 value);

  // optional sfixed32 timer = 12;
  bool has_timer() const;
  void clear_timer();
  static const int kTimerFieldNumber = 12;
  ::google::protobuf::int32 timer() const;
  void set_timer(::google::protobuf::int32 value);

  // optional sfixed32 userarg1 = 14;
  bool has_userarg1() const;
  void clear_userarg1();
  static const int kUserarg1FieldNumber = 14;
  ::google::protobuf::int32 userarg1() const;
  void set_userarg1(::google::protobuf::int32 value);

  // optional sfixed32 userarg2 = 15;
  bool has_userarg2() const;
  void clear_userarg2();
  static const int kUserarg2FieldNumber = 15;
  ::google::protobuf::int32 userarg2() const;
  void set_userarg2(::google::protobuf::int32 value);

  // optional bool no_create = 18;
  bool has_no_create() const;
  void clear_no_create();
  static const int kNoCreateFieldNumber = 18;
  bool no_create() const;
  void set_no_create(bool value);

  // @@protoc_insertion_point(class_scope:machinetalk.Component)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_ninst();
  void clear_has_ninst();
  void set_has_comp_id();
  void clear_has_comp_id();
  void set_has_type();
  void clear_has_type();
  void set_has_state();
  void clear_has_state();
  void set_has_last_update();
  void clear_has_last_update();
  void set_has_last_bound();
  void clear_has_last_bound();
  void set_has_last_unbound();
  void clear_has_last_unbound();
  void set_has_pid();
  void clear_has_pid();
  void set_has_args();
  void clear_has_args();
  void set_has_timer();
  void clear_has_timer();
  void set_has_userarg1();
  void clear_has_userarg1();
  void set_has_userarg2();
  void clear_has_userarg2();
  void set_has_no_create();
  void clear_has_no_create();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Pin > pin_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Param > param_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Function > funct_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr args_;
  ::google::protobuf::uint32 ninst_;
  ::google::protobuf::int32 comp_id_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 last_update_;
  ::google::protobuf::uint32 last_bound_;
  ::google::protobuf::uint32 last_unbound_;
  ::google::protobuf::uint32 pid_;
  ::google::protobuf::int32 timer_;
  ::google::protobuf::int32 userarg1_;
  ::google::protobuf::int32 userarg2_;
  bool no_create_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fobject_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ring : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Ring) */ {
 public:
  Ring();
  virtual ~Ring();

  Ring(const Ring& from);

  inline Ring& operator=(const Ring& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ring(Ring&& from) noexcept
    : Ring() {
    *this = ::std::move(from);
  }

  inline Ring& operator=(Ring&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ring& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ring* internal_default_instance() {
    return reinterpret_cast<const Ring*>(
               &_Ring_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Ring* other);
  friend void swap(Ring& a, Ring& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ring* New() const final {
    return CreateMaybeMessage<Ring>(NULL);
  }

  Ring* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Ring>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Ring& from);
  void MergeFrom(const Ring& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ring* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional fixed32 handle = 2;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 2;
  ::google::protobuf::uint32 handle() const;
  void set_handle(::google::protobuf::uint32 value);

  // optional sfixed32 owner = 3;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 3;
  ::google::protobuf::int32 owner() const;
  void set_owner(::google::protobuf::int32 value);

  // optional bool stream = 4;
  bool has_stream() const;
  void clear_stream();
  static const int kStreamFieldNumber = 4;
  bool stream() const;
  void set_stream(bool value);

  // optional bool wmutex = 5;
  bool has_wmutex() const;
  void clear_wmutex();
  static const int kWmutexFieldNumber = 5;
  bool wmutex() const;
  void set_wmutex(bool value);

  // optional bool rmutex = 6;
  bool has_rmutex() const;
  void clear_rmutex();
  static const int kRmutexFieldNumber = 6;
  bool rmutex() const;
  void set_rmutex(bool value);

  // optional bool rtapi_shm = 7;
  bool has_rtapi_shm() const;
  void clear_rtapi_shm();
  static const int kRtapiShmFieldNumber = 7;
  bool rtapi_shm() const;
  void set_rtapi_shm(bool value);

  // optional sfixed32 reader = 8;
  bool has_reader() const;
  void clear_reader();
  static const int kReaderFieldNumber = 8;
  ::google::protobuf::int32 reader() const;
  void set_reader(::google::protobuf::int32 value);

  // optional sfixed32 writer = 9;
  bool has_writer() const;
  void clear_writer();
  static const int kWriterFieldNumber = 9;
  ::google::protobuf::int32 writer() const;
  void set_writer(::google::protobuf::int32 value);

  // optional sfixed32 total_size = 10;
  bool has_total_size() const;
  void clear_total_size();
  static const int kTotalSizeFieldNumber = 10;
  ::google::protobuf::int32 total_size() const;
  void set_total_size(::google::protobuf::int32 value);

  // optional sfixed32 scratchpad = 11;
  bool has_scratchpad() const;
  void clear_scratchpad();
  static const int kScratchpadFieldNumber = 11;
  ::google::protobuf::int32 scratchpad() const;
  void set_scratchpad(::google::protobuf::int32 value);

  // optional sfixed32 ring_shmkey = 12;
  bool has_ring_shmkey() const;
  void clear_ring_shmkey();
  static const int kRingShmkeyFieldNumber = 12;
  ::google::protobuf::int32 ring_shmkey() const;
  void set_ring_shmkey(::google::protobuf::int32 value);

  // optional fixed32 encodings = 13;
  bool has_encodings() const;
  void clear_encodings();
  static const int kEncodingsFieldNumber = 13;
  ::google::protobuf::uint32 encodings() const;
  void set_encodings(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:machinetalk.Ring)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_handle();
  void clear_has_handle();
  void set_has_owner();
  void clear_has_owner();
  void set_has_stream();
  void clear_has_stream();
  void set_has_wmutex();
  void clear_has_wmutex();
  void set_has_rmutex();
  void clear_has_rmutex();
  void set_has_rtapi_shm();
  void clear_has_rtapi_shm();
  void set_has_reader();
  void clear_has_reader();
  void set_has_writer();
  void clear_has_writer();
  void set_has_total_size();
  void clear_has_total_size();
  void set_has_scratchpad();
  void clear_has_scratchpad();
  void set_has_ring_shmkey();
  void clear_has_ring_shmkey();
  void set_has_encodings();
  void clear_has_encodings();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 handle_;
  ::google::protobuf::int32 owner_;
  bool stream_;
  bool wmutex_;
  bool rmutex_;
  bool rtapi_shm_;
  ::google::protobuf::int32 reader_;
  ::google::protobuf::int32 writer_;
  ::google::protobuf::int32 total_size_;
  ::google::protobuf::int32 scratchpad_;
  ::google::protobuf::int32 ring_shmkey_;
  ::google::protobuf::uint32 encodings_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fobject_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Member : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Member) */ {
 public:
  Member();
  virtual ~Member();

  Member(const Member& from);

  inline Member& operator=(const Member& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Member(Member&& from) noexcept
    : Member() {
    *this = ::std::move(from);
  }

  inline Member& operator=(Member&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Member& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Member* internal_default_instance() {
    return reinterpret_cast<const Member*>(
               &_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Member* other);
  friend void swap(Member& a, Member& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Member* New() const final {
    return CreateMaybeMessage<Member>(NULL);
  }

  Member* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Member>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Member& from);
  void MergeFrom(const Member& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Member* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string groupname = 5;
  bool has_groupname() const;
  void clear_groupname();
  static const int kGroupnameFieldNumber = 5;
  const ::std::string& groupname() const;
  void set_groupname(const ::std::string& value);
  #if LANG_CXX11
  void set_groupname(::std::string&& value);
  #endif
  void set_groupname(const char* value);
  void set_groupname(const char* value, size_t size);
  ::std::string* mutable_groupname();
  ::std::string* release_groupname();
  void set_allocated_groupname(::std::string* groupname);

  // optional .machinetalk.Signal signal = 4;
  bool has_signal() const;
  void clear_signal();
  static const int kSignalFieldNumber = 4;
  private:
  const ::machinetalk::Signal& _internal_signal() const;
  public:
  const ::machinetalk::Signal& signal() const;
  ::machinetalk::Signal* release_signal();
  ::machinetalk::Signal* mutable_signal();
  void set_allocated_signal(::machinetalk::Signal* signal);

  // optional .machinetalk.Pin pin = 7;
  bool has_pin() const;
  void clear_pin();
  static const int kPinFieldNumber = 7;
  private:
  const ::machinetalk::Pin& _internal_pin() const;
  public:
  const ::machinetalk::Pin& pin() const;
  ::machinetalk::Pin* release_pin();
  ::machinetalk::Pin* mutable_pin();
  void set_allocated_pin(::machinetalk::Pin* pin);

  // optional .machinetalk.Param param = 8;
  bool has_param() const;
  void clear_param();
  static const int kParamFieldNumber = 8;
  private:
  const ::machinetalk::Param& _internal_param() const;
  public:
  const ::machinetalk::Param& param() const;
  ::machinetalk::Param* release_param();
  ::machinetalk::Param* mutable_param();
  void set_allocated_param(::machinetalk::Param* param);

  // optional .machinetalk.ObjectType mtype = 1;
  bool has_mtype() const;
  void clear_mtype();
  static const int kMtypeFieldNumber = 1;
  ::machinetalk::ObjectType mtype() const;
  void set_mtype(::machinetalk::ObjectType value);

  // optional sfixed32 userarg1 = 2;
  bool has_userarg1() const;
  void clear_userarg1();
  static const int kUserarg1FieldNumber = 2;
  ::google::protobuf::int32 userarg1() const;
  void set_userarg1(::google::protobuf::int32 value);

  // optional double epsilon = 3;
  bool has_epsilon() const;
  void clear_epsilon();
  static const int kEpsilonFieldNumber = 3;
  double epsilon() const;
  void set_epsilon(double value);

  // optional fixed32 handle = 6;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 6;
  ::google::protobuf::uint32 handle() const;
  void set_handle(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:machinetalk.Member)
 private:
  void set_has_mtype();
  void clear_has_mtype();
  void set_has_userarg1();
  void clear_has_userarg1();
  void set_has_epsilon();
  void clear_has_epsilon();
  void set_has_signal();
  void clear_has_signal();
  void set_has_groupname();
  void clear_has_groupname();
  void set_has_handle();
  void clear_has_handle();
  void set_has_pin();
  void clear_has_pin();
  void set_has_param();
  void clear_has_param();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr groupname_;
  ::machinetalk::Signal* signal_;
  ::machinetalk::Pin* pin_;
  ::machinetalk::Param* param_;
  int mtype_;
  ::google::protobuf::int32 userarg1_;
  double epsilon_;
  ::google::protobuf::uint32 handle_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fobject_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Group : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Group) */ {
 public:
  Group();
  virtual ~Group();

  Group(const Group& from);

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Group(Group&& from) noexcept
    : Group() {
    *this = ::std::move(from);
  }

  inline Group& operator=(Group&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Group& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Group* internal_default_instance() {
    return reinterpret_cast<const Group*>(
               &_Group_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Group* other);
  friend void swap(Group& a, Group& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Group* New() const final {
    return CreateMaybeMessage<Group>(NULL);
  }

  Group* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Group>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Group& from);
  void MergeFrom(const Group& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Group* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .machinetalk.Member member = 7;
  int member_size() const;
  void clear_member();
  static const int kMemberFieldNumber = 7;
  ::machinetalk::Member* mutable_member(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Member >*
      mutable_member();
  const ::machinetalk::Member& member(int index) const;
  ::machinetalk::Member* add_member();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Member >&
      member() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional fixed32 handle = 2;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 2;
  ::google::protobuf::uint32 handle() const;
  void set_handle(::google::protobuf::uint32 value);

  // optional sfixed32 userarg1 = 4;
  bool has_userarg1() const;
  void clear_userarg1();
  static const int kUserarg1FieldNumber = 4;
  ::google::protobuf::int32 userarg1() const;
  void set_userarg1(::google::protobuf::int32 value);

  // optional sfixed32 userarg2 = 5;
  bool has_userarg2() const;
  void clear_userarg2();
  static const int kUserarg2FieldNumber = 5;
  ::google::protobuf::int32 userarg2() const;
  void set_userarg2(::google::protobuf::int32 value);

  // optional sfixed32 refcount = 6;
  bool has_refcount() const;
  void clear_refcount();
  static const int kRefcountFieldNumber = 6;
  ::google::protobuf::int32 refcount() const;
  void set_refcount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:machinetalk.Group)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_handle();
  void clear_has_handle();
  void set_has_userarg1();
  void clear_has_userarg1();
  void set_has_userarg2();
  void clear_has_userarg2();
  void set_has_refcount();
  void clear_has_refcount();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Member > member_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 handle_;
  ::google::protobuf::int32 userarg1_;
  ::google::protobuf::int32 userarg2_;
  ::google::protobuf::int32 refcount_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fobject_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProtocolParameters : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.ProtocolParameters) */ {
 public:
  ProtocolParameters();
  virtual ~ProtocolParameters();

  ProtocolParameters(const ProtocolParameters& from);

  inline ProtocolParameters& operator=(const ProtocolParameters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProtocolParameters(ProtocolParameters&& from) noexcept
    : ProtocolParameters() {
    *this = ::std::move(from);
  }

  inline ProtocolParameters& operator=(ProtocolParameters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtocolParameters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProtocolParameters* internal_default_instance() {
    return reinterpret_cast<const ProtocolParameters*>(
               &_ProtocolParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ProtocolParameters* other);
  friend void swap(ProtocolParameters& a, ProtocolParameters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProtocolParameters* New() const final {
    return CreateMaybeMessage<ProtocolParameters>(NULL);
  }

  ProtocolParameters* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProtocolParameters>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProtocolParameters& from);
  void MergeFrom(const ProtocolParameters& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtocolParameters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed32 keepalive_timer = 1;
  bool has_keepalive_timer() const;
  void clear_keepalive_timer();
  static const int kKeepaliveTimerFieldNumber = 1;
  ::google::protobuf::int32 keepalive_timer() const;
  void set_keepalive_timer(::google::protobuf::int32 value);

  // optional sfixed32 group_timer = 2;
  bool has_group_timer() const;
  void clear_group_timer();
  static const int kGroupTimerFieldNumber = 2;
  ::google::protobuf::int32 group_timer() const;
  void set_group_timer(::google::protobuf::int32 value);

  // optional sfixed32 rcomp_timer = 3;
  bool has_rcomp_timer() const;
  void clear_rcomp_timer();
  static const int kRcompTimerFieldNumber = 3;
  ::google::protobuf::int32 rcomp_timer() const;
  void set_rcomp_timer(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:machinetalk.ProtocolParameters)
 private:
  void set_has_keepalive_timer();
  void clear_has_keepalive_timer();
  void set_has_group_timer();
  void clear_has_group_timer();
  void set_has_rcomp_timer();
  void clear_has_rcomp_timer();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 keepalive_timer_;
  ::google::protobuf::int32 group_timer_;
  ::google::protobuf::int32 rcomp_timer_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fobject_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vtable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Vtable) */ {
 public:
  Vtable();
  virtual ~Vtable();

  Vtable(const Vtable& from);

  inline Vtable& operator=(const Vtable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vtable(Vtable&& from) noexcept
    : Vtable() {
    *this = ::std::move(from);
  }

  inline Vtable& operator=(Vtable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vtable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vtable* internal_default_instance() {
    return reinterpret_cast<const Vtable*>(
               &_Vtable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Vtable* other);
  friend void swap(Vtable& a, Vtable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vtable* New() const final {
    return CreateMaybeMessage<Vtable>(NULL);
  }

  Vtable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vtable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vtable& from);
  void MergeFrom(const Vtable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vtable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional fixed32 handle = 2;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 2;
  ::google::protobuf::uint32 handle() const;
  void set_handle(::google::protobuf::uint32 value);

  // optional sfixed32 owner_id = 3;
  bool has_owner_id() const;
  void clear_owner_id();
  static const int kOwnerIdFieldNumber = 3;
  ::google::protobuf::int32 owner_id() const;
  void set_owner_id(::google::protobuf::int32 value);

  // optional fixed32 context = 5;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 5;
  ::google::protobuf::uint32 context() const;
  void set_context(::google::protobuf::uint32 value);

  // optional sfixed32 refcount = 6;
  bool has_refcount() const;
  void clear_refcount();
  static const int kRefcountFieldNumber = 6;
  ::google::protobuf::int32 refcount() const;
  void set_refcount(::google::protobuf::int32 value);

  // optional fixed64 vtable = 8;
  bool has_vtable() const;
  void clear_vtable();
  static const int kVtableFieldNumber = 8;
  ::google::protobuf::uint64 vtable() const;
  void set_vtable(::google::protobuf::uint64 value);

  // optional sfixed32 version = 7;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 7;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:machinetalk.Vtable)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_handle();
  void clear_has_handle();
  void set_has_owner_id();
  void clear_has_owner_id();
  void set_has_context();
  void clear_has_context();
  void set_has_refcount();
  void clear_has_refcount();
  void set_has_version();
  void clear_has_version();
  void set_has_vtable();
  void clear_has_vtable();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 handle_;
  ::google::protobuf::int32 owner_id_;
  ::google::protobuf::uint32 context_;
  ::google::protobuf::int32 refcount_;
  ::google::protobuf::uint64 vtable_;
  ::google::protobuf::int32 version_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fobject_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Inst : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:machinetalk.Inst) */ {
 public:
  Inst();
  virtual ~Inst();

  Inst(const Inst& from);

  inline Inst& operator=(const Inst& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Inst(Inst&& from) noexcept
    : Inst() {
    *this = ::std::move(from);
  }

  inline Inst& operator=(Inst&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Inst& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Inst* internal_default_instance() {
    return reinterpret_cast<const Inst*>(
               &_Inst_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Inst* other);
  friend void swap(Inst& a, Inst& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Inst* New() const final {
    return CreateMaybeMessage<Inst>(NULL);
  }

  Inst* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Inst>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Inst& from);
  void MergeFrom(const Inst& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Inst* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .machinetalk.Pin pin = 16;
  int pin_size() const;
  void clear_pin();
  static const int kPinFieldNumber = 16;
  ::machinetalk::Pin* mutable_pin(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Pin >*
      mutable_pin();
  const ::machinetalk::Pin& pin(int index) const;
  ::machinetalk::Pin* add_pin();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Pin >&
      pin() const;

  // repeated .machinetalk.Param param = 17;
  int param_size() const;
  void clear_param();
  static const int kParamFieldNumber = 17;
  ::machinetalk::Param* mutable_param(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Param >*
      mutable_param();
  const ::machinetalk::Param& param(int index) const;
  ::machinetalk::Param* add_param();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Param >&
      param() const;

  // repeated .machinetalk.Function funct = 19;
  int funct_size() const;
  void clear_funct();
  static const int kFunctFieldNumber = 19;
  ::machinetalk::Function* mutable_funct(int index);
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Function >*
      mutable_funct();
  const ::machinetalk::Function& funct(int index) const;
  ::machinetalk::Function* add_funct();
  const ::google::protobuf::RepeatedPtrField< ::machinetalk::Function >&
      funct() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional sfixed32 comp_id = 2;
  bool has_comp_id() const;
  void clear_comp_id();
  static const int kCompIdFieldNumber = 2;
  ::google::protobuf::int32 comp_id() const;
  void set_comp_id(::google::protobuf::int32 value);

  // optional fixed32 inst_id = 3;
  bool has_inst_id() const;
  void clear_inst_id();
  static const int kInstIdFieldNumber = 3;
  ::google::protobuf::uint32 inst_id() const;
  void set_inst_id(::google::protobuf::uint32 value);

  // optional fixed64 vtable = 5;
  bool has_vtable() const;
  void clear_vtable();
  static const int kVtableFieldNumber = 5;
  ::google::protobuf::uint64 vtable() const;
  void set_vtable(::google::protobuf::uint64 value);

  // optional fixed32 inst_size = 4;
  bool has_inst_size() const;
  void clear_inst_size();
  static const int kInstSizeFieldNumber = 4;
  ::google::protobuf::uint32 inst_size() const;
  void set_inst_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:machinetalk.Inst)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_comp_id();
  void clear_has_comp_id();
  void set_has_inst_id();
  void clear_has_inst_id();
  void set_has_inst_size();
  void clear_has_inst_size();
  void set_has_vtable();
  void clear_has_vtable();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Pin > pin_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Param > param_;
  ::google::protobuf::RepeatedPtrField< ::machinetalk::Function > funct_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 comp_id_;
  ::google::protobuf::uint32 inst_id_;
  ::google::protobuf::uint64 vtable_;
  ::google::protobuf::uint32 inst_size_;
  friend struct ::protobuf_machinetalk_2fprotobuf_2fobject_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Instance

// optional string name = 1;
inline bool Instance::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Instance::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Instance::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Instance::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Instance::name() const {
  // @@protoc_insertion_point(field_get:machinetalk.Instance.name)
  return name_.GetNoArena();
}
inline void Instance::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Instance.name)
}
#if LANG_CXX11
inline void Instance::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Instance.name)
}
#endif
inline void Instance::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Instance.name)
}
inline void Instance::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Instance.name)
}
inline ::std::string* Instance::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:machinetalk.Instance.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Instance::release_name() {
  // @@protoc_insertion_point(field_release:machinetalk.Instance.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Instance::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Instance.name)
}

// optional sfixed32 id = 2;
inline bool Instance::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Instance::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Instance::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Instance::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Instance::id() const {
  // @@protoc_insertion_point(field_get:machinetalk.Instance.id)
  return id_;
}
inline void Instance::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Instance.id)
}

// -------------------------------------------------------------------

// ServiceAnnouncement

// required .machinetalk.ServiceType stype = 1;
inline bool ServiceAnnouncement::has_stype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServiceAnnouncement::set_has_stype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServiceAnnouncement::clear_has_stype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServiceAnnouncement::clear_stype() {
  stype_ = 1;
  clear_has_stype();
}
inline ::machinetalk::ServiceType ServiceAnnouncement::stype() const {
  // @@protoc_insertion_point(field_get:machinetalk.ServiceAnnouncement.stype)
  return static_cast< ::machinetalk::ServiceType >(stype_);
}
inline void ServiceAnnouncement::set_stype(::machinetalk::ServiceType value) {
  assert(::machinetalk::ServiceType_IsValid(value));
  set_has_stype();
  stype_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.ServiceAnnouncement.stype)
}

// required fixed32 version = 2 [default = 0];
inline bool ServiceAnnouncement::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceAnnouncement::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceAnnouncement::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceAnnouncement::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 ServiceAnnouncement::version() const {
  // @@protoc_insertion_point(field_get:machinetalk.ServiceAnnouncement.version)
  return version_;
}
inline void ServiceAnnouncement::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.ServiceAnnouncement.version)
}

// required fixed32 instance = 3 [default = 0];
inline bool ServiceAnnouncement::has_instance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceAnnouncement::set_has_instance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServiceAnnouncement::clear_has_instance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceAnnouncement::clear_instance() {
  instance_ = 0u;
  clear_has_instance();
}
inline ::google::protobuf::uint32 ServiceAnnouncement::instance() const {
  // @@protoc_insertion_point(field_get:machinetalk.ServiceAnnouncement.instance)
  return instance_;
}
inline void ServiceAnnouncement::set_instance(::google::protobuf::uint32 value) {
  set_has_instance();
  instance_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.ServiceAnnouncement.instance)
}

// required .machinetalk.ServiceAPI api = 8;
inline bool ServiceAnnouncement::has_api() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServiceAnnouncement::set_has_api() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServiceAnnouncement::clear_has_api() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServiceAnnouncement::clear_api() {
  api_ = 1;
  clear_has_api();
}
inline ::machinetalk::ServiceAPI ServiceAnnouncement::api() const {
  // @@protoc_insertion_point(field_get:machinetalk.ServiceAnnouncement.api)
  return static_cast< ::machinetalk::ServiceAPI >(api_);
}
inline void ServiceAnnouncement::set_api(::machinetalk::ServiceAPI value) {
  assert(::machinetalk::ServiceAPI_IsValid(value));
  set_has_api();
  api_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.ServiceAnnouncement.api)
}

// required string uri = 6;
inline bool ServiceAnnouncement::has_uri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceAnnouncement::set_has_uri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceAnnouncement::clear_has_uri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceAnnouncement::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uri();
}
inline const ::std::string& ServiceAnnouncement::uri() const {
  // @@protoc_insertion_point(field_get:machinetalk.ServiceAnnouncement.uri)
  return uri_.GetNoArena();
}
inline void ServiceAnnouncement::set_uri(const ::std::string& value) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.ServiceAnnouncement.uri)
}
#if LANG_CXX11
inline void ServiceAnnouncement::set_uri(::std::string&& value) {
  set_has_uri();
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.ServiceAnnouncement.uri)
}
#endif
inline void ServiceAnnouncement::set_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.ServiceAnnouncement.uri)
}
inline void ServiceAnnouncement::set_uri(const char* value, size_t size) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.ServiceAnnouncement.uri)
}
inline ::std::string* ServiceAnnouncement::mutable_uri() {
  set_has_uri();
  // @@protoc_insertion_point(field_mutable:machinetalk.ServiceAnnouncement.uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServiceAnnouncement::release_uri() {
  // @@protoc_insertion_point(field_release:machinetalk.ServiceAnnouncement.uri)
  if (!has_uri()) {
    return NULL;
  }
  clear_has_uri();
  return uri_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceAnnouncement::set_allocated_uri(::std::string* uri) {
  if (uri != NULL) {
    set_has_uri();
  } else {
    clear_has_uri();
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.ServiceAnnouncement.uri)
}

// optional string description = 7;
inline bool ServiceAnnouncement::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceAnnouncement::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceAnnouncement::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceAnnouncement::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& ServiceAnnouncement::description() const {
  // @@protoc_insertion_point(field_get:machinetalk.ServiceAnnouncement.description)
  return description_.GetNoArena();
}
inline void ServiceAnnouncement::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.ServiceAnnouncement.description)
}
#if LANG_CXX11
inline void ServiceAnnouncement::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.ServiceAnnouncement.description)
}
#endif
inline void ServiceAnnouncement::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.ServiceAnnouncement.description)
}
inline void ServiceAnnouncement::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.ServiceAnnouncement.description)
}
inline ::std::string* ServiceAnnouncement::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:machinetalk.ServiceAnnouncement.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServiceAnnouncement::release_description() {
  // @@protoc_insertion_point(field_release:machinetalk.ServiceAnnouncement.description)
  if (!has_description()) {
    return NULL;
  }
  clear_has_description();
  return description_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceAnnouncement::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.ServiceAnnouncement.description)
}

// -------------------------------------------------------------------

// Originator

// optional .machinetalk.OriginType origin = 1;
inline bool Originator::has_origin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Originator::set_has_origin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Originator::clear_has_origin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Originator::clear_origin() {
  origin_ = 10;
  clear_has_origin();
}
inline ::machinetalk::OriginType Originator::origin() const {
  // @@protoc_insertion_point(field_get:machinetalk.Originator.origin)
  return static_cast< ::machinetalk::OriginType >(origin_);
}
inline void Originator::set_origin(::machinetalk::OriginType value) {
  assert(::machinetalk::OriginType_IsValid(value));
  set_has_origin();
  origin_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Originator.origin)
}

// optional .machinetalk.OriginDetail detail = 2;
inline bool Originator::has_detail() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Originator::set_has_detail() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Originator::clear_has_detail() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Originator::clear_detail() {
  detail_ = 10;
  clear_has_detail();
}
inline ::machinetalk::OriginDetail Originator::detail() const {
  // @@protoc_insertion_point(field_get:machinetalk.Originator.detail)
  return static_cast< ::machinetalk::OriginDetail >(detail_);
}
inline void Originator::set_detail(::machinetalk::OriginDetail value) {
  assert(::machinetalk::OriginDetail_IsValid(value));
  set_has_detail();
  detail_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Originator.detail)
}

// optional string name = 3;
inline bool Originator::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Originator::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Originator::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Originator::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Originator::name() const {
  // @@protoc_insertion_point(field_get:machinetalk.Originator.name)
  return name_.GetNoArena();
}
inline void Originator::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Originator.name)
}
#if LANG_CXX11
inline void Originator::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Originator.name)
}
#endif
inline void Originator::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Originator.name)
}
inline void Originator::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Originator.name)
}
inline ::std::string* Originator::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:machinetalk.Originator.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Originator::release_name() {
  // @@protoc_insertion_point(field_release:machinetalk.Originator.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Originator::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Originator.name)
}

// optional sfixed32 id = 4;
inline bool Originator::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Originator::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Originator::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Originator::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Originator::id() const {
  // @@protoc_insertion_point(field_get:machinetalk.Originator.id)
  return id_;
}
inline void Originator::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Originator.id)
}

// optional .machinetalk.Instance instance = 5;
inline bool Originator::has_instance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Originator::set_has_instance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Originator::clear_has_instance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Originator::clear_instance() {
  if (instance_ != NULL) instance_->Clear();
  clear_has_instance();
}
inline const ::machinetalk::Instance& Originator::_internal_instance() const {
  return *instance_;
}
inline const ::machinetalk::Instance& Originator::instance() const {
  const ::machinetalk::Instance* p = instance_;
  // @@protoc_insertion_point(field_get:machinetalk.Originator.instance)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Instance*>(
      &::machinetalk::_Instance_default_instance_);
}
inline ::machinetalk::Instance* Originator::release_instance() {
  // @@protoc_insertion_point(field_release:machinetalk.Originator.instance)
  clear_has_instance();
  ::machinetalk::Instance* temp = instance_;
  instance_ = NULL;
  return temp;
}
inline ::machinetalk::Instance* Originator::mutable_instance() {
  set_has_instance();
  if (instance_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Instance>(GetArenaNoVirtual());
    instance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Originator.instance)
  return instance_;
}
inline void Originator::set_allocated_instance(::machinetalk::Instance* instance) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete instance_;
  }
  if (instance) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      instance = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, instance, submessage_arena);
    }
    set_has_instance();
  } else {
    clear_has_instance();
  }
  instance_ = instance;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Originator.instance)
}

// -------------------------------------------------------------------

// AnError

// required sfixed32 error_code = 1;
inline bool AnError::has_error_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnError::set_has_error_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnError::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnError::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 AnError::error_code() const {
  // @@protoc_insertion_point(field_get:machinetalk.AnError.error_code)
  return error_code_;
}
inline void AnError::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.AnError.error_code)
}

// optional .machinetalk.Severity severity = 2;
inline bool AnError::has_severity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnError::set_has_severity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnError::clear_has_severity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnError::clear_severity() {
  severity_ = 1;
  clear_has_severity();
}
inline ::machinetalk::Severity AnError::severity() const {
  // @@protoc_insertion_point(field_get:machinetalk.AnError.severity)
  return static_cast< ::machinetalk::Severity >(severity_);
}
inline void AnError::set_severity(::machinetalk::Severity value) {
  assert(::machinetalk::Severity_IsValid(value));
  set_has_severity();
  severity_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.AnError.severity)
}

// optional string error_text = 3;
inline bool AnError::has_error_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnError::set_has_error_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnError::clear_has_error_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnError::clear_error_text() {
  error_text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_text();
}
inline const ::std::string& AnError::error_text() const {
  // @@protoc_insertion_point(field_get:machinetalk.AnError.error_text)
  return error_text_.GetNoArena();
}
inline void AnError::set_error_text(const ::std::string& value) {
  set_has_error_text();
  error_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.AnError.error_text)
}
#if LANG_CXX11
inline void AnError::set_error_text(::std::string&& value) {
  set_has_error_text();
  error_text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.AnError.error_text)
}
#endif
inline void AnError::set_error_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_text();
  error_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.AnError.error_text)
}
inline void AnError::set_error_text(const char* value, size_t size) {
  set_has_error_text();
  error_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.AnError.error_text)
}
inline ::std::string* AnError::mutable_error_text() {
  set_has_error_text();
  // @@protoc_insertion_point(field_mutable:machinetalk.AnError.error_text)
  return error_text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnError::release_error_text() {
  // @@protoc_insertion_point(field_release:machinetalk.AnError.error_text)
  if (!has_error_text()) {
    return NULL;
  }
  clear_has_error_text();
  return error_text_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnError::set_allocated_error_text(::std::string* error_text) {
  if (error_text != NULL) {
    set_has_error_text();
  } else {
    clear_has_error_text();
  }
  error_text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_text);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.AnError.error_text)
}

// optional .machinetalk.Originator origin = 4;
inline bool AnError::has_origin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnError::set_has_origin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnError::clear_has_origin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnError::clear_origin() {
  if (origin_ != NULL) origin_->Clear();
  clear_has_origin();
}
inline const ::machinetalk::Originator& AnError::_internal_origin() const {
  return *origin_;
}
inline const ::machinetalk::Originator& AnError::origin() const {
  const ::machinetalk::Originator* p = origin_;
  // @@protoc_insertion_point(field_get:machinetalk.AnError.origin)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Originator*>(
      &::machinetalk::_Originator_default_instance_);
}
inline ::machinetalk::Originator* AnError::release_origin() {
  // @@protoc_insertion_point(field_release:machinetalk.AnError.origin)
  clear_has_origin();
  ::machinetalk::Originator* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline ::machinetalk::Originator* AnError::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Originator>(GetArenaNoVirtual());
    origin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.AnError.origin)
  return origin_;
}
inline void AnError::set_allocated_origin(::machinetalk::Originator* origin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete origin_;
  }
  if (origin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      origin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    set_has_origin();
  } else {
    clear_has_origin();
  }
  origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.AnError.origin)
}

// -------------------------------------------------------------------

// Pin

// optional .machinetalk.ValueType type = 1;
inline bool Pin::has_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Pin::set_has_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Pin::clear_has_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Pin::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::machinetalk::ValueType Pin::type() const {
  // @@protoc_insertion_point(field_get:machinetalk.Pin.type)
  return static_cast< ::machinetalk::ValueType >(type_);
}
inline void Pin::set_type(::machinetalk::ValueType value) {
  assert(::machinetalk::ValueType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Pin.type)
}

// optional string name = 2;
inline bool Pin::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pin::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pin::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pin::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Pin::name() const {
  // @@protoc_insertion_point(field_get:machinetalk.Pin.name)
  return name_.GetNoArena();
}
inline void Pin::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Pin.name)
}
#if LANG_CXX11
inline void Pin::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Pin.name)
}
#endif
inline void Pin::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Pin.name)
}
inline void Pin::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Pin.name)
}
inline ::std::string* Pin::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:machinetalk.Pin.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Pin::release_name() {
  // @@protoc_insertion_point(field_release:machinetalk.Pin.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Pin::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Pin.name)
}

// optional fixed32 handle = 3;
inline bool Pin::has_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pin::set_has_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pin::clear_has_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pin::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Pin::handle() const {
  // @@protoc_insertion_point(field_get:machinetalk.Pin.handle)
  return handle_;
}
inline void Pin::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Pin.handle)
}

// optional .machinetalk.HalPinDirection dir = 4;
inline bool Pin::has_dir() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Pin::set_has_dir() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Pin::clear_has_dir() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Pin::clear_dir() {
  dir_ = 16;
  clear_has_dir();
}
inline ::machinetalk::HalPinDirection Pin::dir() const {
  // @@protoc_insertion_point(field_get:machinetalk.Pin.dir)
  return static_cast< ::machinetalk::HalPinDirection >(dir_);
}
inline void Pin::set_dir(::machinetalk::HalPinDirection value) {
  assert(::machinetalk::HalPinDirection_IsValid(value));
  set_has_dir();
  dir_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Pin.dir)
}

// optional bool halbit = 5;
inline bool Pin::has_halbit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Pin::set_has_halbit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Pin::clear_has_halbit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Pin::clear_halbit() {
  halbit_ = false;
  clear_has_halbit();
}
inline bool Pin::halbit() const {
  // @@protoc_insertion_point(field_get:machinetalk.Pin.halbit)
  return halbit_;
}
inline void Pin::set_halbit(bool value) {
  set_has_halbit();
  halbit_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Pin.halbit)
}

// optional double halfloat = 6;
inline bool Pin::has_halfloat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Pin::set_has_halfloat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Pin::clear_has_halfloat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Pin::clear_halfloat() {
  halfloat_ = 0;
  clear_has_halfloat();
}
inline double Pin::halfloat() const {
  // @@protoc_insertion_point(field_get:machinetalk.Pin.halfloat)
  return halfloat_;
}
inline void Pin::set_halfloat(double value) {
  set_has_halfloat();
  halfloat_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Pin.halfloat)
}

// optional sfixed32 hals32 = 7;
inline bool Pin::has_hals32() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Pin::set_has_hals32() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Pin::clear_has_hals32() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Pin::clear_hals32() {
  hals32_ = 0;
  clear_has_hals32();
}
inline ::google::protobuf::int32 Pin::hals32() const {
  // @@protoc_insertion_point(field_get:machinetalk.Pin.hals32)
  return hals32_;
}
inline void Pin::set_hals32(::google::protobuf::int32 value) {
  set_has_hals32();
  hals32_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Pin.hals32)
}

// optional fixed32 halu32 = 8;
inline bool Pin::has_halu32() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Pin::set_has_halu32() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Pin::clear_has_halu32() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Pin::clear_halu32() {
  halu32_ = 0u;
  clear_has_halu32();
}
inline ::google::protobuf::uint32 Pin::halu32() const {
  // @@protoc_insertion_point(field_get:machinetalk.Pin.halu32)
  return halu32_;
}
inline void Pin::set_halu32(::google::protobuf::uint32 value) {
  set_has_halu32();
  halu32_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Pin.halu32)
}

// optional sfixed32 owner = 9;
inline bool Pin::has_owner() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Pin::set_has_owner() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Pin::clear_has_owner() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Pin::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::google::protobuf::int32 Pin::owner() const {
  // @@protoc_insertion_point(field_get:machinetalk.Pin.owner)
  return owner_;
}
inline void Pin::set_owner(::google::protobuf::int32 value) {
  set_has_owner();
  owner_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Pin.owner)
}

// optional bool linked = 10;
inline bool Pin::has_linked() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Pin::set_has_linked() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Pin::clear_has_linked() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Pin::clear_linked() {
  linked_ = false;
  clear_has_linked();
}
inline bool Pin::linked() const {
  // @@protoc_insertion_point(field_get:machinetalk.Pin.linked)
  return linked_;
}
inline void Pin::set_linked(bool value) {
  set_has_linked();
  linked_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Pin.linked)
}

// optional string oldname = 11;
inline bool Pin::has_oldname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pin::set_has_oldname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pin::clear_has_oldname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pin::clear_oldname() {
  oldname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_oldname();
}
inline const ::std::string& Pin::oldname() const {
  // @@protoc_insertion_point(field_get:machinetalk.Pin.oldname)
  return oldname_.GetNoArena();
}
inline void Pin::set_oldname(const ::std::string& value) {
  set_has_oldname();
  oldname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Pin.oldname)
}
#if LANG_CXX11
inline void Pin::set_oldname(::std::string&& value) {
  set_has_oldname();
  oldname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Pin.oldname)
}
#endif
inline void Pin::set_oldname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_oldname();
  oldname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Pin.oldname)
}
inline void Pin::set_oldname(const char* value, size_t size) {
  set_has_oldname();
  oldname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Pin.oldname)
}
inline ::std::string* Pin::mutable_oldname() {
  set_has_oldname();
  // @@protoc_insertion_point(field_mutable:machinetalk.Pin.oldname)
  return oldname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Pin::release_oldname() {
  // @@protoc_insertion_point(field_release:machinetalk.Pin.oldname)
  if (!has_oldname()) {
    return NULL;
  }
  clear_has_oldname();
  return oldname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Pin::set_allocated_oldname(::std::string* oldname) {
  if (oldname != NULL) {
    set_has_oldname();
  } else {
    clear_has_oldname();
  }
  oldname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oldname);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Pin.oldname)
}

// optional double epsilon = 12;
inline bool Pin::has_epsilon() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Pin::set_has_epsilon() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Pin::clear_has_epsilon() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Pin::clear_epsilon() {
  epsilon_ = 0;
  clear_has_epsilon();
}
inline double Pin::epsilon() const {
  // @@protoc_insertion_point(field_get:machinetalk.Pin.epsilon)
  return epsilon_;
}
inline void Pin::set_epsilon(double value) {
  set_has_epsilon();
  epsilon_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Pin.epsilon)
}

// optional fixed32 flags = 13;
inline bool Pin::has_flags() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Pin::set_has_flags() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Pin::clear_has_flags() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Pin::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 Pin::flags() const {
  // @@protoc_insertion_point(field_get:machinetalk.Pin.flags)
  return flags_;
}
inline void Pin::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Pin.flags)
}

// -------------------------------------------------------------------

// Signal

// optional .machinetalk.ValueType type = 1;
inline bool Signal::has_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Signal::set_has_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Signal::clear_has_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Signal::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::machinetalk::ValueType Signal::type() const {
  // @@protoc_insertion_point(field_get:machinetalk.Signal.type)
  return static_cast< ::machinetalk::ValueType >(type_);
}
inline void Signal::set_type(::machinetalk::ValueType value) {
  assert(::machinetalk::ValueType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Signal.type)
}

// optional string name = 2;
inline bool Signal::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signal::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Signal::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Signal::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Signal::name() const {
  // @@protoc_insertion_point(field_get:machinetalk.Signal.name)
  return name_.GetNoArena();
}
inline void Signal::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Signal.name)
}
#if LANG_CXX11
inline void Signal::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Signal.name)
}
#endif
inline void Signal::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Signal.name)
}
inline void Signal::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Signal.name)
}
inline ::std::string* Signal::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:machinetalk.Signal.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signal::release_name() {
  // @@protoc_insertion_point(field_release:machinetalk.Signal.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signal::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Signal.name)
}

// optional fixed32 handle = 3;
inline bool Signal::has_handle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Signal::set_has_handle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Signal::clear_has_handle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Signal::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Signal::handle() const {
  // @@protoc_insertion_point(field_get:machinetalk.Signal.handle)
  return handle_;
}
inline void Signal::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Signal.handle)
}

// optional bool halbit = 5;
inline bool Signal::has_halbit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Signal::set_has_halbit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Signal::clear_has_halbit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Signal::clear_halbit() {
  halbit_ = false;
  clear_has_halbit();
}
inline bool Signal::halbit() const {
  // @@protoc_insertion_point(field_get:machinetalk.Signal.halbit)
  return halbit_;
}
inline void Signal::set_halbit(bool value) {
  set_has_halbit();
  halbit_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Signal.halbit)
}

// optional double halfloat = 6;
inline bool Signal::has_halfloat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Signal::set_has_halfloat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Signal::clear_has_halfloat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Signal::clear_halfloat() {
  halfloat_ = 0;
  clear_has_halfloat();
}
inline double Signal::halfloat() const {
  // @@protoc_insertion_point(field_get:machinetalk.Signal.halfloat)
  return halfloat_;
}
inline void Signal::set_halfloat(double value) {
  set_has_halfloat();
  halfloat_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Signal.halfloat)
}

// optional sfixed32 hals32 = 7;
inline bool Signal::has_hals32() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Signal::set_has_hals32() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Signal::clear_has_hals32() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Signal::clear_hals32() {
  hals32_ = 0;
  clear_has_hals32();
}
inline ::google::protobuf::int32 Signal::hals32() const {
  // @@protoc_insertion_point(field_get:machinetalk.Signal.hals32)
  return hals32_;
}
inline void Signal::set_hals32(::google::protobuf::int32 value) {
  set_has_hals32();
  hals32_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Signal.hals32)
}

// optional fixed32 halu32 = 8;
inline bool Signal::has_halu32() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Signal::set_has_halu32() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Signal::clear_has_halu32() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Signal::clear_halu32() {
  halu32_ = 0u;
  clear_has_halu32();
}
inline ::google::protobuf::uint32 Signal::halu32() const {
  // @@protoc_insertion_point(field_get:machinetalk.Signal.halu32)
  return halu32_;
}
inline void Signal::set_halu32(::google::protobuf::uint32 value) {
  set_has_halu32();
  halu32_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Signal.halu32)
}

// optional string strval = 9;
inline bool Signal::has_strval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signal::set_has_strval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Signal::clear_has_strval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Signal::clear_strval() {
  strval_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_strval();
}
inline const ::std::string& Signal::strval() const {
  // @@protoc_insertion_point(field_get:machinetalk.Signal.strval)
  return strval_.GetNoArena();
}
inline void Signal::set_strval(const ::std::string& value) {
  set_has_strval();
  strval_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Signal.strval)
}
#if LANG_CXX11
inline void Signal::set_strval(::std::string&& value) {
  set_has_strval();
  strval_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Signal.strval)
}
#endif
inline void Signal::set_strval(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_strval();
  strval_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Signal.strval)
}
inline void Signal::set_strval(const char* value, size_t size) {
  set_has_strval();
  strval_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Signal.strval)
}
inline ::std::string* Signal::mutable_strval() {
  set_has_strval();
  // @@protoc_insertion_point(field_mutable:machinetalk.Signal.strval)
  return strval_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signal::release_strval() {
  // @@protoc_insertion_point(field_release:machinetalk.Signal.strval)
  if (!has_strval()) {
    return NULL;
  }
  clear_has_strval();
  return strval_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signal::set_allocated_strval(::std::string* strval) {
  if (strval != NULL) {
    set_has_strval();
  } else {
    clear_has_strval();
  }
  strval_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), strval);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Signal.strval)
}

// optional bytes blob = 10;
inline bool Signal::has_blob() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Signal::set_has_blob() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Signal::clear_has_blob() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Signal::clear_blob() {
  blob_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_blob();
}
inline const ::std::string& Signal::blob() const {
  // @@protoc_insertion_point(field_get:machinetalk.Signal.blob)
  return blob_.GetNoArena();
}
inline void Signal::set_blob(const ::std::string& value) {
  set_has_blob();
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Signal.blob)
}
#if LANG_CXX11
inline void Signal::set_blob(::std::string&& value) {
  set_has_blob();
  blob_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Signal.blob)
}
#endif
inline void Signal::set_blob(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_blob();
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Signal.blob)
}
inline void Signal::set_blob(const void* value, size_t size) {
  set_has_blob();
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Signal.blob)
}
inline ::std::string* Signal::mutable_blob() {
  set_has_blob();
  // @@protoc_insertion_point(field_mutable:machinetalk.Signal.blob)
  return blob_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signal::release_blob() {
  // @@protoc_insertion_point(field_release:machinetalk.Signal.blob)
  if (!has_blob()) {
    return NULL;
  }
  clear_has_blob();
  return blob_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signal::set_allocated_blob(::std::string* blob) {
  if (blob != NULL) {
    set_has_blob();
  } else {
    clear_has_blob();
  }
  blob_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blob);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Signal.blob)
}

// optional fixed32 readers = 11;
inline bool Signal::has_readers() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Signal::set_has_readers() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Signal::clear_has_readers() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Signal::clear_readers() {
  readers_ = 0u;
  clear_has_readers();
}
inline ::google::protobuf::uint32 Signal::readers() const {
  // @@protoc_insertion_point(field_get:machinetalk.Signal.readers)
  return readers_;
}
inline void Signal::set_readers(::google::protobuf::uint32 value) {
  set_has_readers();
  readers_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Signal.readers)
}

// optional fixed32 writers = 12;
inline bool Signal::has_writers() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Signal::set_has_writers() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Signal::clear_has_writers() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Signal::clear_writers() {
  writers_ = 0u;
  clear_has_writers();
}
inline ::google::protobuf::uint32 Signal::writers() const {
  // @@protoc_insertion_point(field_get:machinetalk.Signal.writers)
  return writers_;
}
inline void Signal::set_writers(::google::protobuf::uint32 value) {
  set_has_writers();
  writers_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Signal.writers)
}

// optional fixed32 bidirs = 13;
inline bool Signal::has_bidirs() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Signal::set_has_bidirs() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Signal::clear_has_bidirs() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Signal::clear_bidirs() {
  bidirs_ = 0u;
  clear_has_bidirs();
}
inline ::google::protobuf::uint32 Signal::bidirs() const {
  // @@protoc_insertion_point(field_get:machinetalk.Signal.bidirs)
  return bidirs_;
}
inline void Signal::set_bidirs(::google::protobuf::uint32 value) {
  set_has_bidirs();
  bidirs_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Signal.bidirs)
}

// -------------------------------------------------------------------

// Param

// optional .machinetalk.ValueType type = 1;
inline bool Param::has_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Param::set_has_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Param::clear_has_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Param::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::machinetalk::ValueType Param::type() const {
  // @@protoc_insertion_point(field_get:machinetalk.Param.type)
  return static_cast< ::machinetalk::ValueType >(type_);
}
inline void Param::set_type(::machinetalk::ValueType value) {
  assert(::machinetalk::ValueType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Param.type)
}

// optional string name = 2;
inline bool Param::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Param::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Param::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Param::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Param::name() const {
  // @@protoc_insertion_point(field_get:machinetalk.Param.name)
  return name_.GetNoArena();
}
inline void Param::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Param.name)
}
#if LANG_CXX11
inline void Param::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Param.name)
}
#endif
inline void Param::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Param.name)
}
inline void Param::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Param.name)
}
inline ::std::string* Param::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:machinetalk.Param.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Param::release_name() {
  // @@protoc_insertion_point(field_release:machinetalk.Param.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Param::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Param.name)
}

// optional fixed32 handle = 3;
inline bool Param::has_handle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Param::set_has_handle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Param::clear_has_handle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Param::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Param::handle() const {
  // @@protoc_insertion_point(field_get:machinetalk.Param.handle)
  return handle_;
}
inline void Param::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Param.handle)
}

// optional bool halbit = 5;
inline bool Param::has_halbit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Param::set_has_halbit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Param::clear_has_halbit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Param::clear_halbit() {
  halbit_ = false;
  clear_has_halbit();
}
inline bool Param::halbit() const {
  // @@protoc_insertion_point(field_get:machinetalk.Param.halbit)
  return halbit_;
}
inline void Param::set_halbit(bool value) {
  set_has_halbit();
  halbit_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Param.halbit)
}

// optional double halfloat = 6;
inline bool Param::has_halfloat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Param::set_has_halfloat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Param::clear_has_halfloat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Param::clear_halfloat() {
  halfloat_ = 0;
  clear_has_halfloat();
}
inline double Param::halfloat() const {
  // @@protoc_insertion_point(field_get:machinetalk.Param.halfloat)
  return halfloat_;
}
inline void Param::set_halfloat(double value) {
  set_has_halfloat();
  halfloat_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Param.halfloat)
}

// optional sfixed32 hals32 = 7;
inline bool Param::has_hals32() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Param::set_has_hals32() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Param::clear_has_hals32() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Param::clear_hals32() {
  hals32_ = 0;
  clear_has_hals32();
}
inline ::google::protobuf::int32 Param::hals32() const {
  // @@protoc_insertion_point(field_get:machinetalk.Param.hals32)
  return hals32_;
}
inline void Param::set_hals32(::google::protobuf::int32 value) {
  set_has_hals32();
  hals32_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Param.hals32)
}

// optional fixed32 halu32 = 8;
inline bool Param::has_halu32() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Param::set_has_halu32() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Param::clear_has_halu32() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Param::clear_halu32() {
  halu32_ = 0u;
  clear_has_halu32();
}
inline ::google::protobuf::uint32 Param::halu32() const {
  // @@protoc_insertion_point(field_get:machinetalk.Param.halu32)
  return halu32_;
}
inline void Param::set_halu32(::google::protobuf::uint32 value) {
  set_has_halu32();
  halu32_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Param.halu32)
}

// optional string strval = 9;
inline bool Param::has_strval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Param::set_has_strval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Param::clear_has_strval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Param::clear_strval() {
  strval_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_strval();
}
inline const ::std::string& Param::strval() const {
  // @@protoc_insertion_point(field_get:machinetalk.Param.strval)
  return strval_.GetNoArena();
}
inline void Param::set_strval(const ::std::string& value) {
  set_has_strval();
  strval_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Param.strval)
}
#if LANG_CXX11
inline void Param::set_strval(::std::string&& value) {
  set_has_strval();
  strval_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Param.strval)
}
#endif
inline void Param::set_strval(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_strval();
  strval_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Param.strval)
}
inline void Param::set_strval(const char* value, size_t size) {
  set_has_strval();
  strval_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Param.strval)
}
inline ::std::string* Param::mutable_strval() {
  set_has_strval();
  // @@protoc_insertion_point(field_mutable:machinetalk.Param.strval)
  return strval_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Param::release_strval() {
  // @@protoc_insertion_point(field_release:machinetalk.Param.strval)
  if (!has_strval()) {
    return NULL;
  }
  clear_has_strval();
  return strval_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Param::set_allocated_strval(::std::string* strval) {
  if (strval != NULL) {
    set_has_strval();
  } else {
    clear_has_strval();
  }
  strval_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), strval);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Param.strval)
}

// optional bytes blob = 10;
inline bool Param::has_blob() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Param::set_has_blob() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Param::clear_has_blob() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Param::clear_blob() {
  blob_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_blob();
}
inline const ::std::string& Param::blob() const {
  // @@protoc_insertion_point(field_get:machinetalk.Param.blob)
  return blob_.GetNoArena();
}
inline void Param::set_blob(const ::std::string& value) {
  set_has_blob();
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Param.blob)
}
#if LANG_CXX11
inline void Param::set_blob(::std::string&& value) {
  set_has_blob();
  blob_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Param.blob)
}
#endif
inline void Param::set_blob(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_blob();
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Param.blob)
}
inline void Param::set_blob(const void* value, size_t size) {
  set_has_blob();
  blob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Param.blob)
}
inline ::std::string* Param::mutable_blob() {
  set_has_blob();
  // @@protoc_insertion_point(field_mutable:machinetalk.Param.blob)
  return blob_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Param::release_blob() {
  // @@protoc_insertion_point(field_release:machinetalk.Param.blob)
  if (!has_blob()) {
    return NULL;
  }
  clear_has_blob();
  return blob_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Param::set_allocated_blob(::std::string* blob) {
  if (blob != NULL) {
    set_has_blob();
  } else {
    clear_has_blob();
  }
  blob_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blob);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Param.blob)
}

// optional .machinetalk.HalParamDirection dir = 11;
inline bool Param::has_dir() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Param::set_has_dir() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Param::clear_has_dir() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Param::clear_dir() {
  dir_ = 64;
  clear_has_dir();
}
inline ::machinetalk::HalParamDirection Param::dir() const {
  // @@protoc_insertion_point(field_get:machinetalk.Param.dir)
  return static_cast< ::machinetalk::HalParamDirection >(dir_);
}
inline void Param::set_dir(::machinetalk::HalParamDirection value) {
  assert(::machinetalk::HalParamDirection_IsValid(value));
  set_has_dir();
  dir_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Param.dir)
}

// optional string oldname = 12;
inline bool Param::has_oldname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Param::set_has_oldname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Param::clear_has_oldname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Param::clear_oldname() {
  oldname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_oldname();
}
inline const ::std::string& Param::oldname() const {
  // @@protoc_insertion_point(field_get:machinetalk.Param.oldname)
  return oldname_.GetNoArena();
}
inline void Param::set_oldname(const ::std::string& value) {
  set_has_oldname();
  oldname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Param.oldname)
}
#if LANG_CXX11
inline void Param::set_oldname(::std::string&& value) {
  set_has_oldname();
  oldname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Param.oldname)
}
#endif
inline void Param::set_oldname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_oldname();
  oldname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Param.oldname)
}
inline void Param::set_oldname(const char* value, size_t size) {
  set_has_oldname();
  oldname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Param.oldname)
}
inline ::std::string* Param::mutable_oldname() {
  set_has_oldname();
  // @@protoc_insertion_point(field_mutable:machinetalk.Param.oldname)
  return oldname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Param::release_oldname() {
  // @@protoc_insertion_point(field_release:machinetalk.Param.oldname)
  if (!has_oldname()) {
    return NULL;
  }
  clear_has_oldname();
  return oldname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Param::set_allocated_oldname(::std::string* oldname) {
  if (oldname != NULL) {
    set_has_oldname();
  } else {
    clear_has_oldname();
  }
  oldname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oldname);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Param.oldname)
}

// optional sfixed32 owner = 13;
inline bool Param::has_owner() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Param::set_has_owner() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Param::clear_has_owner() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Param::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::google::protobuf::int32 Param::owner() const {
  // @@protoc_insertion_point(field_get:machinetalk.Param.owner)
  return owner_;
}
inline void Param::set_owner(::google::protobuf::int32 value) {
  set_has_owner();
  owner_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Param.owner)
}

// optional sfixed32 runtime = 14;
inline bool Param::has_runtime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Param::set_has_runtime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Param::clear_has_runtime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Param::clear_runtime() {
  runtime_ = 0;
  clear_has_runtime();
}
inline ::google::protobuf::int32 Param::runtime() const {
  // @@protoc_insertion_point(field_get:machinetalk.Param.runtime)
  return runtime_;
}
inline void Param::set_runtime(::google::protobuf::int32 value) {
  set_has_runtime();
  runtime_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Param.runtime)
}

// optional sfixed32 maytime = 15;
inline bool Param::has_maytime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Param::set_has_maytime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Param::clear_has_maytime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Param::clear_maytime() {
  maytime_ = 0;
  clear_has_maytime();
}
inline ::google::protobuf::int32 Param::maytime() const {
  // @@protoc_insertion_point(field_get:machinetalk.Param.maytime)
  return maytime_;
}
inline void Param::set_maytime(::google::protobuf::int32 value) {
  set_has_maytime();
  maytime_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Param.maytime)
}

// -------------------------------------------------------------------

// Function

// optional string name = 1;
inline bool Function::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Function::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Function::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Function::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Function::name() const {
  // @@protoc_insertion_point(field_get:machinetalk.Function.name)
  return name_.GetNoArena();
}
inline void Function::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Function.name)
}
#if LANG_CXX11
inline void Function::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Function.name)
}
#endif
inline void Function::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Function.name)
}
inline void Function::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Function.name)
}
inline ::std::string* Function::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:machinetalk.Function.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Function::release_name() {
  // @@protoc_insertion_point(field_release:machinetalk.Function.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Function::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Function.name)
}

// optional fixed32 handle = 2;
inline bool Function::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Function::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Function::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Function::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Function::handle() const {
  // @@protoc_insertion_point(field_get:machinetalk.Function.handle)
  return handle_;
}
inline void Function::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Function.handle)
}

// optional fixed32 owner_id = 3;
inline bool Function::has_owner_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Function::set_has_owner_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Function::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Function::clear_owner_id() {
  owner_id_ = 0u;
  clear_has_owner_id();
}
inline ::google::protobuf::uint32 Function::owner_id() const {
  // @@protoc_insertion_point(field_get:machinetalk.Function.owner_id)
  return owner_id_;
}
inline void Function::set_owner_id(::google::protobuf::uint32 value) {
  set_has_owner_id();
  owner_id_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Function.owner_id)
}

// optional fixed32 users = 4;
inline bool Function::has_users() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Function::set_has_users() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Function::clear_has_users() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Function::clear_users() {
  users_ = 0u;
  clear_has_users();
}
inline ::google::protobuf::uint32 Function::users() const {
  // @@protoc_insertion_point(field_get:machinetalk.Function.users)
  return users_;
}
inline void Function::set_users(::google::protobuf::uint32 value) {
  set_has_users();
  users_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Function.users)
}

// optional fixed32 runtime = 5;
inline bool Function::has_runtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Function::set_has_runtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Function::clear_has_runtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Function::clear_runtime() {
  runtime_ = 0u;
  clear_has_runtime();
}
inline ::google::protobuf::uint32 Function::runtime() const {
  // @@protoc_insertion_point(field_get:machinetalk.Function.runtime)
  return runtime_;
}
inline void Function::set_runtime(::google::protobuf::uint32 value) {
  set_has_runtime();
  runtime_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Function.runtime)
}

// optional fixed32 maxtime = 6;
inline bool Function::has_maxtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Function::set_has_maxtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Function::clear_has_maxtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Function::clear_maxtime() {
  maxtime_ = 0u;
  clear_has_maxtime();
}
inline ::google::protobuf::uint32 Function::maxtime() const {
  // @@protoc_insertion_point(field_get:machinetalk.Function.maxtime)
  return maxtime_;
}
inline void Function::set_maxtime(::google::protobuf::uint32 value) {
  set_has_maxtime();
  maxtime_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Function.maxtime)
}

// optional bool reentrant = 7;
inline bool Function::has_reentrant() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Function::set_has_reentrant() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Function::clear_has_reentrant() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Function::clear_reentrant() {
  reentrant_ = false;
  clear_has_reentrant();
}
inline bool Function::reentrant() const {
  // @@protoc_insertion_point(field_get:machinetalk.Function.reentrant)
  return reentrant_;
}
inline void Function::set_reentrant(bool value) {
  set_has_reentrant();
  reentrant_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Function.reentrant)
}

// optional .machinetalk.HalFunctType type = 8;
inline bool Function::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Function::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Function::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Function::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::machinetalk::HalFunctType Function::type() const {
  // @@protoc_insertion_point(field_get:machinetalk.Function.type)
  return static_cast< ::machinetalk::HalFunctType >(type_);
}
inline void Function::set_type(::machinetalk::HalFunctType value) {
  assert(::machinetalk::HalFunctType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Function.type)
}

// optional bool maxtime_increased = 9;
inline bool Function::has_maxtime_increased() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Function::set_has_maxtime_increased() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Function::clear_has_maxtime_increased() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Function::clear_maxtime_increased() {
  maxtime_increased_ = false;
  clear_has_maxtime_increased();
}
inline bool Function::maxtime_increased() const {
  // @@protoc_insertion_point(field_get:machinetalk.Function.maxtime_increased)
  return maxtime_increased_;
}
inline void Function::set_maxtime_increased(bool value) {
  set_has_maxtime_increased();
  maxtime_increased_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Function.maxtime_increased)
}

// -------------------------------------------------------------------

// Thread

// optional string name = 1;
inline bool Thread::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Thread::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Thread::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Thread::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Thread::name() const {
  // @@protoc_insertion_point(field_get:machinetalk.Thread.name)
  return name_.GetNoArena();
}
inline void Thread::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Thread.name)
}
#if LANG_CXX11
inline void Thread::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Thread.name)
}
#endif
inline void Thread::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Thread.name)
}
inline void Thread::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Thread.name)
}
inline ::std::string* Thread::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:machinetalk.Thread.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Thread::release_name() {
  // @@protoc_insertion_point(field_release:machinetalk.Thread.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Thread::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Thread.name)
}

// optional fixed32 handle = 2;
inline bool Thread::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Thread::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Thread::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Thread::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Thread::handle() const {
  // @@protoc_insertion_point(field_get:machinetalk.Thread.handle)
  return handle_;
}
inline void Thread::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Thread.handle)
}

// optional bool uses_fp = 3;
inline bool Thread::has_uses_fp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Thread::set_has_uses_fp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Thread::clear_has_uses_fp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Thread::clear_uses_fp() {
  uses_fp_ = false;
  clear_has_uses_fp();
}
inline bool Thread::uses_fp() const {
  // @@protoc_insertion_point(field_get:machinetalk.Thread.uses_fp)
  return uses_fp_;
}
inline void Thread::set_uses_fp(bool value) {
  set_has_uses_fp();
  uses_fp_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Thread.uses_fp)
}

// optional fixed32 period = 4;
inline bool Thread::has_period() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Thread::set_has_period() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Thread::clear_has_period() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Thread::clear_period() {
  period_ = 0u;
  clear_has_period();
}
inline ::google::protobuf::uint32 Thread::period() const {
  // @@protoc_insertion_point(field_get:machinetalk.Thread.period)
  return period_;
}
inline void Thread::set_period(::google::protobuf::uint32 value) {
  set_has_period();
  period_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Thread.period)
}

// optional sfixed32 priority = 5;
inline bool Thread::has_priority() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Thread::set_has_priority() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Thread::clear_has_priority() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Thread::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 Thread::priority() const {
  // @@protoc_insertion_point(field_get:machinetalk.Thread.priority)
  return priority_;
}
inline void Thread::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Thread.priority)
}

// optional fixed32 task_id = 6;
inline bool Thread::has_task_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Thread::set_has_task_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Thread::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Thread::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 Thread::task_id() const {
  // @@protoc_insertion_point(field_get:machinetalk.Thread.task_id)
  return task_id_;
}
inline void Thread::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Thread.task_id)
}

// optional fixed32 cpu_id = 7;
inline bool Thread::has_cpu_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Thread::set_has_cpu_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Thread::clear_has_cpu_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Thread::clear_cpu_id() {
  cpu_id_ = 0u;
  clear_has_cpu_id();
}
inline ::google::protobuf::uint32 Thread::cpu_id() const {
  // @@protoc_insertion_point(field_get:machinetalk.Thread.cpu_id)
  return cpu_id_;
}
inline void Thread::set_cpu_id(::google::protobuf::uint32 value) {
  set_has_cpu_id();
  cpu_id_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Thread.cpu_id)
}

// repeated string function = 8;
inline int Thread::function_size() const {
  return function_.size();
}
inline void Thread::clear_function() {
  function_.Clear();
}
inline const ::std::string& Thread::function(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Thread.function)
  return function_.Get(index);
}
inline ::std::string* Thread::mutable_function(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Thread.function)
  return function_.Mutable(index);
}
inline void Thread::set_function(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:machinetalk.Thread.function)
  function_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Thread::set_function(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:machinetalk.Thread.function)
  function_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Thread::set_function(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  function_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:machinetalk.Thread.function)
}
inline void Thread::set_function(int index, const char* value, size_t size) {
  function_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Thread.function)
}
inline ::std::string* Thread::add_function() {
  // @@protoc_insertion_point(field_add_mutable:machinetalk.Thread.function)
  return function_.Add();
}
inline void Thread::add_function(const ::std::string& value) {
  function_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:machinetalk.Thread.function)
}
#if LANG_CXX11
inline void Thread::add_function(::std::string&& value) {
  function_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:machinetalk.Thread.function)
}
#endif
inline void Thread::add_function(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  function_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:machinetalk.Thread.function)
}
inline void Thread::add_function(const char* value, size_t size) {
  function_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:machinetalk.Thread.function)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Thread::function() const {
  // @@protoc_insertion_point(field_list:machinetalk.Thread.function)
  return function_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Thread::mutable_function() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Thread.function)
  return &function_;
}

// -------------------------------------------------------------------

// Component

// optional string name = 1;
inline bool Component::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Component::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Component::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Component::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Component::name() const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.name)
  return name_.GetNoArena();
}
inline void Component::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Component.name)
}
#if LANG_CXX11
inline void Component::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Component.name)
}
#endif
inline void Component::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Component.name)
}
inline void Component::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Component.name)
}
inline ::std::string* Component::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:machinetalk.Component.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Component::release_name() {
  // @@protoc_insertion_point(field_release:machinetalk.Component.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Component::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Component.name)
}

// optional fixed32 ninst = 2;
inline bool Component::has_ninst() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Component::set_has_ninst() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Component::clear_has_ninst() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Component::clear_ninst() {
  ninst_ = 0u;
  clear_has_ninst();
}
inline ::google::protobuf::uint32 Component::ninst() const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.ninst)
  return ninst_;
}
inline void Component::set_ninst(::google::protobuf::uint32 value) {
  set_has_ninst();
  ninst_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Component.ninst)
}

// optional sfixed32 comp_id = 4;
inline bool Component::has_comp_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Component::set_has_comp_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Component::clear_has_comp_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Component::clear_comp_id() {
  comp_id_ = 0;
  clear_has_comp_id();
}
inline ::google::protobuf::int32 Component::comp_id() const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.comp_id)
  return comp_id_;
}
inline void Component::set_comp_id(::google::protobuf::int32 value) {
  set_has_comp_id();
  comp_id_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Component.comp_id)
}

// optional fixed32 type = 5;
inline bool Component::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Component::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Component::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Component::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Component::type() const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.type)
  return type_;
}
inline void Component::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Component.type)
}

// optional fixed32 state = 6;
inline bool Component::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Component::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Component::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Component::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 Component::state() const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.state)
  return state_;
}
inline void Component::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Component.state)
}

// optional fixed32 last_update = 7;
inline bool Component::has_last_update() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Component::set_has_last_update() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Component::clear_has_last_update() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Component::clear_last_update() {
  last_update_ = 0u;
  clear_has_last_update();
}
inline ::google::protobuf::uint32 Component::last_update() const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.last_update)
  return last_update_;
}
inline void Component::set_last_update(::google::protobuf::uint32 value) {
  set_has_last_update();
  last_update_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Component.last_update)
}

// optional fixed32 last_bound = 8;
inline bool Component::has_last_bound() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Component::set_has_last_bound() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Component::clear_has_last_bound() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Component::clear_last_bound() {
  last_bound_ = 0u;
  clear_has_last_bound();
}
inline ::google::protobuf::uint32 Component::last_bound() const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.last_bound)
  return last_bound_;
}
inline void Component::set_last_bound(::google::protobuf::uint32 value) {
  set_has_last_bound();
  last_bound_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Component.last_bound)
}

// optional fixed32 last_unbound = 9;
inline bool Component::has_last_unbound() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Component::set_has_last_unbound() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Component::clear_has_last_unbound() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Component::clear_last_unbound() {
  last_unbound_ = 0u;
  clear_has_last_unbound();
}
inline ::google::protobuf::uint32 Component::last_unbound() const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.last_unbound)
  return last_unbound_;
}
inline void Component::set_last_unbound(::google::protobuf::uint32 value) {
  set_has_last_unbound();
  last_unbound_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Component.last_unbound)
}

// optional fixed32 pid = 10;
inline bool Component::has_pid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Component::set_has_pid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Component::clear_has_pid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Component::clear_pid() {
  pid_ = 0u;
  clear_has_pid();
}
inline ::google::protobuf::uint32 Component::pid() const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.pid)
  return pid_;
}
inline void Component::set_pid(::google::protobuf::uint32 value) {
  set_has_pid();
  pid_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Component.pid)
}

// optional string args = 11;
inline bool Component::has_args() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Component::set_has_args() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Component::clear_has_args() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Component::clear_args() {
  args_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_args();
}
inline const ::std::string& Component::args() const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.args)
  return args_.GetNoArena();
}
inline void Component::set_args(const ::std::string& value) {
  set_has_args();
  args_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Component.args)
}
#if LANG_CXX11
inline void Component::set_args(::std::string&& value) {
  set_has_args();
  args_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Component.args)
}
#endif
inline void Component::set_args(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_args();
  args_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Component.args)
}
inline void Component::set_args(const char* value, size_t size) {
  set_has_args();
  args_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Component.args)
}
inline ::std::string* Component::mutable_args() {
  set_has_args();
  // @@protoc_insertion_point(field_mutable:machinetalk.Component.args)
  return args_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Component::release_args() {
  // @@protoc_insertion_point(field_release:machinetalk.Component.args)
  if (!has_args()) {
    return NULL;
  }
  clear_has_args();
  return args_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Component::set_allocated_args(::std::string* args) {
  if (args != NULL) {
    set_has_args();
  } else {
    clear_has_args();
  }
  args_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), args);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Component.args)
}

// optional sfixed32 timer = 12;
inline bool Component::has_timer() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Component::set_has_timer() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Component::clear_has_timer() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Component::clear_timer() {
  timer_ = 0;
  clear_has_timer();
}
inline ::google::protobuf::int32 Component::timer() const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.timer)
  return timer_;
}
inline void Component::set_timer(::google::protobuf::int32 value) {
  set_has_timer();
  timer_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Component.timer)
}

// optional sfixed32 userarg1 = 14;
inline bool Component::has_userarg1() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Component::set_has_userarg1() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Component::clear_has_userarg1() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Component::clear_userarg1() {
  userarg1_ = 0;
  clear_has_userarg1();
}
inline ::google::protobuf::int32 Component::userarg1() const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.userarg1)
  return userarg1_;
}
inline void Component::set_userarg1(::google::protobuf::int32 value) {
  set_has_userarg1();
  userarg1_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Component.userarg1)
}

// optional sfixed32 userarg2 = 15;
inline bool Component::has_userarg2() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Component::set_has_userarg2() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Component::clear_has_userarg2() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Component::clear_userarg2() {
  userarg2_ = 0;
  clear_has_userarg2();
}
inline ::google::protobuf::int32 Component::userarg2() const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.userarg2)
  return userarg2_;
}
inline void Component::set_userarg2(::google::protobuf::int32 value) {
  set_has_userarg2();
  userarg2_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Component.userarg2)
}

// repeated .machinetalk.Pin pin = 16;
inline int Component::pin_size() const {
  return pin_.size();
}
inline void Component::clear_pin() {
  pin_.Clear();
}
inline ::machinetalk::Pin* Component::mutable_pin(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Component.pin)
  return pin_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Pin >*
Component::mutable_pin() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Component.pin)
  return &pin_;
}
inline const ::machinetalk::Pin& Component::pin(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.pin)
  return pin_.Get(index);
}
inline ::machinetalk::Pin* Component::add_pin() {
  // @@protoc_insertion_point(field_add:machinetalk.Component.pin)
  return pin_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Pin >&
Component::pin() const {
  // @@protoc_insertion_point(field_list:machinetalk.Component.pin)
  return pin_;
}

// repeated .machinetalk.Param param = 17;
inline int Component::param_size() const {
  return param_.size();
}
inline void Component::clear_param() {
  param_.Clear();
}
inline ::machinetalk::Param* Component::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Component.param)
  return param_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Param >*
Component::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Component.param)
  return &param_;
}
inline const ::machinetalk::Param& Component::param(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.param)
  return param_.Get(index);
}
inline ::machinetalk::Param* Component::add_param() {
  // @@protoc_insertion_point(field_add:machinetalk.Component.param)
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Param >&
Component::param() const {
  // @@protoc_insertion_point(field_list:machinetalk.Component.param)
  return param_;
}

// repeated .machinetalk.Function funct = 19;
inline int Component::funct_size() const {
  return funct_.size();
}
inline void Component::clear_funct() {
  funct_.Clear();
}
inline ::machinetalk::Function* Component::mutable_funct(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Component.funct)
  return funct_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Function >*
Component::mutable_funct() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Component.funct)
  return &funct_;
}
inline const ::machinetalk::Function& Component::funct(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.funct)
  return funct_.Get(index);
}
inline ::machinetalk::Function* Component::add_funct() {
  // @@protoc_insertion_point(field_add:machinetalk.Component.funct)
  return funct_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Function >&
Component::funct() const {
  // @@protoc_insertion_point(field_list:machinetalk.Component.funct)
  return funct_;
}

// optional bool no_create = 18;
inline bool Component::has_no_create() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Component::set_has_no_create() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Component::clear_has_no_create() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Component::clear_no_create() {
  no_create_ = false;
  clear_has_no_create();
}
inline bool Component::no_create() const {
  // @@protoc_insertion_point(field_get:machinetalk.Component.no_create)
  return no_create_;
}
inline void Component::set_no_create(bool value) {
  set_has_no_create();
  no_create_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Component.no_create)
}

// -------------------------------------------------------------------

// Ring

// optional string name = 1;
inline bool Ring::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ring::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ring::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ring::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Ring::name() const {
  // @@protoc_insertion_point(field_get:machinetalk.Ring.name)
  return name_.GetNoArena();
}
inline void Ring::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Ring.name)
}
#if LANG_CXX11
inline void Ring::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Ring.name)
}
#endif
inline void Ring::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Ring.name)
}
inline void Ring::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Ring.name)
}
inline ::std::string* Ring::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:machinetalk.Ring.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ring::release_name() {
  // @@protoc_insertion_point(field_release:machinetalk.Ring.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ring::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Ring.name)
}

// optional fixed32 handle = 2;
inline bool Ring::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ring::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ring::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ring::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Ring::handle() const {
  // @@protoc_insertion_point(field_get:machinetalk.Ring.handle)
  return handle_;
}
inline void Ring::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Ring.handle)
}

// optional sfixed32 owner = 3;
inline bool Ring::has_owner() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ring::set_has_owner() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ring::clear_has_owner() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ring::clear_owner() {
  owner_ = 0;
  clear_has_owner();
}
inline ::google::protobuf::int32 Ring::owner() const {
  // @@protoc_insertion_point(field_get:machinetalk.Ring.owner)
  return owner_;
}
inline void Ring::set_owner(::google::protobuf::int32 value) {
  set_has_owner();
  owner_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Ring.owner)
}

// optional bool stream = 4;
inline bool Ring::has_stream() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ring::set_has_stream() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ring::clear_has_stream() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ring::clear_stream() {
  stream_ = false;
  clear_has_stream();
}
inline bool Ring::stream() const {
  // @@protoc_insertion_point(field_get:machinetalk.Ring.stream)
  return stream_;
}
inline void Ring::set_stream(bool value) {
  set_has_stream();
  stream_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Ring.stream)
}

// optional bool wmutex = 5;
inline bool Ring::has_wmutex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ring::set_has_wmutex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ring::clear_has_wmutex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ring::clear_wmutex() {
  wmutex_ = false;
  clear_has_wmutex();
}
inline bool Ring::wmutex() const {
  // @@protoc_insertion_point(field_get:machinetalk.Ring.wmutex)
  return wmutex_;
}
inline void Ring::set_wmutex(bool value) {
  set_has_wmutex();
  wmutex_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Ring.wmutex)
}

// optional bool rmutex = 6;
inline bool Ring::has_rmutex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Ring::set_has_rmutex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Ring::clear_has_rmutex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Ring::clear_rmutex() {
  rmutex_ = false;
  clear_has_rmutex();
}
inline bool Ring::rmutex() const {
  // @@protoc_insertion_point(field_get:machinetalk.Ring.rmutex)
  return rmutex_;
}
inline void Ring::set_rmutex(bool value) {
  set_has_rmutex();
  rmutex_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Ring.rmutex)
}

// optional bool rtapi_shm = 7;
inline bool Ring::has_rtapi_shm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Ring::set_has_rtapi_shm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Ring::clear_has_rtapi_shm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Ring::clear_rtapi_shm() {
  rtapi_shm_ = false;
  clear_has_rtapi_shm();
}
inline bool Ring::rtapi_shm() const {
  // @@protoc_insertion_point(field_get:machinetalk.Ring.rtapi_shm)
  return rtapi_shm_;
}
inline void Ring::set_rtapi_shm(bool value) {
  set_has_rtapi_shm();
  rtapi_shm_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Ring.rtapi_shm)
}

// optional sfixed32 reader = 8;
inline bool Ring::has_reader() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Ring::set_has_reader() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Ring::clear_has_reader() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Ring::clear_reader() {
  reader_ = 0;
  clear_has_reader();
}
inline ::google::protobuf::int32 Ring::reader() const {
  // @@protoc_insertion_point(field_get:machinetalk.Ring.reader)
  return reader_;
}
inline void Ring::set_reader(::google::protobuf::int32 value) {
  set_has_reader();
  reader_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Ring.reader)
}

// optional sfixed32 writer = 9;
inline bool Ring::has_writer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Ring::set_has_writer() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Ring::clear_has_writer() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Ring::clear_writer() {
  writer_ = 0;
  clear_has_writer();
}
inline ::google::protobuf::int32 Ring::writer() const {
  // @@protoc_insertion_point(field_get:machinetalk.Ring.writer)
  return writer_;
}
inline void Ring::set_writer(::google::protobuf::int32 value) {
  set_has_writer();
  writer_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Ring.writer)
}

// optional sfixed32 total_size = 10;
inline bool Ring::has_total_size() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Ring::set_has_total_size() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Ring::clear_has_total_size() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Ring::clear_total_size() {
  total_size_ = 0;
  clear_has_total_size();
}
inline ::google::protobuf::int32 Ring::total_size() const {
  // @@protoc_insertion_point(field_get:machinetalk.Ring.total_size)
  return total_size_;
}
inline void Ring::set_total_size(::google::protobuf::int32 value) {
  set_has_total_size();
  total_size_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Ring.total_size)
}

// optional sfixed32 scratchpad = 11;
inline bool Ring::has_scratchpad() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Ring::set_has_scratchpad() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Ring::clear_has_scratchpad() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Ring::clear_scratchpad() {
  scratchpad_ = 0;
  clear_has_scratchpad();
}
inline ::google::protobuf::int32 Ring::scratchpad() const {
  // @@protoc_insertion_point(field_get:machinetalk.Ring.scratchpad)
  return scratchpad_;
}
inline void Ring::set_scratchpad(::google::protobuf::int32 value) {
  set_has_scratchpad();
  scratchpad_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Ring.scratchpad)
}

// optional sfixed32 ring_shmkey = 12;
inline bool Ring::has_ring_shmkey() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Ring::set_has_ring_shmkey() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Ring::clear_has_ring_shmkey() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Ring::clear_ring_shmkey() {
  ring_shmkey_ = 0;
  clear_has_ring_shmkey();
}
inline ::google::protobuf::int32 Ring::ring_shmkey() const {
  // @@protoc_insertion_point(field_get:machinetalk.Ring.ring_shmkey)
  return ring_shmkey_;
}
inline void Ring::set_ring_shmkey(::google::protobuf::int32 value) {
  set_has_ring_shmkey();
  ring_shmkey_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Ring.ring_shmkey)
}

// optional fixed32 encodings = 13;
inline bool Ring::has_encodings() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Ring::set_has_encodings() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Ring::clear_has_encodings() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Ring::clear_encodings() {
  encodings_ = 0u;
  clear_has_encodings();
}
inline ::google::protobuf::uint32 Ring::encodings() const {
  // @@protoc_insertion_point(field_get:machinetalk.Ring.encodings)
  return encodings_;
}
inline void Ring::set_encodings(::google::protobuf::uint32 value) {
  set_has_encodings();
  encodings_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Ring.encodings)
}

// -------------------------------------------------------------------

// Member

// optional .machinetalk.ObjectType mtype = 1;
inline bool Member::has_mtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Member::set_has_mtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Member::clear_has_mtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Member::clear_mtype() {
  mtype_ = 0;
  clear_has_mtype();
}
inline ::machinetalk::ObjectType Member::mtype() const {
  // @@protoc_insertion_point(field_get:machinetalk.Member.mtype)
  return static_cast< ::machinetalk::ObjectType >(mtype_);
}
inline void Member::set_mtype(::machinetalk::ObjectType value) {
  assert(::machinetalk::ObjectType_IsValid(value));
  set_has_mtype();
  mtype_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Member.mtype)
}

// optional sfixed32 userarg1 = 2;
inline bool Member::has_userarg1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Member::set_has_userarg1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Member::clear_has_userarg1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Member::clear_userarg1() {
  userarg1_ = 0;
  clear_has_userarg1();
}
inline ::google::protobuf::int32 Member::userarg1() const {
  // @@protoc_insertion_point(field_get:machinetalk.Member.userarg1)
  return userarg1_;
}
inline void Member::set_userarg1(::google::protobuf::int32 value) {
  set_has_userarg1();
  userarg1_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Member.userarg1)
}

// optional double epsilon = 3;
inline bool Member::has_epsilon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Member::set_has_epsilon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Member::clear_has_epsilon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Member::clear_epsilon() {
  epsilon_ = 0;
  clear_has_epsilon();
}
inline double Member::epsilon() const {
  // @@protoc_insertion_point(field_get:machinetalk.Member.epsilon)
  return epsilon_;
}
inline void Member::set_epsilon(double value) {
  set_has_epsilon();
  epsilon_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Member.epsilon)
}

// optional .machinetalk.Signal signal = 4;
inline bool Member::has_signal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Member::set_has_signal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Member::clear_has_signal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Member::clear_signal() {
  if (signal_ != NULL) signal_->Clear();
  clear_has_signal();
}
inline const ::machinetalk::Signal& Member::_internal_signal() const {
  return *signal_;
}
inline const ::machinetalk::Signal& Member::signal() const {
  const ::machinetalk::Signal* p = signal_;
  // @@protoc_insertion_point(field_get:machinetalk.Member.signal)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Signal*>(
      &::machinetalk::_Signal_default_instance_);
}
inline ::machinetalk::Signal* Member::release_signal() {
  // @@protoc_insertion_point(field_release:machinetalk.Member.signal)
  clear_has_signal();
  ::machinetalk::Signal* temp = signal_;
  signal_ = NULL;
  return temp;
}
inline ::machinetalk::Signal* Member::mutable_signal() {
  set_has_signal();
  if (signal_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Signal>(GetArenaNoVirtual());
    signal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Member.signal)
  return signal_;
}
inline void Member::set_allocated_signal(::machinetalk::Signal* signal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete signal_;
  }
  if (signal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      signal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, signal, submessage_arena);
    }
    set_has_signal();
  } else {
    clear_has_signal();
  }
  signal_ = signal;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Member.signal)
}

// optional string groupname = 5;
inline bool Member::has_groupname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Member::set_has_groupname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Member::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Member::clear_groupname() {
  groupname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_groupname();
}
inline const ::std::string& Member::groupname() const {
  // @@protoc_insertion_point(field_get:machinetalk.Member.groupname)
  return groupname_.GetNoArena();
}
inline void Member::set_groupname(const ::std::string& value) {
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Member.groupname)
}
#if LANG_CXX11
inline void Member::set_groupname(::std::string&& value) {
  set_has_groupname();
  groupname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Member.groupname)
}
#endif
inline void Member::set_groupname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Member.groupname)
}
inline void Member::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  groupname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Member.groupname)
}
inline ::std::string* Member::mutable_groupname() {
  set_has_groupname();
  // @@protoc_insertion_point(field_mutable:machinetalk.Member.groupname)
  return groupname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Member::release_groupname() {
  // @@protoc_insertion_point(field_release:machinetalk.Member.groupname)
  if (!has_groupname()) {
    return NULL;
  }
  clear_has_groupname();
  return groupname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Member::set_allocated_groupname(::std::string* groupname) {
  if (groupname != NULL) {
    set_has_groupname();
  } else {
    clear_has_groupname();
  }
  groupname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), groupname);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Member.groupname)
}

// optional fixed32 handle = 6;
inline bool Member::has_handle() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Member::set_has_handle() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Member::clear_has_handle() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Member::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Member::handle() const {
  // @@protoc_insertion_point(field_get:machinetalk.Member.handle)
  return handle_;
}
inline void Member::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Member.handle)
}

// optional .machinetalk.Pin pin = 7;
inline bool Member::has_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Member::set_has_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Member::clear_has_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Member::clear_pin() {
  if (pin_ != NULL) pin_->Clear();
  clear_has_pin();
}
inline const ::machinetalk::Pin& Member::_internal_pin() const {
  return *pin_;
}
inline const ::machinetalk::Pin& Member::pin() const {
  const ::machinetalk::Pin* p = pin_;
  // @@protoc_insertion_point(field_get:machinetalk.Member.pin)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Pin*>(
      &::machinetalk::_Pin_default_instance_);
}
inline ::machinetalk::Pin* Member::release_pin() {
  // @@protoc_insertion_point(field_release:machinetalk.Member.pin)
  clear_has_pin();
  ::machinetalk::Pin* temp = pin_;
  pin_ = NULL;
  return temp;
}
inline ::machinetalk::Pin* Member::mutable_pin() {
  set_has_pin();
  if (pin_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Pin>(GetArenaNoVirtual());
    pin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Member.pin)
  return pin_;
}
inline void Member::set_allocated_pin(::machinetalk::Pin* pin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pin_;
  }
  if (pin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pin, submessage_arena);
    }
    set_has_pin();
  } else {
    clear_has_pin();
  }
  pin_ = pin;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Member.pin)
}

// optional .machinetalk.Param param = 8;
inline bool Member::has_param() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Member::set_has_param() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Member::clear_has_param() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Member::clear_param() {
  if (param_ != NULL) param_->Clear();
  clear_has_param();
}
inline const ::machinetalk::Param& Member::_internal_param() const {
  return *param_;
}
inline const ::machinetalk::Param& Member::param() const {
  const ::machinetalk::Param* p = param_;
  // @@protoc_insertion_point(field_get:machinetalk.Member.param)
  return p != NULL ? *p : *reinterpret_cast<const ::machinetalk::Param*>(
      &::machinetalk::_Param_default_instance_);
}
inline ::machinetalk::Param* Member::release_param() {
  // @@protoc_insertion_point(field_release:machinetalk.Member.param)
  clear_has_param();
  ::machinetalk::Param* temp = param_;
  param_ = NULL;
  return temp;
}
inline ::machinetalk::Param* Member::mutable_param() {
  set_has_param();
  if (param_ == NULL) {
    auto* p = CreateMaybeMessage<::machinetalk::Param>(GetArenaNoVirtual());
    param_ = p;
  }
  // @@protoc_insertion_point(field_mutable:machinetalk.Member.param)
  return param_;
}
inline void Member::set_allocated_param(::machinetalk::Param* param) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete param_;
  }
  if (param) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      param = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, param, submessage_arena);
    }
    set_has_param();
  } else {
    clear_has_param();
  }
  param_ = param;
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Member.param)
}

// -------------------------------------------------------------------

// Group

// optional string name = 1;
inline bool Group::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Group::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Group::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Group::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Group::name() const {
  // @@protoc_insertion_point(field_get:machinetalk.Group.name)
  return name_.GetNoArena();
}
inline void Group::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Group.name)
}
#if LANG_CXX11
inline void Group::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Group.name)
}
#endif
inline void Group::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Group.name)
}
inline void Group::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Group.name)
}
inline ::std::string* Group::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:machinetalk.Group.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_name() {
  // @@protoc_insertion_point(field_release:machinetalk.Group.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Group.name)
}

// optional fixed32 handle = 2;
inline bool Group::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Group::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Group::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Group::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Group::handle() const {
  // @@protoc_insertion_point(field_get:machinetalk.Group.handle)
  return handle_;
}
inline void Group::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Group.handle)
}

// optional sfixed32 userarg1 = 4;
inline bool Group::has_userarg1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Group::set_has_userarg1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Group::clear_has_userarg1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Group::clear_userarg1() {
  userarg1_ = 0;
  clear_has_userarg1();
}
inline ::google::protobuf::int32 Group::userarg1() const {
  // @@protoc_insertion_point(field_get:machinetalk.Group.userarg1)
  return userarg1_;
}
inline void Group::set_userarg1(::google::protobuf::int32 value) {
  set_has_userarg1();
  userarg1_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Group.userarg1)
}

// optional sfixed32 userarg2 = 5;
inline bool Group::has_userarg2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Group::set_has_userarg2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Group::clear_has_userarg2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Group::clear_userarg2() {
  userarg2_ = 0;
  clear_has_userarg2();
}
inline ::google::protobuf::int32 Group::userarg2() const {
  // @@protoc_insertion_point(field_get:machinetalk.Group.userarg2)
  return userarg2_;
}
inline void Group::set_userarg2(::google::protobuf::int32 value) {
  set_has_userarg2();
  userarg2_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Group.userarg2)
}

// optional sfixed32 refcount = 6;
inline bool Group::has_refcount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Group::set_has_refcount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Group::clear_has_refcount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Group::clear_refcount() {
  refcount_ = 0;
  clear_has_refcount();
}
inline ::google::protobuf::int32 Group::refcount() const {
  // @@protoc_insertion_point(field_get:machinetalk.Group.refcount)
  return refcount_;
}
inline void Group::set_refcount(::google::protobuf::int32 value) {
  set_has_refcount();
  refcount_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Group.refcount)
}

// repeated .machinetalk.Member member = 7;
inline int Group::member_size() const {
  return member_.size();
}
inline void Group::clear_member() {
  member_.Clear();
}
inline ::machinetalk::Member* Group::mutable_member(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Group.member)
  return member_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Member >*
Group::mutable_member() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Group.member)
  return &member_;
}
inline const ::machinetalk::Member& Group::member(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Group.member)
  return member_.Get(index);
}
inline ::machinetalk::Member* Group::add_member() {
  // @@protoc_insertion_point(field_add:machinetalk.Group.member)
  return member_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Member >&
Group::member() const {
  // @@protoc_insertion_point(field_list:machinetalk.Group.member)
  return member_;
}

// -------------------------------------------------------------------

// ProtocolParameters

// optional sfixed32 keepalive_timer = 1;
inline bool ProtocolParameters::has_keepalive_timer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtocolParameters::set_has_keepalive_timer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtocolParameters::clear_has_keepalive_timer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtocolParameters::clear_keepalive_timer() {
  keepalive_timer_ = 0;
  clear_has_keepalive_timer();
}
inline ::google::protobuf::int32 ProtocolParameters::keepalive_timer() const {
  // @@protoc_insertion_point(field_get:machinetalk.ProtocolParameters.keepalive_timer)
  return keepalive_timer_;
}
inline void ProtocolParameters::set_keepalive_timer(::google::protobuf::int32 value) {
  set_has_keepalive_timer();
  keepalive_timer_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.ProtocolParameters.keepalive_timer)
}

// optional sfixed32 group_timer = 2;
inline bool ProtocolParameters::has_group_timer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtocolParameters::set_has_group_timer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtocolParameters::clear_has_group_timer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtocolParameters::clear_group_timer() {
  group_timer_ = 0;
  clear_has_group_timer();
}
inline ::google::protobuf::int32 ProtocolParameters::group_timer() const {
  // @@protoc_insertion_point(field_get:machinetalk.ProtocolParameters.group_timer)
  return group_timer_;
}
inline void ProtocolParameters::set_group_timer(::google::protobuf::int32 value) {
  set_has_group_timer();
  group_timer_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.ProtocolParameters.group_timer)
}

// optional sfixed32 rcomp_timer = 3;
inline bool ProtocolParameters::has_rcomp_timer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtocolParameters::set_has_rcomp_timer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtocolParameters::clear_has_rcomp_timer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtocolParameters::clear_rcomp_timer() {
  rcomp_timer_ = 0;
  clear_has_rcomp_timer();
}
inline ::google::protobuf::int32 ProtocolParameters::rcomp_timer() const {
  // @@protoc_insertion_point(field_get:machinetalk.ProtocolParameters.rcomp_timer)
  return rcomp_timer_;
}
inline void ProtocolParameters::set_rcomp_timer(::google::protobuf::int32 value) {
  set_has_rcomp_timer();
  rcomp_timer_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.ProtocolParameters.rcomp_timer)
}

// -------------------------------------------------------------------

// Vtable

// optional string name = 1;
inline bool Vtable::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vtable::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vtable::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vtable::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Vtable::name() const {
  // @@protoc_insertion_point(field_get:machinetalk.Vtable.name)
  return name_.GetNoArena();
}
inline void Vtable::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Vtable.name)
}
#if LANG_CXX11
inline void Vtable::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Vtable.name)
}
#endif
inline void Vtable::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Vtable.name)
}
inline void Vtable::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Vtable.name)
}
inline ::std::string* Vtable::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:machinetalk.Vtable.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Vtable::release_name() {
  // @@protoc_insertion_point(field_release:machinetalk.Vtable.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Vtable::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Vtable.name)
}

// optional fixed32 handle = 2;
inline bool Vtable::has_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vtable::set_has_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vtable::clear_has_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vtable::clear_handle() {
  handle_ = 0u;
  clear_has_handle();
}
inline ::google::protobuf::uint32 Vtable::handle() const {
  // @@protoc_insertion_point(field_get:machinetalk.Vtable.handle)
  return handle_;
}
inline void Vtable::set_handle(::google::protobuf::uint32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Vtable.handle)
}

// optional sfixed32 owner_id = 3;
inline bool Vtable::has_owner_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vtable::set_has_owner_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vtable::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vtable::clear_owner_id() {
  owner_id_ = 0;
  clear_has_owner_id();
}
inline ::google::protobuf::int32 Vtable::owner_id() const {
  // @@protoc_insertion_point(field_get:machinetalk.Vtable.owner_id)
  return owner_id_;
}
inline void Vtable::set_owner_id(::google::protobuf::int32 value) {
  set_has_owner_id();
  owner_id_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Vtable.owner_id)
}

// optional fixed32 context = 5;
inline bool Vtable::has_context() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vtable::set_has_context() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vtable::clear_has_context() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vtable::clear_context() {
  context_ = 0u;
  clear_has_context();
}
inline ::google::protobuf::uint32 Vtable::context() const {
  // @@protoc_insertion_point(field_get:machinetalk.Vtable.context)
  return context_;
}
inline void Vtable::set_context(::google::protobuf::uint32 value) {
  set_has_context();
  context_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Vtable.context)
}

// optional sfixed32 refcount = 6;
inline bool Vtable::has_refcount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Vtable::set_has_refcount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Vtable::clear_has_refcount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Vtable::clear_refcount() {
  refcount_ = 0;
  clear_has_refcount();
}
inline ::google::protobuf::int32 Vtable::refcount() const {
  // @@protoc_insertion_point(field_get:machinetalk.Vtable.refcount)
  return refcount_;
}
inline void Vtable::set_refcount(::google::protobuf::int32 value) {
  set_has_refcount();
  refcount_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Vtable.refcount)
}

// optional sfixed32 version = 7;
inline bool Vtable::has_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Vtable::set_has_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Vtable::clear_has_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Vtable::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Vtable::version() const {
  // @@protoc_insertion_point(field_get:machinetalk.Vtable.version)
  return version_;
}
inline void Vtable::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Vtable.version)
}

// optional fixed64 vtable = 8;
inline bool Vtable::has_vtable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Vtable::set_has_vtable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Vtable::clear_has_vtable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Vtable::clear_vtable() {
  vtable_ = GOOGLE_ULONGLONG(0);
  clear_has_vtable();
}
inline ::google::protobuf::uint64 Vtable::vtable() const {
  // @@protoc_insertion_point(field_get:machinetalk.Vtable.vtable)
  return vtable_;
}
inline void Vtable::set_vtable(::google::protobuf::uint64 value) {
  set_has_vtable();
  vtable_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Vtable.vtable)
}

// -------------------------------------------------------------------

// Inst

// optional string name = 1;
inline bool Inst::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Inst::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Inst::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Inst::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Inst::name() const {
  // @@protoc_insertion_point(field_get:machinetalk.Inst.name)
  return name_.GetNoArena();
}
inline void Inst::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:machinetalk.Inst.name)
}
#if LANG_CXX11
inline void Inst::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:machinetalk.Inst.name)
}
#endif
inline void Inst::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:machinetalk.Inst.name)
}
inline void Inst::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:machinetalk.Inst.name)
}
inline ::std::string* Inst::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:machinetalk.Inst.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Inst::release_name() {
  // @@protoc_insertion_point(field_release:machinetalk.Inst.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Inst::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:machinetalk.Inst.name)
}

// optional sfixed32 comp_id = 2;
inline bool Inst::has_comp_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Inst::set_has_comp_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Inst::clear_has_comp_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Inst::clear_comp_id() {
  comp_id_ = 0;
  clear_has_comp_id();
}
inline ::google::protobuf::int32 Inst::comp_id() const {
  // @@protoc_insertion_point(field_get:machinetalk.Inst.comp_id)
  return comp_id_;
}
inline void Inst::set_comp_id(::google::protobuf::int32 value) {
  set_has_comp_id();
  comp_id_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Inst.comp_id)
}

// optional fixed32 inst_id = 3;
inline bool Inst::has_inst_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Inst::set_has_inst_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Inst::clear_has_inst_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Inst::clear_inst_id() {
  inst_id_ = 0u;
  clear_has_inst_id();
}
inline ::google::protobuf::uint32 Inst::inst_id() const {
  // @@protoc_insertion_point(field_get:machinetalk.Inst.inst_id)
  return inst_id_;
}
inline void Inst::set_inst_id(::google::protobuf::uint32 value) {
  set_has_inst_id();
  inst_id_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Inst.inst_id)
}

// optional fixed32 inst_size = 4;
inline bool Inst::has_inst_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Inst::set_has_inst_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Inst::clear_has_inst_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Inst::clear_inst_size() {
  inst_size_ = 0u;
  clear_has_inst_size();
}
inline ::google::protobuf::uint32 Inst::inst_size() const {
  // @@protoc_insertion_point(field_get:machinetalk.Inst.inst_size)
  return inst_size_;
}
inline void Inst::set_inst_size(::google::protobuf::uint32 value) {
  set_has_inst_size();
  inst_size_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Inst.inst_size)
}

// optional fixed64 vtable = 5;
inline bool Inst::has_vtable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Inst::set_has_vtable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Inst::clear_has_vtable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Inst::clear_vtable() {
  vtable_ = GOOGLE_ULONGLONG(0);
  clear_has_vtable();
}
inline ::google::protobuf::uint64 Inst::vtable() const {
  // @@protoc_insertion_point(field_get:machinetalk.Inst.vtable)
  return vtable_;
}
inline void Inst::set_vtable(::google::protobuf::uint64 value) {
  set_has_vtable();
  vtable_ = value;
  // @@protoc_insertion_point(field_set:machinetalk.Inst.vtable)
}

// repeated .machinetalk.Pin pin = 16;
inline int Inst::pin_size() const {
  return pin_.size();
}
inline void Inst::clear_pin() {
  pin_.Clear();
}
inline ::machinetalk::Pin* Inst::mutable_pin(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Inst.pin)
  return pin_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Pin >*
Inst::mutable_pin() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Inst.pin)
  return &pin_;
}
inline const ::machinetalk::Pin& Inst::pin(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Inst.pin)
  return pin_.Get(index);
}
inline ::machinetalk::Pin* Inst::add_pin() {
  // @@protoc_insertion_point(field_add:machinetalk.Inst.pin)
  return pin_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Pin >&
Inst::pin() const {
  // @@protoc_insertion_point(field_list:machinetalk.Inst.pin)
  return pin_;
}

// repeated .machinetalk.Param param = 17;
inline int Inst::param_size() const {
  return param_.size();
}
inline void Inst::clear_param() {
  param_.Clear();
}
inline ::machinetalk::Param* Inst::mutable_param(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Inst.param)
  return param_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Param >*
Inst::mutable_param() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Inst.param)
  return &param_;
}
inline const ::machinetalk::Param& Inst::param(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Inst.param)
  return param_.Get(index);
}
inline ::machinetalk::Param* Inst::add_param() {
  // @@protoc_insertion_point(field_add:machinetalk.Inst.param)
  return param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Param >&
Inst::param() const {
  // @@protoc_insertion_point(field_list:machinetalk.Inst.param)
  return param_;
}

// repeated .machinetalk.Function funct = 19;
inline int Inst::funct_size() const {
  return funct_.size();
}
inline void Inst::clear_funct() {
  funct_.Clear();
}
inline ::machinetalk::Function* Inst::mutable_funct(int index) {
  // @@protoc_insertion_point(field_mutable:machinetalk.Inst.funct)
  return funct_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::machinetalk::Function >*
Inst::mutable_funct() {
  // @@protoc_insertion_point(field_mutable_list:machinetalk.Inst.funct)
  return &funct_;
}
inline const ::machinetalk::Function& Inst::funct(int index) const {
  // @@protoc_insertion_point(field_get:machinetalk.Inst.funct)
  return funct_.Get(index);
}
inline ::machinetalk::Function* Inst::add_funct() {
  // @@protoc_insertion_point(field_add:machinetalk.Inst.funct)
  return funct_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::machinetalk::Function >&
Inst::funct() const {
  // @@protoc_insertion_point(field_list:machinetalk.Inst.funct)
  return funct_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace machinetalk

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_machinetalk_2fprotobuf_2fobject_2eproto
